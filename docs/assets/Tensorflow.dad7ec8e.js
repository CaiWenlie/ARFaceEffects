var K5=Object.defineProperty,Y5=Object.defineProperties;var Z5=Object.getOwnPropertyDescriptors;var wf=Object.getOwnPropertySymbols;var J5=Object.prototype.hasOwnProperty,Q5=Object.prototype.propertyIsEnumerable;var _f=(n,e,t)=>e in n?K5(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t,Vu=(n,e)=>{for(var t in e||(e={}))J5.call(e,t)&&_f(n,t,e[t]);if(wf)for(var t of wf(e))Q5.call(e,t)&&_f(n,t,e[t]);return n},Sf=(n,e)=>Y5(n,Z5(e));import{d as Tf,f as Zl,o as co,g as uo,F as Ef,h as e9,n as Cf,i as t9,t as Mf,j as n9,k as s9,r as r9,l as Vs,w as i9,v as o9,m as a9,p as l9,q as c9,s as u9}from"./vendor.1eebe7e1.js";import{_ as Af}from"./index.bc845bf8.js";function h9(n,e){return e.forEach(function(t){t&&typeof t!="string"&&!Array.isArray(t)&&Object.keys(t).forEach(function(s){if(s!=="default"&&!(s in n)){var r=Object.getOwnPropertyDescriptor(t,s);Object.defineProperty(n,s,r.get?r:{enumerable:!0,get:function(){return t[s]}})}})}),Object.freeze(n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d9=1e-7,p9=1e-4;class f9{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class Rf{refCount(e){return ls("refCount")}incRef(e){return ls("incRef")}timerAvailable(){return!0}time(e){return ls("time")}read(e){return ls("read")}readSync(e){return ls("readSync")}numDataIds(){return ls("numDataIds")}disposeData(e,t){return ls("disposeData")}write(e,t,s){return ls("write")}move(e,t,s,r,i){return ls("move")}memory(){return ls("memory")}floatPrecision(){return ls("floatPrecision")}epsilon(){return this.floatPrecision()===32?d9:p9}dispose(){return ls("dispose")}}function ls(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jl(n,e,t){return Math.max(n,Math.min(e,t))}function If(n){return n%2==0?n:n+1}function ka(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function m9(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function O(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function As(n,e,t=""){O(Qt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Gu(n){O(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ho(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||Gs(n)&&!t)for(let s=0;s<n.length;++s)ho(n[s],e,t);else e.push(n);return e}function Se(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Qt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function $a(n){return n%1==0}function Wu(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function po(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function Nf(n,e=s=>0,t){return new Promise((s,r)=>{let i=0;const o=()=>{if(n()){s();return}i++;const a=e(i);if(t!=null&&i>=t){r();return}setTimeout(o,a)};o()})}function g9(n,e){let t=1,s=-1;for(let i=0;i<n.length;++i)if(n[i]>=0)t*=n[i];else if(n[i]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${i}`);s=i}else if(n[i]<0)throw Error(`Shapes can not be < 0. Found ${n[i]} at dim ${i}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!=0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const r=n.slice();return r[s]=e/t,r}function gn(n,e){const t=e.length;return n=n==null?e.map((s,r)=>r):[].concat(n),O(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),O(n.every(s=>$a(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Or(n,e){const t=[],s=[],r=e!=null&&Array.isArray(e)&&e.length===0,i=e==null||r?null:gn(e,n).sort();let o=0;for(let a=0;a<n.length;++a){if(i!=null){if(i[o]===a&&n[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${n[a]}' is not 1`);(i[o]==null||i[o]>a)&&n[a]===1&&(t.push(n[a]),s.push(a)),i[o]<=a&&o++}n[a]!==1&&(t.push(n[a]),s.push(a))}return{newShape:t,keptDims:s}}function Br(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function cs(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function x9(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function y9(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function v9(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Gs(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function Hu(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function b9(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Ql(n){return typeof n=="string"||n instanceof String}function w9(n){return typeof n=="boolean"}function _9(n){return typeof n=="number"}function ec(n){return Array.isArray(n)?ec(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":_9(n)?"float32":Ql(n)?"string":w9(n)?"bool":"float32"}function Lf(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Xu(n,e){for(let t=e;t<n;++t)if(n%t==0)return t;return n}function wn(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function Pf(n,e,t,s=!1){const r=new Array;if(e.length===1){const i=e[0]*(s?2:1);for(let o=0;o<i;o++)r[o]=t[n+o]}else{const i=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<i;l++)r[l]=Pf(n+l*a,o,t,s)}return r}function ju(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((r,i)=>r*i)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return Pf(0,n,e,t)}function Df(n,e){const t=zr(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function zr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function kf(n){n.forEach(e=>{O(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function qu(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let r=0;r<n.length-1;++r)s+=t[r]*n[r];return s}function $f(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let r=0;r<s.length-1;++r)s[r]=Math.floor(n/t[r]),n-=s[r]*t[r];return s[s.length-1]=n,s}function Fa(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ff="tfjsflags";class S9{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=T9,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${t}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const r=this.urlFlags[e];ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${r}.`),this.set(e,r)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Fa(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global=="undefined"||typeof this.global.location=="undefined"||typeof this.global.location.search=="undefined")return;const e=this.getQueryParams(this.global.location.search);Ff in e&&e[Ff].split(",").forEach(s=>{const[r,i]=s.split(":");this.urlFlags[r]=C9(r,i)})}}function T9(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(E9(e,s[0],s[1]),s.join("="))),e}function E9(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function C9(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function ee(){return Of}let Of=null;function M9(n){Of=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ku;function Bf(){if(Ku==null){let n;if(typeof window!="undefined")n=window;else if(typeof global!="undefined")n=global;else if(typeof process!="undefined")n=process;else if(typeof self!="undefined")n=self;else throw new Error("Could not find a global object");Ku=n}return Ku}function A9(){const n=Bf();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function Yu(n,e){const t=A9();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const zf="Abs",Uf="Acos",Vf="Acosh",Zu="Add",Gf="AddN",Wf="All",Hf="Any",Xf="ArgMax",jf="ArgMin",qf="Asin",Kf="Asinh",Yf="Atan",Zf="Atanh",Jf="Atan2",Qf="AvgPool",R9="AvgPoolGrad",e0="AvgPool3D",I9="AvgPool3DGrad",t0="BatchMatMul",n0="BatchToSpaceND",s0="Bincount",r0="BroadcastArgs",Ju="Cast",i0="Ceil",o0="ClipByValue",a0="Complex",l0="ComplexAbs",c0="Concat",u0="Conv2D",h0="Conv2DBackpropFilter",d0="Conv2DBackpropInput",p0="Conv3D",N9="Conv3DBackpropFilterV2",L9="Conv3DBackpropInputV2",f0="Cos",m0="Cosh",g0="Cumsum",x0="CropAndResize",y0="DenseBincount",v0="DepthToSpace",b0="DepthwiseConv2dNative",w0="DepthwiseConv2dNativeBackpropFilter",_0="DepthwiseConv2dNativeBackpropInput",P9="Diag",S0="Dilation2D",T0="RealDiv",E0="Einsum",C0="Elu",D9="EluGrad",M0="Erf",A0="Equal",R0="Exp",I0="ExpandDims",N0="Expm1",L0="FFT",P0="Fill",D0="FlipLeftRight",k0="Floor",$0="FloorDiv",F0="FusedBatchNorm",O0="GatherV2",B0="GatherNd",z0="Greater",U0="GreaterEqual",Qu="Identity",V0="IFFT",G0="Imag",k9="IsFinite",$9="IsInf",W0="IsNan",H0="LeakyRelu",X0="Less",j0="LessEqual",q0="LinSpace",K0="Log",Y0="Log1p",Z0="LogicalAnd",J0="LogicalNot",Q0="LogicalOr",em="LRN",F9="LRNGrad",tm="Max",nm="Maximum",sm="MaxPool",O9="MaxPoolGrad",rm="MaxPool3D",B9="MaxPool3DGrad",im="MaxPoolWithArgmax",om="Mean",am="Min",lm="Minimum",cm="MirrorPad",um="Mod",hm="Multinomial",dm="Multiply",pm="Neg",fm="NotEqual",mm="NonMaxSuppressionV3",gm="NonMaxSuppressionV4",xm="NonMaxSuppressionV5",ym="OnesLike",vm="OneHot",bm="Pack",wm="PadV2",_m="Pow",Sm="Prelu",Tm="Prod",Em="Range",Cm="Real",Mm="Reciprocal",Am="Relu",Rm="Reshape",Im="ResizeNearestNeighbor",z9="ResizeNearestNeighborGrad",Nm="ResizeBilinear",U9="ResizeBilinearGrad",Lm="Relu6",Pm="Reverse",Dm="Round",km="Rsqrt",$m="ScatterNd",Fm="Select",Om="Selu",Bm="Slice",zm="Sin",Um="Sinh",Vm="Sign",Gm="Sigmoid",Wm="Softplus",Hm="Sqrt",Xm="Sum",jm="SpaceToBatchND",qm="SplitV",Km="Softmax",Ym="SparseFillEmptyRows",Zm="SparseReshape",Jm="SparseSegmentMean",Qm="SparseSegmentSum",e1="SparseToDense",t1="SquaredDifference",V9="Square",n1="StridedSlice",s1="StringNGrams",r1="StringSplit",i1="StringToHashBucketFast",o1="Sub",a1="Tan",l1="Tanh",eh="Tile",c1="TopK",u1="Transform",h1="Transpose",d1="Unique",p1="Unpack",G9="UnsortedSegmentSum",f1="ZerosLike",m1="Step",th="FromPixels",g1="RotateWithOffset",nh="_FusedMatMul",sh="FusedConv2D",rh="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(...n){ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(...n)}function W9(...n){ee().getBool("IS_TEST")||ee().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tc=Yu("kernelRegistry",()=>new Map),H9=Yu("gradRegistry",()=>new Map);function ih(n,e){const t=v1(n,e);return tc.get(t)}function x1(n){return H9.get(n)}function y1(n){const e=tc.entries(),t=[];for(;;){const{done:s,value:r}=e.next();if(s)break;const[i,o]=r,[a]=i.split("_");a===n&&t.push(o)}return t}function X9(n){const{kernelName:e,backendName:t}=n,s=v1(e,t);tc.has(s)&&Rs(`The kernel '${e}' for backend '${t}' is already registered`),tc.set(s,n)}function v1(n,e){return`${e}_${n}`}var gr=typeof globalThis!="undefined"?globalThis:typeof window!="undefined"?window:typeof global!="undefined"?global:typeof self!="undefined"?self:{},oh=zt,us=null;try{us=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function zt(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}zt.prototype.__isLong__;Object.defineProperty(zt.prototype,"__isLong__",{value:!0});function Xn(n){return(n&&n.__isLong__)===!0}zt.isLong=Xn;var b1={},w1={};function bi(n,e){var t,s,r;return e?(n>>>=0,(r=0<=n&&n<256)&&(s=w1[n],s)?s:(t=Ut(n,(n|0)<0?-1:0,!0),r&&(w1[n]=t),t)):(n|=0,(r=-128<=n&&n<128)&&(s=b1[n],s)?s:(t=Ut(n,n<0?-1:0,!1),r&&(b1[n]=t),t))}zt.fromInt=bi;function hs(n,e){if(isNaN(n))return e?wi:ds;if(e){if(n<0)return wi;if(n>=S1)return A1}else{if(n<=-T1)return jn;if(n+1>=T1)return M1}return n<0?hs(-n,e).neg():Ut(n%fo|0,n/fo|0,e)}zt.fromNumber=hs;function Ut(n,e,t){return new zt(n,e,t)}zt.fromBits=Ut;var nc=Math.pow;function ah(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return ds;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var s;if((s=n.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return ah(n.substring(1),e,t).neg();for(var r=hs(nc(t,8)),i=ds,o=0;o<n.length;o+=8){var a=Math.min(8,n.length-o),l=parseInt(n.substring(o,o+a),t);if(a<8){var c=hs(nc(t,a));i=i.mul(c).add(hs(l))}else i=i.mul(r),i=i.add(hs(l))}return i.unsigned=e,i}zt.fromString=ah;function Is(n,e){return typeof n=="number"?hs(n,e):typeof n=="string"?ah(n,e):Ut(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}zt.fromValue=Is;var _1=1<<16,j9=1<<24,fo=_1*_1,S1=fo*fo,T1=S1/2,E1=bi(j9),ds=bi(0);zt.ZERO=ds;var wi=bi(0,!0);zt.UZERO=wi;var mo=bi(1);zt.ONE=mo;var C1=bi(1,!0);zt.UONE=C1;var lh=bi(-1);zt.NEG_ONE=lh;var M1=Ut(4294967295|0,2147483647|0,!1);zt.MAX_VALUE=M1;var A1=Ut(4294967295|0,4294967295|0,!0);zt.MAX_UNSIGNED_VALUE=A1;var jn=Ut(0,2147483648|0,!1);zt.MIN_VALUE=jn;var be=zt.prototype;be.toInt=function(){return this.unsigned?this.low>>>0:this.low};be.toNumber=function(){return this.unsigned?(this.high>>>0)*fo+(this.low>>>0):this.high*fo+(this.low>>>0)};be.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(jn)){var t=hs(e),s=this.div(t),r=s.mul(t).sub(this);return s.toString(e)+r.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var i=hs(nc(e,6),this.unsigned),o=this,a="";;){var l=o.div(i),c=o.sub(l.mul(i)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};be.getHighBits=function(){return this.high};be.getHighBitsUnsigned=function(){return this.high>>>0};be.getLowBits=function(){return this.low};be.getLowBitsUnsigned=function(){return this.low>>>0};be.getNumBitsAbs=function(){if(this.isNegative())return this.eq(jn)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&(e&1<<t)==0;t--);return this.high!=0?t+33:t+1};be.isZero=function(){return this.high===0&&this.low===0};be.eqz=be.isZero;be.isNegative=function(){return!this.unsigned&&this.high<0};be.isPositive=function(){return this.unsigned||this.high>=0};be.isOdd=function(){return(this.low&1)==1};be.isEven=function(){return(this.low&1)==0};be.equals=function(e){return Xn(e)||(e=Is(e)),this.unsigned!==e.unsigned&&this.high>>>31==1&&e.high>>>31==1?!1:this.high===e.high&&this.low===e.low};be.eq=be.equals;be.notEquals=function(e){return!this.eq(e)};be.neq=be.notEquals;be.ne=be.notEquals;be.lessThan=function(e){return this.comp(e)<0};be.lt=be.lessThan;be.lessThanOrEqual=function(e){return this.comp(e)<=0};be.lte=be.lessThanOrEqual;be.le=be.lessThanOrEqual;be.greaterThan=function(e){return this.comp(e)>0};be.gt=be.greaterThan;be.greaterThanOrEqual=function(e){return this.comp(e)>=0};be.gte=be.greaterThanOrEqual;be.ge=be.greaterThanOrEqual;be.compare=function(e){if(Xn(e)||(e=Is(e)),this.eq(e))return 0;var t=this.isNegative(),s=e.isNegative();return t&&!s?-1:!t&&s?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};be.comp=be.compare;be.negate=function(){return!this.unsigned&&this.eq(jn)?jn:this.not().add(mo)};be.neg=be.negate;be.add=function(e){Xn(e)||(e=Is(e));var t=this.high>>>16,s=this.high&65535,r=this.low>>>16,i=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,h=0,d=0,p=0;return p+=i+c,d+=p>>>16,p&=65535,d+=r+l,h+=d>>>16,d&=65535,h+=s+a,u+=h>>>16,h&=65535,u+=t+o,u&=65535,Ut(d<<16|p,u<<16|h,this.unsigned)};be.subtract=function(e){return Xn(e)||(e=Is(e)),this.add(e.neg())};be.sub=be.subtract;be.multiply=function(e){if(this.isZero())return ds;if(Xn(e)||(e=Is(e)),us){var t=us.mul(this.low,this.high,e.low,e.high);return Ut(t,us.get_high(),this.unsigned)}if(e.isZero())return ds;if(this.eq(jn))return e.isOdd()?jn:ds;if(e.eq(jn))return this.isOdd()?jn:ds;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(E1)&&e.lt(E1))return hs(this.toNumber()*e.toNumber(),this.unsigned);var s=this.high>>>16,r=this.high&65535,i=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,h=0,d=0,p=0,f=0;return f+=o*u,p+=f>>>16,f&=65535,p+=i*u,d+=p>>>16,p&=65535,p+=o*c,d+=p>>>16,p&=65535,d+=r*u,h+=d>>>16,d&=65535,d+=i*c,h+=d>>>16,d&=65535,d+=o*l,h+=d>>>16,d&=65535,h+=s*u+r*c+i*l+o*a,h&=65535,Ut(p<<16|f,h<<16|d,this.unsigned)};be.mul=be.multiply;be.divide=function(e){if(Xn(e)||(e=Is(e)),e.isZero())throw Error("division by zero");if(us){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?us.div_u:us.div_s)(this.low,this.high,e.low,e.high);return Ut(t,us.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?wi:ds;var s,r,i;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return wi;if(e.gt(this.shru(1)))return C1;i=wi}else{if(this.eq(jn)){if(e.eq(mo)||e.eq(lh))return jn;if(e.eq(jn))return mo;var o=this.shr(1);return s=o.div(e).shl(1),s.eq(ds)?e.isNegative()?mo:lh:(r=this.sub(e.mul(s)),i=s.add(r.div(e)),i)}else if(e.eq(jn))return this.unsigned?wi:ds;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();i=ds}for(r=this;r.gte(e);){s=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(s)/Math.LN2),l=a<=48?1:nc(2,a-48),c=hs(s),u=c.mul(e);u.isNegative()||u.gt(r);)s-=l,c=hs(s,this.unsigned),u=c.mul(e);c.isZero()&&(c=mo),i=i.add(c),r=r.sub(u)}return i};be.div=be.divide;be.modulo=function(e){if(Xn(e)||(e=Is(e)),us){var t=(this.unsigned?us.rem_u:us.rem_s)(this.low,this.high,e.low,e.high);return Ut(t,us.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};be.mod=be.modulo;be.rem=be.modulo;be.not=function(){return Ut(~this.low,~this.high,this.unsigned)};be.and=function(e){return Xn(e)||(e=Is(e)),Ut(this.low&e.low,this.high&e.high,this.unsigned)};be.or=function(e){return Xn(e)||(e=Is(e)),Ut(this.low|e.low,this.high|e.high,this.unsigned)};be.xor=function(e){return Xn(e)||(e=Is(e)),Ut(this.low^e.low,this.high^e.high,this.unsigned)};be.shiftLeft=function(e){return Xn(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?Ut(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Ut(0,this.low<<e-32,this.unsigned)};be.shl=be.shiftLeft;be.shiftRight=function(e){return Xn(e)&&(e=e.toInt()),(e&=63)==0?this:e<32?Ut(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Ut(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};be.shr=be.shiftRight;be.shiftRightUnsigned=function(e){if(Xn(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var s=this.low;return Ut(s>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?Ut(t,0,this.unsigned):Ut(t>>>e-32,0,this.unsigned)};be.shru=be.shiftRightUnsigned;be.shr_u=be.shiftRightUnsigned;be.toSigned=function(){return this.unsigned?Ut(this.low,this.high,!1):this};be.toUnsigned=function(){return this.unsigned?this:Ut(this.low,this.high,!0)};be.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};be.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};be.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};zt.fromBytes=function(e,t,s){return s?zt.fromBytesLE(e,t):zt.fromBytesBE(e,t)};zt.fromBytesLE=function(e,t){return new zt(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};zt.fromBytesBE=function(e,t){return new zt(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};var q9=Object.freeze(h9({__proto__:null,[Symbol.toStringTag]:"Module",default:oh},[oh]));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _i=oh||q9;function sc(n){return _i.fromString(n,!0,16)}const R1=sc("c3a5c85c97cb3127"),Si=sc("b492b66fbe98f273"),Mn=sc("9ae16a3b2f90404f");function ch(n){return n.xor(n.shru(47))}function I1(n,e,t){const s=n.slice(e,e+t);return _i.fromBytes(Array.from(s),!0,!0)}function kt(n,e){return I1(n,e,8)}function N1(n,e){return I1(n,e,4)}function an(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Ur(n,e,t=sc("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let r=e.xor(s).mul(t);return r=r.xor(r.shru(47)),r=r.mul(t),r}function K9(n,e,t,s,r,i){r=r.add(n),i=an(i.add(r).add(s),21);const o=r;return r=r.add(e),r=r.add(t),i=i.add(an(r,44)),[r.add(s),i.add(o)]}function rc(n,e,t,s){return K9(kt(n,e),kt(n,e+8),kt(n,e+16),kt(n,e+24),t,s)}function Y9(n,e=n.length){if(e>=8){const t=Mn.add(e*2),s=kt(n,0).add(Mn),r=kt(n,e-8),i=an(r,37).mul(t).add(s),o=an(s,25).add(r).mul(t);return Ur(i,o,t)}if(e>=4){const t=Mn.add(e*2),s=N1(n,0);return Ur(s.shl(3).add(e),N1(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],r=n[e-1],i=t+(s<<8),o=e+(r<<2);return ch(Mn.mul(i).xor(R1.mul(o))).mul(Mn)}return Mn}function Z9(n,e=n.length){const t=Mn.add(e*2),s=kt(n,0).mul(Si),r=kt(n,8),i=kt(n,e-8).mul(t),o=kt(n,e-16).mul(Mn);return Ur(an(s.add(r),43).add(an(i,30)).add(o),s.add(an(r.add(Mn),18)).add(i),t)}function J9(n,e=n.length){const t=Mn.add(e*2),s=kt(n,0).mul(Mn),r=kt(n,8),i=kt(n,e-8).mul(t),o=kt(n,e-16).mul(Mn),a=an(s.add(r),43).add(an(i,30)).add(o),l=Ur(a,s.add(an(r.add(Mn),18)).add(i),t),c=kt(n,16).mul(t),u=kt(n,24),h=a.add(kt(n,e-32)).mul(t),d=l.add(kt(n,e-24)).mul(t);return Ur(an(c.add(u),43).add(an(h,30)).add(d),c.add(an(u.add(s),18)).add(h),t)}function Q9(n,e=n.length){const t=_i.fromNumber(81,!0);if(e<=32)return e<=16?Y9(n,e):Z9(n,e);if(e<=64)return J9(n,e);let s=t,r=t.mul(Si).add(113),i=ch(r.mul(Mn).add(113)).mul(Mn),o=[_i.UZERO,_i.UZERO],a=[_i.UZERO,_i.UZERO];s=s.mul(Mn).add(kt(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do s=an(s.add(r).add(o[0]).add(kt(n,l+8)),37).mul(Si),r=an(r.add(o[1]).add(kt(n,l+48)),42).mul(Si),s=s.xor(a[1]),r=r.add(o[0]).add(kt(n,l+40)),i=an(i.add(a[0]),33).mul(Si),o=rc(n,l,o[1].mul(Si),s.add(a[0])),a=rc(n,l+32,i.add(a[1]),r.add(kt(n,l+16))),[i,s]=[s,i],l+=64;while(l!==c);const h=Si.add(i.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),s=an(s.add(r).add(o[0]).add(kt(n,l+8)),37).mul(h),r=an(r.add(o[1]).add(kt(n,l+48)),42).mul(h),s=s.xor(a[1].mul(9)),r=r.add(o[0].mul(9).add(kt(n,l+40))),i=an(i.add(a[0]),33).mul(h),o=rc(n,l,o[1].mul(h),s.add(a[0])),a=rc(n,l+32,i.add(a[1]),r.add(kt(n,l+16))),[i,s]=[s,i],Ur(Ur(o[0],a[0],h).add(ch(r).mul(R1)).add(i),Ur(o[1],a[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function go(n,e){return e==="string"?Ti(n):uh([n],e)}function e6(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function uh(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=ho(n)),ee().getBool("DEBUG")&&x9(n,e),e6(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Ns(){return ee().platform.now()}function Ti(n,e="utf-8"){return e=e||"utf-8",ee().platform.encode(n,e)}function Oa(n,e="utf-8"){return e=e||"utf-8",ee().platform.decode(n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t6{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new s6)}profileKernel(e,t,s){let r;const i=()=>{r=s()};let o;const a=Ns();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(i);else{i();for(const c of r)c.dataSync();o=Promise.resolve({kernelMs:Ns()-a})}if(ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<r.length;c++){const u=r[c];u.data().then(h=>{n6(h,u.dtype,e)})}return{kernelName:e,outputs:r,inputs:t,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:r,inputs:i,extraInfo:o}=e;s.forEach(a=>{Promise.all([a.data(),r,o]).then(l=>{this.logger.logKernelProfile(t,a,l[0],l[1],i,l[2])})})}}function n6(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const r=n[s];if(isNaN(r)||!isFinite(r))return console.warn(`Found ${r} in the result of '${t}'`),!0}return!1}class s6{logKernelProfile(e,t,s,r,i,o){const a=typeof r=="number"?po(`${r}ms`,9):r.error,l=po(e,25),c=t.rank,u=t.size,h=po(t.shape.toString(),14);let d="";for(const p in i){const f=i[p];if(f!=null){const m=f.shape||t.shape,y=m.length;d+=`${p}: ${y}D ${y>0?m:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${h}	%c${u}	%c${d}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6(n,e,t){const s={},r={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const d=u[h];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){c.outputs.forEach(m=>s[m.id]=!0),p=!0,r[c.id]=!0;break}if(p)break}}const i={};i[t.id]=!0;const o={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(i[c.outputs[h].id]){for(const d in u)i[u[d].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<n.length;l++){const c=n[l];if(r[c.id]&&o[c.id]){const u={};for(const d in c.inputs){const p=c.inputs[d];s[p.id]&&(u[d]=p)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,a.push(h)}}return a}function i6(n,e,t,s){for(let r=e.length-1;r>=0;r--){const i=e[r],o=[];if(i.outputs.forEach(l=>{const c=n[l.id];c!=null?o.push(c):o.push(null)}),i.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${i.kernelName}.`);const a=i.gradient(o);for(const l in i.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=t(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=i.inputs[l];if(!Qt(c.shape,u.shape))throw new Error(`Error in gradient for op ${i.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=s(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L1=20,Ba=3,hh=7;function o6(n,e,t,s){const r=wn(e),i=a6(n,e,t,r),o=e.length,a=ic(n,e,t,r,i),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function a6(n,e,t,s){const r=Se(e),i=s[s.length-1],o=new Array(i).fill(0),a=e.length,l=t==="complex64"?Ua(n):n;if(a>1)for(let c=0;c<r/i;c++){const u=c*i;for(let h=0;h<i;h++)o[h]=Math.max(o[h],za(l[u+h],0,t).length)}return o}function za(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed(hh))} + ${parseFloat(n[1].toFixed(hh))}j`:Ql(n)?s=`'${n}'`:t==="bool"?s=P1(n):s=parseFloat(n.toFixed(hh)).toString(),po(s,e)}function P1(n){return n===0?"false":"true"}function ic(n,e,t,s,r,i=!0){const o=t==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(t==="complex64"){const m=Ua(n);return[za(m[0],0,t)]}return t==="bool"?[P1(n[0])]:[n[0].toString()]}if(l===1){if(a>L1){const y=Ba*o;let g=Array.from(n.slice(0,y)),x=Array.from(n.slice((a-Ba)*o,a*o));return t==="complex64"&&(g=Ua(g),x=Ua(x)),["["+g.map((b,w)=>za(b,r[w],t)).join(", ")+", ..., "+x.map((b,w)=>za(b,r[a-Ba+w],t)).join(", ")+"]"]}const m=t==="complex64"?Ua(n):Array.from(n);return["["+m.map((y,g)=>za(y,r[g],t)).join(", ")+"]"]}const c=e.slice(1),u=s.slice(1),h=s[0]*o,d=[];if(a>L1){for(let m=0;m<Ba;m++){const y=m*h,g=y+h;d.push(...ic(n.slice(y,g),c,t,u,r,!1))}d.push("...");for(let m=a-Ba;m<a;m++){const y=m*h,g=y+h;d.push(...ic(n.slice(y,g),c,t,u,r,m===a-1))}}else for(let m=0;m<a;m++){const y=m*h,g=y+h;d.push(...ic(n.slice(y,g),c,t,u,r,m===a-1))}const p=l===2?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=`,
`;for(let m=2;m<l;m++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(i?"":f),d}function Ua(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Va{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=Se(e),s!=null){const r=s.length;O(r===this.size,()=>`Length of values '${r}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||cs(t,this.size),this.strides=wn(e)}set(e,...t){t.length===0&&(t=[0]),O(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const r of e){if(r<0||r>=this.shape[t]){const i=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(i)}t++}let s=e[e.length-1];for(let r=0;r<e.length-1;++r)s+=this.strides[r]*e[r];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ws().makeTensor(this.values,this.shape,this.dtype)}}let Ws=null,xo=null;function l6(n){Ws=n}function c6(n){xo=n}class Zt{constructor(e,t,s,r){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Se(e),this.strides=wn(e),this.dataId=s,this.id=r,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return xo.buffer(this.shape,this.dtype,e)}bufferSync(){return xo.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ju(this.shape,e,this.dtype==="complex64")}arraySync(){return ju(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ws().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Oa(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataSync(){this.throwIfDisposed();const e=Ws().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Oa(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ws().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ws().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return xo.print(this,e)}clone(){return this.throwIfDisposed(),xo.clone(this)}toString(e=!1){const t=this.dataSync();return o6(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),xo.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Ws().makeVariable(this,e,t,s)}}Object.defineProperty(Zt,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function u6(){return Yu("Tensor",()=>Zt)}u6();class dh extends Zt{constructor(e,t,s,r){super(e.shape,e.dtype,e.dataId,r);this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Qt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ws().disposeTensor(this),this.dataId=e.dataId,Ws().incRef(this,null)}dispose(){Ws().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(dh,Symbol.hasInstance,{value:n=>n instanceof Zt&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var D1;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(D1||(D1={}));var ph;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(ph||(ph={}));var fh;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(fh||(fh={}));var mh;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(mh||(mh={}));var gh;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(gh||(gh={}));const h6={float32:mh,int32:ph,bool:fh,complex64:gh};function Hs(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return h6[n][e]}function xh(n){return Hs(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kt(n,e){if(n.dtype===e.dtype)return[n,e];const t=Hs(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function k1(n){const e=[],t=new Set;return $1(n,e,t),e}function $1(n,e,t){if(n==null)return;if(n instanceof Zt){e.push(n);return}if(!d6(n))return;const s=n;for(const r in s){const i=s[r];t.has(i)||(t.add(i),$1(i,e,t))}}function d6(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yh(n){return n.kernelName!=null}class F1{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class yo{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new F1}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(Rs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new t6(this.backendInstance),!0}setupRegisteredKernels(){y1(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){y1(e).forEach(s=>{s.disposeFunc!=null&&s.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Rf)&&typeof s.then=="function"){const r=++this.pendingBackendInitId,i=s.then(o=>r<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(r<this.pendingBackendInitId||(this.pendingBackendInit=null,Rs(`Initialization of backend ${e} failed`),Rs(o.stack||o.message)),!1));return this.pendingBackendInit=i,{success:i,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return Rs(`Initialization of backend ${e} failed`),Rs(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:r,asyncInit:i}=this.initializeBackend(s);if(i||r)return{name:s,asyncInit:i}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),r=s.backend,i=this.readSync(t),o=r.refCount(t);r.disposeData(t,!0),s.backend=e,e.move(t,i,s.shape,s.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let r;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(r),()=>(r=t(),r instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),r))}scopedRun(e,t,s){e();try{const r=s();return t(),r}catch(r){throw t(),r}}nextTensorId(){return yo.nextTensorId++}nextVariableId(){return yo.nextVariableId++}clone(e){const t=G.runKernel(Qu,{x:e}),s={x:e},r=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return G.runKernel(Ju,l,c)}}),i=[];return this.addTapeNode(this.state.activeScope.name,s,[t],r,i,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,!(ih(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const r=this.backend.numDataIds();let i=0;s.forEach(l=>{i+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=r-t-i-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const r=this.isTapeOn(),i=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=yh(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(yh(e)){const{kernelName:f,inputs:m,attrs:y}=e;this.backendName==null&&this.backend;const g=ih(f,this.backendName);O(g!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),a=()=>{const x=this.backend.numDataIds();l=g.kernelFunc({inputs:m,attrs:y,backend:this.backend});const b=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,x,b);const w=b.map(C=>{if(C.rank!=null)return C;const{dataId:M,shape:E,dtype:A}=C;return this.makeTensorFromDataId(M,E,A)});if(r){const C=this.getTensorsForGradient(f,m,w);s=this.saveTensorsForBackwardMode(C)}return w}}else{const{forwardFunc:f}=e,m=y=>{!r||(s=y.map(g=>this.keep(this.clone(g))))};a=()=>{const y=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,m));const g=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,y,g),g}}const{inputs:u,attrs:h}=e,d=yh(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=a():(p=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),r&&this.addTapeNode(c,u,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-i,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(s=>this.keep(this.clone(s)))}getTensorsForGradient(e,t,s){const r=x1(e);if(r!=null){const i=r.inputsToSave||[],o=r.outputsToSave||[];let a;r.saveAllInputs?(O(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(t).map(c=>t[c])):a=i.map(c=>t[c]);const l=s.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,t,s,r){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",r=r||this.backend;let i=e;s==="string"&&Ql(e[0])&&(i=e.map(l=>Ti(l)));const o=r.write(i,t,s),a=new Zt(t,s,o,this.nextTensorId());if(this.trackTensor(a,r),s==="string"){const l=this.state.tensorInfo.get(o),c=b9(i);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,t,s,r){s=s||"float32";const i=new Zt(t,s,e,this.nextTensorId());return this.trackTensor(i,r),i}makeVariable(e,t=!0,s,r){s=s||this.nextVariableId().toString(),r!=null&&r!==e.dtype&&(e=e.cast(r));const i=new dh(e,t,s,this.nextTensorId());if(this.state.registeredVariables[i.name]!=null)throw new Error(`Variable with name ${i.name} was already registered`);return this.state.registeredVariables[i.name]=i,this.incRef(i,this.backend),i}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Hu(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof dh||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Hu(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(r=>r.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const r of this.state.activeProfile.kernels)r.kernelTimeMs=await r.kernelTimeMs,r.extraInfo=await r.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,r,i,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:i},l=x1(e);l!=null&&(r=l.gradFunc),r!=null&&(a.gradient=c=>(c=c.map((u,h)=>{if(u==null){const d=s[h],p=zr(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),r(c.length>1?c:c[0],i,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=k1(e),s=new Set(t.map(i=>i.id));for(let i=0;i<this.state.activeScope.track.length;i++){const o=this.state.activeScope.track[i];!o.kept&&!s.has(o.id)&&o.dispose()}const r=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(i=>{!i.kept&&i.scopeId===r.id&&this.track(i)})}gradients(e,t,s,r=!1){if(O(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const i=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));O(i instanceof Zt,()=>"The result y returned by f() must be a tensor.");const o=r6(this.state.activeTape,t,i);if(!r&&o.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[i.id]=s==null?p6(i.shape):s,i6(a,o,c=>this.tidy(c),f6);const l=t.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:i,grads:l}})}customGrad(e){return O(Lf(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{O(t.every(a=>a instanceof Zt),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const r={};t.forEach((a,l)=>{r[l]=a});const i=(a,l)=>(s=e(...t,l),O(s.value instanceof Zt,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),O(Lf(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),o=(a,l)=>{const c=s.gradFunc(a,l),u=Array.isArray(c)?c:[c];O(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),O(u.every(d=>d instanceof Zt),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:i,backwardsFunc:o,inputs:r})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}async time(e){const t=Ns(),s=await this.backend.time(e);return s.wallMs=Ns()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new F1;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}yo.nextTensorId=0;yo.nextVariableId=0;function p6(n){const e=Df(Se(n),"float32");return G.makeTensor(e,n,"float32")}function O1(){const n=Bf();if(n._tfengine==null){const e=new S9(n);n._tfengine=new yo(e)}return M9(n._tfengine.ENV),l6(()=>n._tfengine),n._tfengine}const G=O1();function f6(n,e){const t={a:n,b:e};return G.runKernel(Zu,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m6(){return typeof navigator!="undefined"&&navigator!=null}function B1(n){if(n||m6()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window!="undefined"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function z1(){return typeof window!="undefined"&&window.document!=null||typeof WorkerGlobalScope!="undefined"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ls=ee();Ls.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Ls.registerFlag("IS_BROWSER",()=>z1());Ls.registerFlag("IS_NODE",()=>typeof process!="undefined"&&typeof process.versions!="undefined"&&typeof process.versions.node!="undefined");Ls.registerFlag("IS_CHROME",()=>typeof navigator!="undefined"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Ls.registerFlag("PROD",()=>!1);Ls.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Ls.getBool("DEBUG"));Ls.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Ls.registerFlag("IS_TEST",()=>!1);Ls.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);Ls.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ga(n,e){let t=n;if(Gs(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Gs(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&U1(n,s,[]),s}function U1(n,e,t){if(t=t||[],!Array.isArray(n)&&!Gs(n)){O(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}O(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),O(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let r=0;r<n.length;++r)U1(n[r],s,t.concat(r))}function V1(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function P(n,e,t,s="numeric"){if(n instanceof Zt)return V1(s,n.dtype,e,t),n;let r=ec(n);if(r!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(r=s),V1(s,r,e,t),n==null||!Gs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const l=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${l}'`)}const i=Ga(n,r);!Gs(n)&&!Array.isArray(n)&&(n=[n]);const a=r!=="string"?uh(n,r):ho(n,[],!0);return G.makeTensor(a,i,r)}function G1(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,o)=>P(i,`${e}[${o}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g6="__op";function W(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+g6;const r=(...i)=>{G.startScope(t);try{const o=s(...i);return Fa(o)&&console.error("Cannot return a Promise inside of tidy."),G.endScope(o),o}catch(o){throw G.endScope(null),o}};return Object.defineProperty(r,"name",{value:t,configurable:!0}),r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x6(n,e){const t=P(n,"real","complex"),s=P(e,"imag","complex");As(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const r={real:t,imag:s};return G.runKernel(a0,r)}const Ei=W({complex_:x6});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wa(n,e,t,s){if(s==null&&(s=ec(n)),s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Gs(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){kf(e);const r=Se(e),i=Se(t);O(r===i,()=>`Based on the provided shape, [${e}], the tensor should have ${r} values but has ${i}`);for(let o=0;o<t.length;++o){const a=t[o],l=o===t.length-1?a!==Se(e.slice(o)):!0;O(t[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Gs(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?uh(n,s):ho(n,[],!0),G.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vr(n,e,t){const s=Ga(n,t);return Wa(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W1={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H1=4;function y6(n,e){const t={};let s,r=0;for(const i of e){const o=i.name,a=i.dtype,l=i.shape,c=Se(l);let u;if("quantization"in i){const h=i.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${i.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${i.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${i.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=W1[h.dtype],p=n.slice(r,r+c*d),f=h.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(a==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){u=new Float32Array(f.length);for(let m=0;m<f.length;m++){const y=f[m];u[m]=y*h.scale+h.min}}else if(h.dtype==="float16")s===void 0&&(s=C6()),u=s(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(a==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);u=new Int32Array(f.length);for(let m=0;m<f.length;m++){const y=f[m];u[m]=Math.round(y*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*d}else if(a==="string"){const h=Se(i.shape);u=[];for(let d=0;d<h;d++){const p=new Uint32Array(n.slice(r,r+H1))[0];r+=H1;const f=new Uint8Array(n.slice(r,r+p));u.push(f),r+=p}}else{const h=W1[a],d=n.slice(r,r+c*h);if(a==="float32")u=new Float32Array(d);else if(a==="int32")u=new Int32Array(d);else if(a==="bool")u=new Uint8Array(d);else if(a==="complex64"){u=new Float32Array(d);const p=new Float32Array(u.length/2),f=new Float32Array(u.length/2);for(let g=0;g<p.length;g++)p[g]=u[g*2],f[g]=u[g*2+1];const m=Vr(p,l,"float32"),y=Vr(f,l,"float32");t[o]=Ei(m,y),m.dispose(),y.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);r+=c*h}a!=="complex64"&&(t[o]=Vr(u,l,a))}return t}const vh=typeof Buffer!="undefined"&&(typeof Blob=="undefined"||typeof atob=="undefined"||typeof btoa=="undefined");function X1(n){return vh?Buffer.byteLength(n):new Blob([n]).size}function v6(n){if(vh)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function b6(n){if(vh){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function w6(n){if(n.length===1)return n[0];let e=0;n.forEach(r=>{e+=r.byteLength});const t=new Uint8Array(e);let s=0;return n.forEach(r=>{t.set(new Uint8Array(r),s),s+=r.byteLength}),t.buffer}function j1(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}async function _6(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),n.weightsManifest!=null){const[s,r]=await e(n.weightsManifest);t.weightSpecs=s,t.weightData=r}return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),t}function oc(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:X1(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:X1(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function S6(){const n=t=>{let s=t<<13,r=0;for(;(s&8388608)==0;)r-=8388608,s<<=1;return s&=~8388608,r+=947912704,s|r},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function T6(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function E6(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function C6(){const n=S6(),e=T6(),t=E6();return s=>{const r=new ArrayBuffer(4*s.length),i=new Uint32Array(r);for(let o=0;o<s.length;o++){const a=s[o],l=n[t[a>>10]+(a&1023)]+e[a>>10];i[o]=l}return new Float32Array(r)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return sn.instance==null&&(sn.instance=new sn),sn.instance}static registerSaveRouter(e){sn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){sn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return sn.getHandlers(e,"save")}static getLoadHandlers(e,t){return sn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const r=[];return(t==="load"?sn.getInstance().loadRouters:sn.getInstance().saveRouters).forEach(o=>{const a=o(e,s);a!==null&&r.push(a)}),r}}const M6=n=>sn.getSaveHandlers(n),A6=(n,e)=>sn.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bh="tensorflowjs",wh=1,Ci="models_store",Gr="model_info_store";function q1(){if(!ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window=="undefined"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function _h(n){const e=n.result;e.createObjectStore(Ci,{keyPath:"modelPath"}),e.createObjectStore(Gr,{keyPath:"modelPath"})}class Mi{constructor(e){if(this.indexedDB=q1(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,r)=>{const i=this.indexedDB.open(bh,wh);i.onupgradeneeded=()=>_h(i),i.onsuccess=()=>{const o=i.result;if(t==null){const a=o.transaction(Ci,"readonly"),c=a.objectStore(Ci).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),r(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(c.result.modelArtifacts)},c.onerror=u=>(o.close(),r(c.error)),a.oncomplete=()=>o.close()}else{const a=oc(t),l=o.transaction(Gr,"readwrite");let c=l.objectStore(Gr);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let h;u.onsuccess=()=>{h=o.transaction(Ci,"readwrite");const p=h.objectStore(Ci).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});p.onsuccess=()=>s({modelArtifactsInfo:a}),p.onerror=f=>{c=l.objectStore(Gr);const m=c.delete(this.modelPath);m.onsuccess=()=>(o.close(),r(p.error)),m.onerror=y=>(o.close(),r(p.error))}},u.onerror=d=>(o.close(),r(u.error)),l.oncomplete=()=>{h==null?o.close():h.oncomplete=()=>o.close()}}},i.onerror=o=>r(i.error)})}}Mi.URL_SCHEME="indexeddb://";const K1=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Mi.URL_SCHEME)?R6(n.slice(Mi.URL_SCHEME.length)):null;sn.registerSaveRouter(K1);sn.registerLoadRouter(K1);function R6(n){return new Mi(n)}function I6(n){return n.startsWith(Mi.URL_SCHEME)?n.slice(Mi.URL_SCHEME.length):n}class N6{constructor(){this.indexedDB=q1()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(bh,wh);s.onupgradeneeded=()=>_h(s),s.onsuccess=()=>{const r=s.result,i=r.transaction(Gr,"readonly"),a=i.objectStore(Gr).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(r.close(),t(a.error)),i.oncomplete=()=>r.close()},s.onerror=r=>t(s.error)})}async removeModel(e){return e=I6(e),new Promise((t,s)=>{const r=this.indexedDB.open(bh,wh);r.onupgradeneeded=()=>_h(r),r.onsuccess=()=>{const i=r.result,o=i.transaction(Gr,"readwrite"),a=o.objectStore(Gr),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return i.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),h=()=>{c=i.transaction(Ci,"readwrite");const p=c.objectStore(Ci).delete(e);p.onsuccess=()=>t(l.result.modelArtifactsInfo),p.onerror=f=>s(l.error)};u.onsuccess=h,u.onerror=d=>(h(),i.close(),s(l.error))}},l.onerror=u=>(i.close(),s(l.error)),o.oncomplete=()=>{c==null?i.close():c.oncomplete=()=>i.close()}},r.onerror=i=>s(r.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xr="/",vo="tensorflowjs_models",Y1="info",L6="model_topology",P6="weight_specs",D6="weight_data",k6="model_metadata";function Z1(n){return{info:[vo,n,Y1].join(xr),topology:[vo,n,L6].join(xr),weightSpecs:[vo,n,P6].join(xr),weightData:[vo,n,D6].join(xr),modelMetadata:[vo,n,k6].join(xr)}}function J1(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function $6(n){const e=n.split(xr);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(xr)}function F6(n){return n.startsWith(Ai.URL_SCHEME)?n.slice(Ai.URL_SCHEME.length):n}class Ai{constructor(e){if(!ee().getBool("IS_BROWSER")||typeof window=="undefined"||typeof window.localStorage=="undefined")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=Z1(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),r=oc(e);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,v6(e.weightData));const i={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(i)),{modelArtifactsInfo:r}}catch{throw J1(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${r.modelTopologyBytes}, weightSpecsBytes=${r.weightSpecsBytes}, weightDataBytes=${r.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const r=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(r==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=r;const i=this.LS.getItem(this.keys.modelMetadata);if(i!=null){const a=JSON.parse(i);t.format=a.format,t.generatedBy=a.generatedBy,t.convertedBy=a.convertedBy,a.signature!=null&&(t.signature=a.signature),a.userDefinedMetadata!=null&&(t.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(t.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(t.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=b6(o),t}}Ai.URL_SCHEME="localstorage://";const Q1=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ai.URL_SCHEME)?O6(n.slice(Ai.URL_SCHEME.length)):null;sn.registerSaveRouter(Q1);sn.registerLoadRouter(Q1);function O6(n){return new Ai(n)}class B6{constructor(){O(ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),O(typeof window=="undefined"||typeof window.localStorage!="undefined",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=vo+xr,s=xr+Y1;for(let r=0;r<this.LS.length;++r){const i=this.LS.key(r);if(i.startsWith(t)&&i.endsWith(s)){const o=$6(i);e[o]=JSON.parse(this.LS.getItem(i))}}return e}async removeModel(e){e=F6(e);const t=Z1(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return J1(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e2="://";class Wr{constructor(){this.managers={}}static getInstance(){return Wr.instance==null&&(Wr.instance=new Wr),Wr.instance}static registerManager(e,t){O(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(e2)&&(e=e.slice(0,e.indexOf(e2))),O(e.length>0,()=>"scheme must not be an empty string.");const s=Wr.getInstance();O(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=this.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(this.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z6{fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}}if(ee().get("IS_BROWSER")){ee().setPlatform("browser",new z6);try{Wr.registerManager(Ai.URL_SCHEME,new B6)}catch{}try{Wr.registerManager(Mi.URL_SCHEME,new N6)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U6={importFetch:()=>require("node-fetch")};let Sh;class V6{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ee().global.fetch!=null?ee().global.fetch(e,t):(Sh==null&&(Sh=U6.importFetch()),Sh(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}ee().get("IS_NODE")&&ee().setPlatform("node",new V6);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xn(n,e="float32",t){return e=e||"float32",kf(n),new Va(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G6(n,e){const t=P(n,"x","cast");if(!y9(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},r={dtype:e};return G.runKernel(Ju,s,r)}const Xt=W({cast_:G6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W6(n){const t={x:P(n,"x","clone","string_or_numeric")};return G.runKernel(Qu,t)}const Ri=W({clone_:W6});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H6(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */O1();const X6={buffer:xn,cast:Xt,clone:Ri,print:H6};c6(X6);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j6="model",q6=".json",K6=".weights.bin";function t2(n){return new Promise(e=>setTimeout(e)).then(n)}class Ii{constructor(e){if(!ee().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ii.URL_SCHEME)&&(e=e.slice(Ii.URL_SCHEME.length)),(e==null||e.length===0)&&(e=j6),this.modelJsonFileName=e+q6,this.weightDataFileName=e+K6}async save(e){if(typeof document=="undefined")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],r=j1(e,s),i=window.URL.createObjectURL(new Blob([JSON.stringify(r)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=i,await t2(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=t,await t2(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:oc(e)}}}}Ii.URL_SCHEME="downloads://";const Y6=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ii.URL_SCHEME)?Z6(n.slice(Ii.URL_SCHEME.length)):null;sn.registerSaveRouter(Y6);function Z6(n="model"){return new Ii(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n2(n,e,t,s){o(n),t=t==null?0:t,s=s==null?1:s,a(t,s);let r=0;const i=l=>(l.then(c=>{const u=t+ ++r/n.length*(s-t);return e(u),c}),l);function o(l){O(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){O(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),O(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),O(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(i))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function J6(n,e){e==null&&(e={});const t=e.fetchFunc==null?ee().platform.fetch:e.fetchFunc,s=n.map(h=>t(h,e.requestInit,{isBinary:!0})),r=0,i=.5,a=(e.onProgress==null?await Promise.all(s):await n2(s,e.onProgress,r,i)).map(h=>h.arrayBuffer()),l=.5,c=1;return e.onProgress==null?await Promise.all(a):await n2(a,e.onProgress,l,c)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q6="application/octet-stream",ev="application/json";class Th{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(O(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ee().platform.fetch,O(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&O(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],r=j1(e,s);t.body.append("model.json",new Blob([JSON.stringify(r)],{type:ev}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:Q6}),"model.weights.bin");const i=await this.fetch(this.path,t);if(i.ok)return{modelArtifactsInfo:oc(e),responses:[i]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${i.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const s=t.modelTopology,r=t.weightsManifest;if(s==null&&r==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return _6(t,i=>this.loadWeights(i))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,r]=tv(t),i=this.weightPathPrefix||s,o=[];for(const u of e)o.push(...u.weights);const a=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):a.push(i+h+r);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await J6(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,w6(c)]}}Th.URL_SCHEME_REGEX=/^https?:\/\//;function tv(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),r=t>e?n.substring(t):"";return[s+"/",r]}function s2(n){return n.match(Th.URL_SCHEME_REGEX)!=null}const r2=(n,e)=>{if(typeof fetch=="undefined"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>s2(s)):t=s2(n),t)return i2(n,e)}return null};sn.registerSaveRouter(r2);sn.registerLoadRouter(r2);function i2(n,e){return new Th(n,e)}function o2(n,e){return i2(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nv(n,e,t=!1,s=!1){let r=P(n,"a","matMul"),i=P(e,"b","matMul");[r,i]=Kt(r,i);const o={a:r,b:i},a={transposeA:t,transposeB:s};return G.runKernel(t0,o,a)}const ln=W({matMul_:nv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sv(n,e,t=1,s=0){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const i={indices:P(n,"indices","oneHot","int32")},o={depth:e,onValue:t,offValue:s};return G.runKernel(vm,i,o)}const rv=W({oneHot_:sv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iv(n,e){const t=P(n,"x","transpose");if(e==null&&(e=t.shape.map((i,o)=>o).reverse()),O(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of perm ${e}.`),e.forEach(i=>{O(i>=0&&i<t.rank,()=>`All entries in 'perm' must be between 0 and ${t.rank-1} but got ${e}`)}),t.rank<=1)return t.clone();const s={x:t},r={perm:e};return G.runKernel(h1,s,r)}const Eh=W({transpose_:iv});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ac(n,e){const t=n.length,s=[];for(let r=0;r<t;r++){const i=t-1-r,o=n[i]||1;(e[e.length-1-r]||1)>1&&o===1&&s.unshift(i)}return s}function a2(n,e){const t=[];for(let s=0;s<e.length;s++){const r=n[n.length-s-1],i=e.length-s-1,o=e[i];(r==null||r===1&&o>1)&&t.unshift(i)}return t}function Ct(n,e){const t=[],s=Math.max(n.length,e.length);for(let r=0;r<s;r++){let i=n[n.length-r-1];i==null&&(i=1);let o=e[e.length-r-1];if(o==null&&(o=1),i===1)t.unshift(o);else if(o===1)t.unshift(i);else if(i!==o){const a=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(a)}else t.unshift(i)}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ov(n,e,t){if(Gu(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=Ga(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Wa(n,e,s,t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Ni;function av(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,r=!1,i=!1,o=!1,a=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData!="undefined"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement!="undefined"&&n instanceof HTMLVideoElement)r=!0;else if(typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement)i=!0;else if(n.getContext!=null)o=!0;else if(typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(r){const f=2;if(r&&n.readyState<f)throw new Error("The video element has not loaded data yet. Please wait for `loadeddata` event on the <video> element.")}if(ih(th,G.backendName)!=null){const f={pixels:n},m={numChannels:e};return G.runKernel(th,f,m)}const[c,u]=r?[n.videoWidth,n.videoHeight]:[n.width,n.height];let h;if(o)h=n.getContext("2d").getImageData(0,0,c,u).data;else if(s||t)h=n.data;else if(i||r||a){if(Ni==null)if(typeof document=="undefined")if(typeof OffscreenCanvas!="undefined"&&typeof OffscreenCanvasRenderingContext2D!="undefined")Ni=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else Ni=document.createElement("canvas").getContext("2d");Ni.canvas.width=c,Ni.canvas.height=u,Ni.drawImage(n,0,0,c,u),h=Ni.getImageData(0,0,c,u).data}let d;if(e===4)d=new Int32Array(h);else{const f=c*u;d=new Int32Array(f*e);for(let m=0;m<f;m++)for(let y=0;y<e;++y)d[m*e+y]=h[m*4+y]}return ov(d,[u,c,e],"int32")}const l2=W({fromPixels_:av});function c2(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(Se(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const r=e.shape,i=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const a=n.shape,l=r.slice();l.pop();let c=1;for(let h=i;h<t;++h)c*=a[h],l.push(a[h]);const u=[...wn(n.shape).map(h=>h/c),1].slice(0,i);return[l,o,c,u]}function u2(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,r=e.rank>1?e.rank-1:1,i=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${r}.`;if(t.rank<r)throw new Error(i+` update.rank < ${r}. `);if(n.length<s+(t.rank-r))throw new Error(i+` Output shape length < ${s+(t.rank-r)}`);if(t.rank!==r+n.length-s)throw new Error(i+` update.rank != ${r+n.length-s}`);for(let o=0;o<r;++o)if(t.shape[o]!==e.shape[o])throw new Error(i+` updates.shape[${o}] (${t.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<t.rank-r;++o)if(t.shape[o+r]!==n[o+s])throw new Error(i+` updates.shape[${o+r}] (${t.shape[o+r]}) != shape[${o+r}] (${n[o+r]})`)}function h2(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}u2(t,e,n)}function Ch(n,e,t){const s=e.shape.length,r=s>1?e.shape[s-1]:1,i=t.length;let o=1;for(let h=r;h<i;++h)o*=t[h];const a=r<1?1:r,l=Se(e.shape)/a,c=[...wn(t.slice(0,r)),1],u=Se(t);return{sliceRank:r,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mh=-2,lv=-1;function d2(n,e,t){const s=n.shape.length;O(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),O(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let r=0;r<s;++r)O(e[r]+t[r]<=n.shape[r],()=>`Error in slice${s}D: begin[${r}] + size[${r}] (${e[r]+t[r]}) would overflow input.shape[${r}] (${n.shape[r]})`)}function cv(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function p2(n,e,t){const s=[];for(let r=0;r<n.length;r++)s[r]=Math.ceil((e[r]-n[r])/t[r]);return s}function f2(n,e,t,s){const r=[...n];for(let i=r.length;i<s.length;i++)r.push(1);for(let i=0;i<t;i++)i===0?r[e]=1:(r.splice(e,0,1),r.pop());return r}function m2(n,e,t){return t<=n?t:t-(e-1)}function g2(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function uv(n,e,t,s,r,i,o,a,l){const c=n.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&t>0){const p=e[0],f=t+1;u=x2(o,p,f,s,n),h=y2(a,p,f,r,n),d=f2(i,p,f,n)}else for(let p=0;p<c;p++)u[p]=b2(o,s,i,n,p,l),h[p]=w2(a,r,i,n,p,l),d[p]=v2(i,p,l);return{begin:u,end:h,strides:d}}function x2(n,e,t,s,r){const i=[...r],o=g2(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=0;else{const l=m2(e,t,a);let c=s[l];n&1<<l&&(c=0),i[a]=c}return i}function y2(n,e,t,s,r){const i=[...r],o=g2(t,e);for(let a=0;a<i.length;a++)if(o.indexOf(a)>-1)i[a]=Number.MAX_SAFE_INTEGER;else{const l=m2(e,t,a);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),i[a]=c}for(let a=0;a<i.length;a++){const l=r[a];i[a]<0&&(i[a]+=l),i[a]=Jl(0,i[a],r[a])}return i}function v2(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function b2(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),o=Jl(0,o,l-1),o}function w2(n,e,t,s,r,i){let o=e[r];const a=t[r]||1;(n&1<<r||i&1<<r||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=s[r];return o<0&&(o+=l),a>0?o=Jl(0,o,l):o=Jl(-1,o,l-1),o}function Ah(n,e,t){let s=t.length;for(let r=0;r<t.length;r++)if(t[r]>1){s=r;break}for(let r=s+1;r<t.length;r++)if(e[r]>0||t[r]!==n[r])return!1;return!0}function Rh(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function _2(n,e,t){let s;const r=n.shape.length;typeof e=="number"?s=[e,...new Array(r-1).fill(0)]:e.length<r?s=e.concat(new Array(r-e.length).fill(0)):s=e.slice(),s.forEach(o=>{O(o!==-1,()=>"slice() does not support negative begin indexing.")});let i;return t==null?i=new Array(r).fill(-1):typeof t=="number"?i=[t,...new Array(r-1).fill(-1)]:t.length<r?i=t.concat(new Array(r-t.length).fill(-1)):i=t,i=i.map((o,a)=>o>=0?o:(O(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),n.shape[a]-s[a])),[s,i]}function S2(n,e,t,s,r,i,o,a,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,o!=null&&(o&o-1)!=0)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)u&&(1<<b&a)!=0&&h.numAddAxisAfterEllipsis++,1<<b&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};hv(h,d);let p=!0,f=!0,m=!0;const y=[],g=[];for(let b=0;b<n.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const w=!!(d.shrinkAxisMask&1<<b),C=n[b];if(C===-1){y.push(w?1:-1);continue}const M=[d.beginMask&1<<b,d.endMask&1<<b],E=[d.strides[b]>0?0:-1,d.strides[b]>0?C:C-1];if(w&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&d.strides[b]===1;const A=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(w){const K=d.begin[b]<0?C+d.begin[b]:d.begin[b];if(d.begin[b]=K,d.end[b]=d.begin[b]+1,K<0||K>=C)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=T2(d.begin[b],0,d.strides[b],C,M,E),d.end[b]=T2(d.end[b],1,d.strides[b],C,M,E);const R=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===C;p=p&&R,f=f&&(b===0&&d.strides[b]===1||R)}else p=p&&d.strides[b]===1&&A,f=f&&(b===0&&d.strides[b]===1||A);let $,B=!1;if(d.beginValid&&d.endValid?($=d.end[b]-d.begin[b],B=!0):w?($=1,B=!0):A&&C>=0&&(d.strides[b]<0?$=-C:$=C,B=!0),B){let R;$===0||$<0!=d.strides[b]<0?R=0:R=Math.trunc($/d.strides[b])+($%d.strides[b]!=0?1:0),y.push(R)}else y.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const w=d.finalShapeGatherIndices[b];w>=0?g.push(y[w]):w===Mh&&g.push(1)}return{finalShapeSparse:g.filter((b,w)=>d.finalShapeGatherIndices[w]!==Mh),finalShape:g,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function hv(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const r=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<r;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(Mh),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(lv),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function T2(n,e,t,s,r,i){if(r[e])return t>0?i[e]:i[e+1&1];{const o=n<0?s+n:n;return o<i[0]?i[0]:o>i[1]?i[1]:o}}var dv=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",assertParamsValid:d2,maskToAxes:cv,computeOutShape:p2,stridesWithElidedDims:f2,getNormalizedAxes:uv,startIndicesWithElidedDims:x2,stopIndicesWithElidedDims:y2,stridesForAxis:v2,startForAxis:b2,stopForAxis:w2,isSliceContinous:Ah,computeFlatOffset:Rh,parseSliceParams:_2,sliceInfo:S2});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(){return G}function xt(n,e){return G.tidy(n,e)}function pv(n){k1(n).forEach(t=>t.dispose())}function Hr(n){return G.keep(n)}function fv(n){return G.setBackend(n)}function mv(){return G.backendName}function gv(n,e,t=1){return G.registerBackend(n,e,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xv(n,e){let t=P(n,"a","add"),s=P(e,"b","add");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel(Zu,r)}const _n=W({add_:xv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(n,e){let t=P(n,"a","floorDiv"),s=P(e,"b","floorDiv");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel($0,r)}const E2=W({floorDiv_:yv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n,e){let t=P(n,"a","div"),s=P(e,"b","div");if([t,s]=Kt(t,s),t.dtype==="int32"&&s.dtype==="int32")return E2(t,s);const r={a:t,b:s},i={};return G.runKernel(T0,r,i)}const rn=W({div_:vv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bv(n,e){let t=P(n,"a","mul"),s=P(e,"b","mul");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel(dm,r)}const tt=W({mul_:bv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wv(n){const e=P(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return G.runKernel(l0,t)}else{const t={x:e};return G.runKernel(zf,t)}}const ps=W({abs_:wv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _v(n){const t={x:P(n,"x","acos")};return G.runKernel(Uf,t)}const Sv=W({acos_:_v});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tv(n){const t={x:P(n,"x","acosh")};return G.runKernel(Vf,t)}const Ev=W({acosh_:Tv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cv(n){O(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),O(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((r,i)=>P(r,`tensors${i}`,"addN")),t=e[0];e.forEach(r=>{if(r.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(r=>{if(!Qt(r.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return G.runKernel(Gf,s)}const Mv=W({addN_:Cv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Av(n,e=null,t=!1){const r={x:P(n,"x","all","bool")},i={axis:e,keepDims:t};return G.runKernel(Wf,r,i)}const Rv=W({all_:Av});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iv(n,e=null,t=!1){const r={x:P(n,"x","any","bool")},i={axis:e,keepDims:t};return G.runKernel(Hf,r,i)}const Nv=W({any_:Iv});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lv(n,e=0){const s={x:P(n,"x","argMax")},r={axis:e};return G.runKernel(Xf,s,r)}const Pv=W({argMax_:Lv});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dv(n,e=0){const s={x:P(n,"x","argMin")},r={axis:e};return G.runKernel(jf,s,r)}const kv=W({argMin_:Dv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n){const t={x:P(n,"x","asin")};return G.runKernel(qf,t)}const Fv=W({asin_:$v});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ov(n){const t={x:P(n,"x","asinh")};return G.runKernel(Kf,t)}const Bv=W({asinh_:Ov});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zv(n){const t={x:P(n,"x","atan")};return G.runKernel(Yf,t)}const Uv=W({atan_:zv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vv(n,e){let t=P(n,"a","atan2"),s=P(e,"b","atan2");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel(Jf,r)}const Gv=W({atan2_:Vv});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wv(n){const t={x:P(n,"x","atanh")};return G.runKernel(Zf,t)}const Hv=W({atanh_:Wv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2(n,e,t,s,r="NHWC",i){const o=n[3],a=[...e,o],l=_o(r);return ns(n,a,t,i,s,null,null,l)}function bo(n,e,t,s,r,i,o="channelsLast"){const[a,l]=lc(e);let c;if(o==="channelsLast")c=[a,l,n[3],n[3]];else if(o==="channelsFirst")c=[a,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ns(n,c,t,s,r,i,!1,o)}function Xa(n,e,t,s,r,i,o="NDHWC"){const[a,l,c]=Nh(e);let u,h;if(o==="NDHWC")h="channelsLast",u=[a,l,c,n[4],n[4]];else if(o==="NCDHW")h="channelsFirst",u=[a,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${o}`);return ja(n,u,t,s,r,!1,h,i)}function ns(n,e,t,s,r,i,o=!1,a="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h]=n;else if(a==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${a}`);const[d,p,,f]=e,[m,y]=lc(t),[g,x]=lc(s),b=wo(d,g),w=wo(p,x),{padInfo:C,outHeight:M,outWidth:E}=qv(r,c,u,m,y,b,w,i,a),A=o?f*h:f;let $;return a==="channelsFirst"?$=[l,A,M,E]:a==="channelsLast"&&($=[l,M,E,A]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:h,outHeight:M,outWidth:E,outChannels:A,padInfo:C,strideHeight:m,strideWidth:y,filterHeight:d,filterWidth:p,effectiveFilterHeight:b,effectiveFilterWidth:w,dilationHeight:g,dilationWidth:x,inShape:n,outShape:$,filterShape:e}}function ja(n,e,t,s,r,i=!1,o="channelsLast",a){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h,d]=n;else if(o==="channelsFirst")[l,d,c,u,h]=n;else throw new Error(`Unknown dataFormat ${o}`);const[p,f,m,,y]=e,[g,x,b]=Nh(t),[w,C,M]=Nh(s),E=wo(p,w),A=wo(f,C),$=wo(m,M),{padInfo:B,outDepth:R,outHeight:K,outWidth:F}=Kv(r,c,u,h,g,x,b,E,A,$,a),z=i?y*d:y;let V;return o==="channelsFirst"?V=[l,z,R,K,F]:o==="channelsLast"&&(V=[l,R,K,F,z]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:R,outHeight:K,outWidth:F,outChannels:z,padInfo:B,strideDepth:g,strideHeight:x,strideWidth:b,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:E,effectiveFilterHeight:A,effectiveFilterWidth:$,dilationDepth:w,dilationHeight:C,dilationWidth:M,inShape:n,outShape:V,filterShape:e}}function Xv(n,e,t,s,r){s==null&&(s=Ih(n,e,t));const i=n[0],o=n[1],a=Li((i-e+2*s)/t+1,r),l=Li((o-e+2*s)/t+1,r);return[a,l]}function jv(n,e,t,s,r,i){r==null&&(r=Ih(n,e,s));const o=n[0],a=n[1],l=n[2],c=Li((o-e+2*r)/s+1,i),u=Li((a-e+2*r)/s+1,i),h=Li((l-e+2*r)/s+1,i);return[c,u,h,t]}function Ih(n,e,t,s=1){const r=wo(e,s);return Math.floor((n[0]*(t-1)-t+r)/2)}function lc(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function Nh(n){return typeof n=="number"?[n,n,n]:n}function wo(n,e){return e<=1?n:n+(n-1)*(e-1)}function qv(n,e,t,s,r,i,o,a,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const p=Xv([e,t],i,s,n,a);u=p[0],h=p[1]}else if(n==="same"){u=Math.ceil(e/s),h=Math.ceil(t/r);const d=Math.max(0,(u-1)*s+i-e),p=Math.max(0,(h-1)*r+o-t),f=Math.floor(d/2),m=d-f,y=Math.floor(p/2),g=p-y;c={top:f,bottom:m,left:y,right:g,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-i+1)/s),h=Math.ceil((t-o+1)/r);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],m=l==="channelsLast"?n[2][1]:n[3][1];c={top:d,bottom:p,left:f,right:m,type:d===0&&p===0&&f===0&&m===0?"VALID":"EXPLICIT"},u=Li((e-i+d+p)/s+1,a),h=Li((t-o+f+m)/r+1,a)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function Kv(n,e,t,s,r,i,o,a,l,c,u){let h,d,p,f;if(typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=jv([e,t,s,1],a,1,r,n,u);d=y[0],p=y[1],f=y[2]}else if(n==="same"){d=Math.ceil(e/r),p=Math.ceil(t/i),f=Math.ceil(s/o);const m=(d-1)*r+a-e,y=(p-1)*i+l-t,g=(f-1)*o+c-s,x=Math.floor(m/2),b=m-x,w=Math.floor(y/2),C=y-w,M=Math.floor(g/2),E=g-M;h={top:w,bottom:C,left:M,right:E,front:x,back:b,type:"SAME"}}else if(n==="valid")h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((e-a+1)/r),p=Math.ceil((t-l+1)/i),f=Math.ceil((s-c+1)/o);else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Li(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function qa(n){const[e,t,s]=lc(n);return e===1&&t===1&&s===1}function ss(n,e){return qa(n)||qa(e)}function _o(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function fs(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")O($a(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(r=>{O($a(r),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${r}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yv(n,e){const s={x:P(n,"x","reshape","string_or_numeric")},r={shape:e};return G.runKernel(Rm,s,r)}const de=W({reshape_:Yv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zv(n,e,t,s,r){const i=P(n,"x","avgPool","float32"),o=1;O(ss(t,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`);let a=i,l=!1;i.rank===3&&(l=!0,a=de(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),fs("avgPool",s,r);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r};let h=G.runKernel(Qf,c,u);return h=Xt(h,i.dtype),l?de(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Jv=W({avgPool_:Zv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qv(n,e,t,s,r,i="NDHWC"){const o=P(n,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=de(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),O(i==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),fs("avgPool3d",s,r);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i};let h=G.runKernel(e0,c,u);return h=Xt(h,a.dtype),l?de(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const e8=W({avgPool3d_:Qv});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(n,e=0){O(n.length>=1,()=>"Pass at least one tensor to concat");const t=G1(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(i=>{if(i.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${i.dtype}. `)}),t.length===1)return Ri(t[0]);const s=t,r={axis:e};return G.runKernel(c0,s,r)}const Sn=W({concat_:t8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n8(n){const t={x:P(n,"x","sigmoid","float32")};return G.runKernel(Gm,t)}const Lh=W({sigmoid_:n8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(n,e,t){const s=P(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const r={x:s},i={begin:e,size:t};return G.runKernel(Bm,r,i)}const dt=W({slice_:s8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(n){const t={x:P(n,"x","tanh","float32")};return G.runKernel(l1,t)}const i8=W({tanh_:r8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n,e,t){const s=P(n,"x","batchToSpaceND"),r=e.reduce((a,l)=>a*l);O(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),O(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),O(s.shape[0]%r==0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${r}`);const i={x:s},o={blockShape:e,crops:t};return G.runKernel(n0,i,o)}const a8=W({batchToSpaceND_:o8});function l8(n){let e;return n.rank===0||n.rank===1?e=de(n,[1,1,1,n.size]):n.rank===2?e=de(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=de(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(n,e,t,s,r,i){i==null&&(i=.001);const o=P(n,"x","batchNorm"),a=P(e,"mean","batchNorm"),l=P(t,"variance","batchNorm");let c;r!=null&&(c=P(r,"scale","batchNorm"));let u;s!=null&&(u=P(s,"offset","batchNorm")),O(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:l8(o),scale:c,offset:u,mean:a,variance:l},p={varianceEpsilon:i},f=G.runKernel(F0,d,p);return de(f,o.shape)}const M2=W({batchNorm_:c8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u8(n,e,t){const s=P(n,"x","bincount"),r=P(e,"weights","bincount");O(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(r.size===s.size||r.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${r.shape}.`);const i={x:s,weights:r},o={size:t};return G.runKernel(s0,i,o)}const A2=W({bincount_:u8});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n,e){const t=P(n,"s0","broadcastArgs","int32"),s=P(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const r={s0:t,s1:s};return G.runKernel(r0,r)}const d8=W({broadcastArgs_:h8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p8(n,e){let t=P(n,"broadcastTo","x");const s=t.shape;if(e.some(c=>!(c>0)||c%1!=0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const c=t.shape.slice();for(;c.length<e.length;)c.unshift(1);t=de(t,c)}const r=t.shape,i=Array.from(e);for(let c=e.length-1;c>=0;c--)if(r[c]===e[c])i[c]=1;else if(t.shape[c]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(i.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return Ri(t);const a={x:t},l={reps:i};return G.runKernel(eh,a,l)}const cc=W({broadcastTo_:p8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f8(n){const t={x:P(n,"x","ceil","float32")};return G.runKernel(i0,t)}const m8=W({ceil_:f8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g8(n,e,t){const s=P(n,"x","clipByValue");O(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`);const r={x:s},i={clipValueMin:e,clipValueMax:t};return G.runKernel(o0,r,i)}const x8=W({clipByValue_:g8});function y8(n,e){return Sn(n,e)}const R2=W({concat2d_:y8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8(n,e,t,s,r="NHWC",i=[1,1],o){const a=P(n,"x","conv2d","float32"),l=P(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=de(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),O(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),fs("conv2d",s,o);const h=r==="NHWC"?c.shape[3]:c.shape[1];O(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),O(ss(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`);const d={x:c,filter:l},p={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},f=G.runKernel(u0,d,p);return u?de(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Ph=W({conv2d_:v8});function b8(n,e,t,s,r="NWC",i=1,o){const a=P(n,"x","conv1d"),l=P(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=de(a,[1,a.shape[0],a.shape[1]])),O(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),O(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),fs("conv1d",s,o),O(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),O(ss(t,i),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${i}'`),O(r==="NWC",()=>`Error in conv1d: got dataFormat of ${r} but only NWC is currently supported.`);const h=de(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=de(c,[c.shape[0],1,c.shape[1],c.shape[2]]),y=Ph(d,h,[1,t],s,"NHWC",[1,i],o);return u?de(y,[y.shape[2],y.shape[3]]):de(y,[y.shape[0],y.shape[2],y.shape[3]])}const w8=W({conv1d_:b8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _8(n,e,t,s,r,i="NHWC",o){O(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,l=e,c=!1;e.rank===3&&(c=!0,l=de(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,n[0],n[1],n[2]]),O(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),O(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),O(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=i==="NHWC"?a[3]:a[1],h=i==="NHWC"?l.shape[3]:l.shape[1];O(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),O(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),fs("conv2dDerInput",r,o);const d={dy:l,filter:t},p={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,inputShape:a},f=G.runKernel(d0,d,p);return c?de(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const I2=W({conv2DBackpropInput_:_8});function S8(n,e,t,s,r,i){const o=P(n,"x","conv2dTranspose"),a=P(e,"filter","conv2dTranspose");return I2(t,o,a,s,r,"NHWC",i)}const T8=W({conv2dTranspose_:S8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8(n,e,t,s,r="NDHWC",i=[1,1,1]){const o=P(n,"x","conv3d"),a=P(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=de(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),O(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),O(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),O(ss(t,i),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),O(r==="NDHWC",()=>`Error in conv3d: got dataFormat of ${r} but only NDHWC is currently supported.`);const u={x:l,filter:a},h={strides:t,pad:s,dataFormat:r,dilations:i},d=G.runKernel(p0,u,h);return c?de(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const C8=W({conv3d_:E8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M8(n){const t={x:P(n,"x","cos","float32")};return G.runKernel(f0,t)}const A8=W({cos_:M8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R8(n){const t={x:P(n,"x","cosh","float32")};return G.runKernel(m0,t)}const I8=W({cosh_:R8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N8(n,e=0,t=!1,s=!1){const i={x:P(n,"x","cumsum")},o={axis:e,exclusive:t,reverse:s};return G.runKernel(g0,i,o)}const L8=W({cumsum_:N8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P8(n,e,t,s=!1){const r=P(n,"x","denseBincount"),i=P(e,"weights","denseBincount");O(r.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${r.dtype}`),O(r.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${r.rank}.`),O(t>=0,()=>`size must be non-negative, but got ${t}.`),O(i.size===r.size||i.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${r.shape}, weights shape: ${i.shape}.`);const o={x:r,weights:i},a={size:t,binaryOutput:s};return G.runKernel(y0,o,a)}const D8=W({denseBincount_:P8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k8(n,e,t="NHWC"){const s=P(n,"x","depthToSpace","float32"),r=t==="NHWC"?s.shape[1]:s.shape[2],i=t==="NHWC"?s.shape[2]:s.shape[3],o=t==="NHWC"?s.shape[3]:s.shape[1];O(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),O(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e}  for depthToSpace with input shape
    ${s.shape}`),O(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e} for depthToSpace with input shape
        ${s.shape}`),O(o%(e*e)==0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${s.shape}`);const a={x:s},l={blockSize:e,dataFormat:t};return G.runKernel(v0,a,l)}const $8=W({depthToSpace_:k8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F8(n,e,t,s,r="NHWC",i=[1,1],o){const a=P(n,"x","depthwiseConv2d","float32"),l=P(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=de(a,[1,a.shape[0],a.shape[1],a.shape[2]])),O(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),O(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`),O(c.shape[3]===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),fs("depthwiseConv2d",s,o);const h={x:c,filter:l},d={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o},p=G.runKernel(b0,h,d);return u?de(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const N2=W({depthwiseConv2d_:F8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O8(n,e,t,s,r=[1,1],i="NHWC"){const o=P(n,"x","dilation2d"),a=P(e,"filter","dilation2d");O(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),O(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),O(i==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${i}`);let l=o,c=!1;o.rank===3&&(l=de(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const u={x:l,filter:a},h={strides:t,pad:s,dilations:r},d=G.runKernel(S0,u,h);return c?de(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const B8=W({dilation2d_:O8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z8(n,e){let t=P(n,"a","equal","string_or_numeric"),s=P(e,"b","equal","string_or_numeric");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(A0,r)}const L2=W({equal_:z8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8(n,e,t){const s=P(e,"a","where"),r=P(t,"b","where"),i=P(n,"condition","where","bool"),o=Ct(Ct(i.shape,s.shape),r.shape),a=cc(i,o),l=cc(s,o),c=cc(r,o),u={condition:a,t:l,e:c};return G.runKernel(Fm,u)}const So=W({where_:U8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V8(n){const t={x:P(n,"x","zerosLike")};return G.runKernel(f1,t)}const Dh=W({zerosLike_:V8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G8(n,e){let t=P(n,"a","div"),s=P(e,"b","div");[t,s]=Kt(t,s);const r=rn(t,s),i=Dh(r),o=L2(s,i);return So(o,i,r)}const W8=W({divNoNan_:G8});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H8(n,...e){const t=e.map((r,i)=>P(r,`tensors${i}`,"einsum")),s={equation:n};return G.runKernel(E0,t,s)}const X8=W({einsum_:H8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j8(n){const t={x:P(n,"x","elu","float32")};return G.runKernel(C0,t)}const P2=W({elu_:j8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q8(n){let e=P(n,"x","erf");O(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Xt(e,"float32"));const t={x:e};return G.runKernel(M0,t)}const K8=W({erf_:q8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y8(n){const t={x:P(n,"x","exp")};return G.runKernel(R0,t)}const Pi=W({exp_:Y8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z8(n,e=0){const t=P(n,"x","expandDims","string_or_numeric");O(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},r={dim:e};return G.runKernel(I0,s,r)}const yr=W({expandDims_:Z8});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J8(n){const t={x:P(n,"x","expm1")};return G.runKernel(N0,t)}const Q8=W({expm1_:J8});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eb(n,e){const t=P(n,"x","tile","string_or_numeric");O(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},r={reps:e};return G.runKernel(eh,s,r)}const Ka=W({tile_:eb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tb(n,e,t,s="float32"){e==null&&(e=n);const r=xn([n,e],s),i=n<=e?n:e;for(let a=0;a<i;++a)r.set(1,a,a);const o=de(r.toTensor(),[n,e]);if(t==null)return o;if(t.length===1)return Ka(yr(o,0),[t[0],1,1]);if(t.length===2)return Ka(yr(yr(o,0),0),[t[0],t[1],1,1]);if(t.length===3)return Ka(yr(yr(yr(o,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const nb=W({eye_:tb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kh(n,e,t){const s={shape:n,value:e,dtype:t};return G.runKernel(P0,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(n){const t={x:P(n,"x","floor","float32")};return G.runKernel(k0,t)}const rb=W({floor_:sb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(n,e,t=0,s=0){const r=P(n,"x","gather"),i=P(e,"indices","gather","int32"),o={x:r,indices:i},a={axis:t,batchDims:s};return G.runKernel(O0,o,a)}const D2=W({gather_:ib});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ob(n,e){let t=P(n,"a","greater","string_or_numeric"),s=P(e,"b","greater","string_or_numeric");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(z0,r)}const uc=W({greater_:ob});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ab(n,e){let t=P(n,"a","greaterEqual","string_or_numeric"),s=P(e,"b","greaterEqual","string_or_numeric");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(U0,r)}const k2=W({greaterEqual_:ab});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lb(n){const t={input:P(n,"input","imag")};return G.runKernel(G0,t)}const $h=W({imag_:lb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cb(n){const t={x:P(n,"x","isNaN")};return G.runKernel(W0,t)}const ub=W({isNaN_:cb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hb(n,e=.2){const s={x:P(n,"x","leakyRelu")},r={alpha:e};return G.runKernel(H0,s,r)}const $2=W({leakyRelu_:hb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function db(n,e){let t=P(n,"a","less","string_or_numeric"),s=P(e,"b","less","string_or_numeric");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(X0,r)}const pb=W({less_:db});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fb(n,e){let t=P(n,"a","lessEqual","string_or_numeric"),s=P(e,"b","lessEqual","string_or_numeric");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(j0,r)}const Fh=W({lessEqual_:fb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mb(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return G.runKernel(q0,{},s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gb(n,e=5,t=1,s=1,r=.5){const i=P(n,"x","localResponseNormalization");O(i.rank===4||i.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${i.rank}.`),O($a(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=i,a=!1;i.rank===3&&(a=!0,o=de(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const l={x:o},c={depthRadius:e,bias:t,alpha:s,beta:r},u=G.runKernel(em,l,c);return a?de(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const xb=W({localResponseNormalization_:gb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yb(n){const t={x:P(n,"x","log","float32")};return G.runKernel(K0,t)}const Ya=W({log_:yb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vb(n){const t={x:P(n,"x","log1p")};return G.runKernel(Y0,t)}const F2=W({log1p_:vb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xr(n){return G.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bb(n){const t={x:P(n,"x","neg")};return G.runKernel(pm,t)}const Za=W({neg_:bb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wb(n){const t={x:P(n,"x","softplus")};return G.runKernel(Wm,t)}const _b=W({softplus_:wb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sb(n,e=null,t=!1){const r={x:P(n,"x","max")},i={reductionIndices:e,keepDims:t};return G.runKernel(tm,r,i)}const To=W({max_:Sb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tb(n,e){let t=P(n,"a","sub"),s=P(e,"b","sub");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel(o1,r)}const pt=W({sub_:Tb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eb(n,e=null,t=!1){let s=P(n,"x","sum");s.dtype==="bool"&&(s=Xt(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return G.runKernel(Xm,r,i)}const Vt=W({sum_:Eb});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cb(n,e=-1){const t=P(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Xr((r,i)=>{const o=!0,a=To(r,e,!0),l=pt(r,a),c=pt(Xt(l,"float32"),Ya(Vt(Pi(l),e,o)));return i([c]),{value:c,gradFunc:(h,d)=>{const[p]=d,f=!0,m=Pi(p);return pt(h,tt(Vt(h,e,f),m))}}})(t)}const Mb=W({logSoftmax_:Cb});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oh(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function O2(n,e,t){const s=n.length+e.length,r=[];let i=0,o=0;for(let a=0;a<s;a++)t.indexOf(a)===-1?r.push(n[i++]):r.push(e[o++]);return r}function Xs(n,e){const t=[],s=n.length;for(let i=0;i<s;i++)e.indexOf(i)===-1&&t.push(n[i]);const r=e.map(i=>n[i]);return[t,r]}function ms(n,e){const t=e.map(s=>1);return O2(n,t,e)}function Ps(n,e,t){O(Oh(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function gs(n,e){if(Oh(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Bh(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function xs(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ab(n,e=null,t=!1){const s=P(n,"x","logSumExp"),r=gn(e,s.shape),i=To(s,r,!0),o=pt(s,i),a=Pi(o),l=Vt(a,r),c=Ya(l),u=_n(de(i,c.shape),c);if(t){const h=ms(u.shape,r);return de(u,h)}return u}const Rb=W({logSumExp_:Ab});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ib(n,e){const t=P(n,"a","logicalAnd","bool"),s=P(e,"b","logicalAnd","bool");Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(Z0,r)}const B2=W({logicalAnd_:Ib});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nb(n){const t={x:P(n,"x","logicalNot","bool")};return G.runKernel(J0,t)}const Lb=W({logicalNot_:Nb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pb(n,e){const t=P(n,"a","logicalOr","bool"),s=P(e,"b","logicalOr","bool");Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(Q0,r)}const Db=W({logicalOr_:Pb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kb(n,e,t,s,r){const i=P(n,"x","maxPool"),o=1;let a=i,l=!1;i.rank===3&&(l=!0,a=de(i,[1,i.shape[0],i.shape[1],i.shape[2]])),O(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),O(ss(t,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${o}'`),fs("maxPool",s,r);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r},h=G.runKernel(sm,c,u);return l?de(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const $b=W({maxPool_:kb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fb(n,e=[1,1,1],t,s,r,i="NDHWC"){const o=P(n,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=de(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),O(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),O(i==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${i}`),fs("maxPool3d",s,r);const c={x:a},u={filterSize:e,strides:t,pad:s,dimRoundingMode:r,dataFormat:i},h=G.runKernel(rm,c,u);return l?de(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const Ob=W({maxPool3d_:Fb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bb(n,e,t,s,r=!1){const o={x:P(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:r},l=G.runKernel(im,o,a);return{result:l[0],indexes:l[1]}}const zb=W({maxPoolWithArgmax_:Bb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ub(n,e){let t=P(n,"a","maximum"),s=P(e,"b","maximum");[t,s]=Kt(t,s),t.dtype==="bool"&&(t=Xt(t,"int32"),s=Xt(s,"int32")),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(nm,r)}const Vb=W({maximum_:Ub});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gb(n,e=null,t=!1){const r={x:P(n,"x","mean")},i={axis:e,keepDims:t};return G.runKernel(om,r,i)}const z2=W({mean_:Gb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Di(n,e="float32"){if(e==="complex64"){const s=Di(n,"float32"),r=Di(n,"float32");return Ei(s,r)}const t=zr(Se(n),e);return G.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zh(n,e="float32"){if(e==="complex64"){const s=zh(n,"float32"),r=Di(n,"float32");return Ei(s,r)}const t=Df(Se(n),e);return G.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wb(n,e=null,t=!1){const r={x:P(n,"x","min")},i={axis:e,keepDims:t};return G.runKernel(am,r,i)}const Uh=W({min_:Wb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hb(n,e){let t=P(n,"a","minimum"),s=P(e,"b","minimum");[t,s]=Kt(t,s),t.dtype==="bool"&&(t=Xt(t,"int32"),s=Xt(s,"int32")),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(lm,r)}const U2=W({minimum_:Hb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xb(n,e,t){O(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=P(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");O(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const r=t==="reflect"?1:0;for(let a=0;a<s.rank;a++)O(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),O(e[a][0]>=0&&e[a][0]<=s.shape[a]-r&&e[a][1]>=0&&e[a][1]<=s.shape[a]-r,()=>`Padding in dimension ${a} cannot be greater than or equal to ${s.shape[a]-r} or less than 0 for input of shape ${s.shape}`);const i={paddings:e,mode:t},o={x:s};return G.runKernel(cm,o,i)}const jb=W({mirrorPad_:Xb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qb(n,e){let t=P(n,"a","mod"),s=P(e,"b","mod");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel(um,r)}const Kb=W({mod_:qb});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yb(n){const e=P(n,"x","square"),t={};return G.runKernel("Square",{x:e},t)}const Vh=W({square_:Yb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zb(n,e,t,s=!1){const r=P(n,"logits","multinomial"),i=r.size,o=r.rank;if(i<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${i}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);t=t||Math.random();const l={logits:o===1?de(r,[1,-1]):r},c={numSamples:e,seed:t,normalized:s},u=G.runKernel(hm,l,c);return o===1?de(u,[u.size]):u}const Jb=W({multinomial_:Zb});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qb(n,e){let t=P(n,"a","notEqual","string_or_numeric"),s=P(e,"b","notEqual","string_or_numeric");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s};return G.runKernel(fm,r)}const V2=W({notEqual_:Qb});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(n){const t={x:P(n,"x","onesLike")};return G.runKernel(ym,t)}const t7=W({onesLike_:e7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7(n,e,t=0){const s=P(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:e,constantValue:t},i={x:s};return G.runKernel(wm,i,r)}const s7=W({pad_:n7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r7(n,e,t){const s=P(n,"x","spaceToBatchND");O(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),O(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),O(s.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+t[l-1][0]+t[l-1][1])%e[l-1]==0:o,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const r={x:s},i={blockShape:e,paddings:t};return G.runKernel(jm,r,i)}const i7=W({spaceToBatchND_:r7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7(n,e){let t=P(n,"base","pow"),s=P(e,"exp","pow");[t,s]=Kt(t,s);const r={a:t,b:s};return G.runKernel(_m,r)}const G2=W({pow_:o7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a7(n,e){const t=P(n,"x","prelu"),s=P(e,"alpha","prelu"),r={x:t,alpha:s};return G.runKernel(Sm,r)}const W2=W({prelu_:a7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n,e=null,t=!1){let s=P(n,"x","prod");s.dtype==="bool"&&(s=Xt(s,"int32"));const r={x:s},i={axis:e,keepDims:t};return G.runKernel(Tm,r,i)}const H2=W({prod_:l7});var X2={exports:{}};(function(n){(function(e,t,s){function r(l){var c=this,u=a();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function i(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new r(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&i(h,u),d.state=function(){return i(u,{})}),d}function a(){var l=4022871197,c=function(u){u=u.toString();for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.alea=o})(gr,n,!1)})(X2);var j2={exports:{}};(function(n){(function(e,t,s){function r(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor128=o})(gr,n,!1)})(j2);var q2={exports:{}};(function(n){(function(e,t,s){function r(a){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function i(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorwow=o})(gr,n,!1)})(q2);var K2={exports:{}};(function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var u=l.x,h=l.i,d,p;return d=u[h],d^=d>>>7,p=d^d<<24,d=u[h+1&7],p^=d^d>>>10,d=u[h+3&7],p^=d^d>>>3,d=u[h+4&7],p^=d^d<<7,d=u[h+7&7],d=d^d<<13,p^=d^d<<9,u[h]=p,l.i=h+1&7,p};function c(u,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8&&(p[7]=-1),u.x=p,u.i=0,d=256;d>0;--d)u.next()}c(l,a)}function i(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.x&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xorshift7=o})(gr,n,!1)})(K2);var Y2={exports:{}};(function(n){(function(e,t,s){function r(a){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,p,f;return l.w=u=u+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(u^u>>>16)|0};function c(u,h){var d,p,f,m,y,g=[],x=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,x=Math.max(x,h.length)),f=0,m=-32;m<x;++m)h&&(p^=h.charCodeAt((m+32)%h.length)),m===0&&(y=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,m>=0&&(y=y+1640531527|0,d=g[m&127]^=p+y,f=d==0?f+1:0);for(f>=128&&(g[(h&&h.length||0)&127]=-1),f=127,m=4*128;m>0;--m)p=g[f+34&127],d=g[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,g[f]=p^d;u.w=y,u.X=g,u.i=f}c(l,a)}function i(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.X&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.xor4096=o})(gr,n,!1)})(Y2);var Z2={exports:{}};(function(n){(function(e,t,s){function r(a){var l=this,c="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=2654435769|0,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function i(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new r(a),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&i(u,c),h.state=function(){return i(c,{})}),h}t&&t.exports?t.exports=o:s&&s.amd?s(function(){return o}):this.tychei=o})(gr,n,!1)})(Z2);var J2={exports:{}};(function(n){(function(e,t){var s=this,r=256,i=6,o=52,a="random",l=t.pow(r,i),c=t.pow(2,o),u=c*2,h=r-1,d;function p(w,C,M){var E=[];C=C==!0?{entropy:!0}:C||{};var A=g(y(C.entropy?[w,b(e)]:w==null?x():w,3),E),$=new f(E),B=function(){for(var R=$.g(i),K=l,F=0;R<c;)R=(R+F)*r,K*=r,F=$.g(1);for(;R>=u;)R/=2,K/=2,F>>>=1;return(R+F)/K};return B.int32=function(){return $.g(4)|0},B.quick=function(){return $.g(4)/4294967296},B.double=B,g(b($.S),e),(C.pass||M||function(R,K,F,z){return z&&(z.S&&m(z,$),R.state=function(){return m($,{})}),F?(t[a]=R,K):R})(B,A,"global"in C?C.global:this==t,C.state)}t["seed"+a]=p;function f(w){var C,M=w.length,E=this,A=0,$=E.i=E.j=0,B=E.S=[];for(M||(w=[M++]);A<r;)B[A]=A++;for(A=0;A<r;A++)B[A]=B[$=h&$+w[A%M]+(C=B[A])],B[$]=C;(E.g=function(R){for(var K,F=0,z=E.i,V=E.j,H=E.S;R--;)K=H[z=h&z+1],F=F*r+H[h&(H[z]=H[V=h&V+K])+(H[V]=K)];return E.i=z,E.j=V,F})(r)}function m(w,C){return C.i=w.i,C.j=w.j,C.S=w.S.slice(),C}function y(w,C){var M=[],E=typeof w,A;if(C&&E=="object")for(A in w)try{M.push(y(w[A],C-1))}catch{}return M.length?M:E=="string"?w:w+"\0"}function g(w,C){for(var M=w+"",E,A=0;A<M.length;)C[h&A]=h&(E^=C[h&A]*19)+M.charCodeAt(A++);return b(C)}function x(){try{var w;return d&&(w=d.randomBytes)?w=w(r):(w=new Uint8Array(r),(s.crypto||s.msCrypto).getRandomValues(w)),b(w)}catch{var C=s.navigator,M=C&&C.plugins;return[+new Date,s,M,s.screen,b(e)]}}function b(w){return String.fromCharCode.apply(0,w)}if(g(t.random(),e),n.exports){n.exports=p;try{d=require("crypto")}catch{}}})([],Math)})(J2);var c7=X2.exports,u7=j2.exports,h7=q2.exports,d7=K2.exports,p7=Y2.exports,f7=Z2.exports,ki=J2.exports;ki.alea=c7;ki.xor128=u7;ki.xorwow=h7;ki.xorshift7=d7;ki.xor4096=p7;ki.tychei=f7;var Q2=ki;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class m7{constructor(e,t,s,r,i){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=r,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=i||Math.random();this.random=Q2.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const r=this.nextVal;return this.nextVal=NaN,r}let e,t,s=!1;for(;!s;){let r,i,o;do r=2*this.random()-1,i=2*this.random()-1,o=r*r+i*i;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*r*a,t=this.mean+this.stdDev*i*a,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class g7{constructor(e=0,t=1,s,r){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,r==null&&(r=Math.random()),typeof r=="number"&&(r=r.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Q2.alea(r)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x7(n,e=0,t=1,s="float32",r){const i=xn(n,s),o=new g7(e,t,null,r);for(let a=0;a<i.values.length;a++)i.values[a]=o.nextValue();return i.toTensor()}const y7=W({randomUniform_:x7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ja(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const r={start:n,stop:e,step:t,dtype:s};return G.runKernel(Em,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v7(n){const t={input:P(n,"input","real")};return G.runKernel(Cm,t)}const hc=W({real_:v7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(n){const t={x:P(n,"x","reciprocal")};return G.runKernel(Mm,t)}const w7=W({reciprocal_:b7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(n){const t={x:P(n,"x","relu")};return G.runKernel(Am,t)}const dc=W({relu_:_7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(n){const t={x:P(n,"x","relu6")};return G.runKernel(Lm,t)}const eg=W({relu6_:S7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(n,e){const s={x:P(n,"x","reverse")},r={dims:e};return G.runKernel(Pm,s,r)}const pc=W({reverse_:T7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E7(n){const t={x:P(n,"x","round")};return G.runKernel(Dm,t)}const tg=W({round_:E7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C7(n){const t={x:P(n,"x","rsqrt","float32")};return G.runKernel(km,t)}const M7=W({rsqrt_:C7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mt(n,e){if((Gs(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Gs(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Wa(n,[],[],e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A7(n){const t={x:P(n,"x","selu")};return G.runKernel(Om,t)}const R7=W({selu_:A7});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function I7(n,e){const t=P(n,"x","setdiff1d"),s=P(e,"y","setdiff1d");O(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),O(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),O(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const r=await t.data(),i=await s.data(),o=new Set(i);let a=0;for(let u=0;u<r.length;u++)o.has(r[u])||a++;const l=new Va([a],t.dtype),c=new Va([a],"int32");for(let u=0,h=0;u<r.length;u++)o.has(r[u])||(l.values[h]=r[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const N7=I7;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(n){const t={x:P(n,"x","sign")};return G.runKernel(Vm,t)}const P7=W({sign_:L7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D7(n){const t={x:P(n,"x","sin","float32")};return G.runKernel(zm,t)}const k7=W({sin_:D7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $7(n){const t={x:P(n,"x","sinh")};return G.runKernel(Um,t)}const F7=W({sinh_:$7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O7(n,e=-1){const t=P(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},r={dim:e};return G.runKernel(Km,s,r)}const B7=W({softmax_:O7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z7(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return G.runKernel(L0,e)}const ng=W({fft_:z7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U7(n){O(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return G.runKernel(V0,e)}const Gh=W({ifft_:U7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V7(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const r=de(n,[t,e]);s=Gh(r)}else{const r=[t,2*(e-1)],i=de(hc(n),[t,e]),o=de($h(n),[t,e]),a=pc(dt(i,[0,1],[t,e-2]),1),l=tt(pc(dt(o,[0,1],[t,e-2]),1),Mt(-1)),c=Sn([i,a],1),u=Sn([o,l],1),h=de(Ei(c,u),[r[0],r[1]]);s=Gh(h)}if(s=hc(s),n.rank===3&&n.shape[0]!==0){const r=s,i=n.shape[0];s=de(s,[i,s.shape[0]/i,s.shape[1]]),r.dispose()}return s}const G7=W({irfft_:V7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7(n,e,t=0){const r={x:P(n,"x","split")},i={numOrSizeSplits:e,axis:t};return G.runKernel(qm,r,i)}const Qa=W({split_:W7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H7(n,e){O(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let r;if(e!=null&&e<t){const f=n.shape.map(y=>0),m=n.shape.map(y=>y);m[n.shape.length-1]=e,r=dt(n,f,m),t=e}else if(e!=null&&e>t){const f=n.shape.map(m=>m);f[n.shape.length-1]=e-t,r=Sn([n,Di(f)],n.shape.length-1),t=e}else r=n;const i=Dh(r),o=de(Ei(r,i),[s,t]),a=ng(o),l=Math.floor(t/2)+1,c=hc(a),u=$h(a),h=Qa(c,[l,t-l],c.shape.length-1),d=Qa(u,[l,t-l],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=l,de(Ei(h[0],d[0]),p)}const sg=W({rfft_:H7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7(n){const t={x:P(n,"x","sqrt","float32")};return G.runKernel(Hm,t)}const Wh=W({sqrt_:X7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j7(n,e){let t=P(n,"a","squaredDifference"),s=P(e,"b","squaredDifference");[t,s]=Kt(t,s),Ct(t.shape,s.shape);const r={a:t,b:s},i={};return G.runKernel(t1,r,i)}const rg=W({squaredDifference_:j7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q7(n,e){const t=P(n,"x","squeeze");return de(t,Or(t.shape,e).newShape)}const Ds=W({squeeze_:q7});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K7(n,e=0){const t=G1(n,"tensors","stack","string_or_numeric");O(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&O(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,r={axis:e};return G.runKernel(bm,s,r)}const vr=W({stack_:K7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y7(n,e=0){const s={x:P(n,"x","step")},r={alpha:e};return G.runKernel(m1,s,r)}const Z7=W({step_:Y7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J7(n,e,t,s,r=0,i=0,o=0,a=0,l=0){const u={x:P(n,"x","stridedSlice","string_or_numeric")},h={begin:e,end:t,strides:s,beginMask:r,endMask:i,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return G.runKernel(n1,u,h)}const Q7=W({stridedSlice_:J7});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ew(n){const t={x:P(n,"x","tan","float32")};return G.runKernel(a1,t)}const tw=W({tan_:ew});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(n,e){Gu(n);const t=Ga(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Wa(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jr(n,e,t){if(Gu(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=Ga(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Wa(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nw(n,e=1,t=!0){const s=P(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const r=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>r)throw new Error(`'k' passed to topk() must be <= the last dimension (${r}) but got ${e}`);const i={x:s},o={k:e,sorted:t},[a,l]=G.runKernel(c1,i,o);return{values:a,indices:l}}const sw=W({topk_:nw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rw(n,e=0,t=1,s,r){if(s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const i=new m7(e,t,s,!0,r),o=xn(n,s);for(let a=0;a<o.values.length;a++)o.values[a]=i.nextValue();return o.toTensor()}const iw=W({truncatedNormal_:rw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ow(n,e=0){const t=P(n,"x","unique","string_or_numeric");O(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},r={axis:e},[i,o]=G.runKernel(d1,s,r);return{values:i,indices:o}}const ig=W({unique_:ow});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aw(n,e=0){const t=P(n,"x","unstack","string_or_numeric");O(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},r={axis:e};return G.runKernel(p1,s,r)}const $i=W({unstack_:aw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function og(n,e){const t=[];for(let i=0;i<e.length;i++)e[i]&&t.push(i);const s=xn(n,"int32"),r=xn([t.length,n.length],"int32");for(let i=0;i<t.length;i++){const o=s.indexToLoc(t[i]),a=i*n.length;r.values.set(o,a)}return r.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function lw(n){const e=P(n,"condition","whereAsync","bool"),t=await e.data(),s=og(e.shape,t);return n!==e&&e.dispose(),s}const cw=lw;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uw(n,e="euclidean",t=null,s=!1){n=P(n,"x","norm");const r=ag(n,e,t);let i=r.shape;if(s){const o=gn(t,n.shape);i=ms(r.shape,o)}return de(r,i)}function ag(n,e,t=null){if(n.rank===0)return ps(n);if(n.rank!==1&&t===null)return ag(de(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Vt(ps(n),t);if(e===1/0)return To(ps(n),t);if(e===-1/0)return Uh(ps(n),t);if(e==="euclidean"||e===2)return Wh(Vt(G2(ps(n),Mt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return To(Vt(ps(n),t[0]),t[1]-1);if(e===1/0)return To(Vt(ps(n),t[1]),t[0]);if(e===-1/0)return Uh(Vt(ps(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Wh(Vt(Vh(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const lg=W({norm_:uw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hw(n,e,t){const s=P(n,"indices","scatterND","int32"),r=P(e,"updates","scatterND");h2(r,s,t);const i={indices:s,updates:r},o={shape:t};return G.runKernel($m,i,o)}const dw=W({scatterND_:hw});function pw(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const r=n.rank>0?n.shape[0]:1,i=n.rank>1?n.shape[1]:1;if(t.length!==i)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${i}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===r))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${r}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fw(n,e,t,s=0){const r=P(n,"sparseIndices","sparseToDense","int32"),i=P(e,"sparseValues","sparseToDense"),o=P(s,"defaultValue","sparseToDense",i.dtype);pw(r,i,t,o);const a={sparseIndices:r,sparseValues:i,defaultValue:o},l={outputShape:t};return G.runKernel(e1,a,l)}const cg=W({sparseToDense_:fw});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mw(n,e){const t=P(e,"indices","gatherND","int32"),r={params:P(n,"x","gatherND","string_or_numeric"),indices:t};return G.runKernel(B0,r)}const gw=W({gatherND_:mw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xw(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function ug(n,e,t){const s=1-n%2,r=new Float32Array(n);for(let i=0;i<n;++i){const o=2*Math.PI*i/(n+s-1);r[i]=e-t*Math.cos(o)}return cn(r,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yw(n,e,t,s,r,i="NHWC",o){let a=n;n.rank===3&&(a=de(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=de(e,[1,e.shape[0],e.shape[1],e.shape[2]])),O(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),O(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),O(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=i==="NHWC"?a.shape[3]:a.shape[1],u=i==="NHWC"?l.shape[3]:l.shape[1];O(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),O(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),fs("conv2dDerFilter",r,o);const h={x:a,dy:l},d={strides:s,pad:r,dataFormat:i,dimRoundingMode:o,filterShape:t};return G.runKernel(h0,h,d)}const vw=W({conv2DBackpropFilter_:yw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fc(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return tt(n,Z7(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function mc(n,e){let t=e;const s=a2(n.shape,e.shape);return s.length>0&&(t=Vt(t,s)),de(t,n.shape)}function gc(n,e,t,s){if(e==="linear")return n;if(e==="relu")return dc(n);if(e==="elu")return P2(n);if(e==="relu6")return eg(n);if(e==="prelu")return W2(n,t);if(e==="leakyrelu")return $2(n,s);if(e==="sigmoid")return Lh(n);throw new Error(`Unknown fused activation ${e}.`)}const xc=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bw({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",xc(G.state.gradientDepth,l)===!1){let C=Ph(n,e,t,s,r,i,o);return a!=null&&(C=_n(C,a)),gc(C,l,c,u)}const h=P(n,"x","conv2d","float32"),d=P(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=de(h,[1,h.shape[0],h.shape[1],h.shape[2]])),O(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),O(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),fs("fused conv2d",s,o),O(p.shape[3]===d.shape[2],()=>`Error in conv2d: depth of input (${p.shape[3]}) must match input depth for filter ${d.shape[2]}.`),O(ss(t,i),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),O(r==="NHWC",()=>`Error in conv2d: got dataFormat of ${r} but only NHWC is currently supported.`);const m=ns(p.shape,d.shape,t,i,s,o);let y;a!=null&&(y=P(a,"bias","fused conv2d"),[y]=Kt(y,h),Ct(m.outShape,y.shape));let g;c!=null&&(g=P(c,"prelu weights","fused conv2d"));const x=(C,M)=>{const[E,A,$,B]=M,R=fc(C,$,l);O(qa(i),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${i}'`);const K=I2(A.shape,R,E,t,s),F=vw(A,R,E.shape,t,s),z=[K,F];if(B!=null){const V=mc(B,R);z.push(V)}return z},b={x:p,filter:d,bias:y,preluActivationWeights:g},w={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?Xr((M,E,A)=>{let $=G.runKernel(sh,b,w);return A([E,M,$]),f&&($=de($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(p,d):Xr((M,E,A,$)=>{let B=G.runKernel(sh,b,w);return $([E,M,B,A]),f&&(B=de(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:x}})(p,d,y)}const ww=W({fusedConv2d_:bw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _w(n,e,t,s,r,i=[1,1],o){let a=n;n.rank===3&&(a=de(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=de(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:s,pad:r,dimRoundingMode:o,dilations:i,filterShape:t};return G.runKernel(w0,c,u)}const Sw=W({depthwiseConv2dNativeBackpropFilter_:_w});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tw(n,e,t,s,r,i=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=de(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:t},u={strides:s,pad:r,dimRoundingMode:o,dilations:i,inputShape:n},h=G.runKernel(_0,c,u);return l?de(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Ew=W({depthwiseConv2dNativeBackpropInput_:Tw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cw({x:n,filter:e,strides:t,pad:s,dataFormat:r="NHWC",dilations:i=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(xc(G.state.gradientDepth,l)===!1){let C=N2(n,e,t,s,r,i,o);return a!=null&&(C=_n(C,a)),gc(C,l,c,u)}const h=P(n,"x","depthwiseConv2d","float32"),d=P(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=de(h,[1,h.shape[0],h.shape[1],h.shape[2]])),O(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),O(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),O(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),i==null&&(i=[1,1]),O(ss(t,i),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${i}'`),fs("fused depthwiseConv2d",s,o);const m=ns(p.shape,d.shape,t,i,s,o,!0);let y;a!=null&&(y=P(a,"bias","fused conv2d"),[y]=Kt(y,h),Ct(m.outShape,y.shape));let g;c!=null&&(g=P(c,"prelu weights","fused depthwiseConv2d"));const x=(C,M)=>{O(qa(i),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${i}'`);const[E,A,$,B]=M,R=fc(C,$,l),K=Ew(A.shape,R,E,t,s,i,o),F=Sw(A,R,E.shape,t,s,i,o);if(B!=null){const z=mc(y,R);return[K,F,z]}return[K,F]},b={x:p,filter:d,bias:y,preluActivationWeights:g},w={strides:t,pad:s,dataFormat:r,dilations:i,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?Xr((M,E,A)=>{let $=G.runKernel(rh,b,w);return A([E,M,$]),f&&($=de($,[$.shape[1],$.shape[2],$.shape[3]])),{value:$,gradFunc:x}})(p,d):Xr((M,E,A,$)=>{let B=G.runKernel(rh,b,w);return $([E,M,B,A]),f&&(B=de(B,[B.shape[1],B.shape[2],B.shape[3]])),{value:B,gradFunc:x}})(p,d,y)}const Mw=W({fusedDepthwiseConv2d_:Cw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aw({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:r,activation:i="linear",preluActivationWeights:o,leakyreluAlpha:a}){if(xc(G.state.gradientDepth,i)===!1){let R=ln(n,e,t,s);return r!=null&&(R=_n(R,r)),gc(R,i,o,a)}let l=P(n,"a","fused matMul"),c=P(e,"b","fused matMul");[l,c]=Kt(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),m=c.shape.slice(0,-2),y=Se(f),g=Se(m);O(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const b=Ct(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),w=t?de(l,[y,u,d]):de(l,[y,d,u]),C=s?de(c,[g,p,h]):de(c,[g,h,p]);let M;r!=null&&(M=P(r,"bias","fused matMul"),[M]=Kt(M,l),Ct(b,M.shape));let E;o!=null&&(E=P(o,"prelu weights","fused matMul"));const A=(R,K)=>{const[F,z,V,H]=K,j=fc(de(R,V.shape),V,i);let ae,fe;if(!t&&!s?(ae=ln(j,z,!1,!0),fe=ln(F,j,!0,!1)):!t&&s?(ae=ln(j,z,!1,!1),fe=ln(j,F,!0,!1)):t&&!s?(ae=ln(z,j,!1,!0),fe=ln(F,j,!1,!1)):(ae=ln(z,j,!0,!0),fe=ln(j,F,!0,!0)),r!=null){const Q=mc(H,j);return[ae,fe,Q]}else return[ae,fe]},$={a:w,b:C,bias:M,preluActivationWeights:E},B={transposeA:t,transposeB:s,activation:i,leakyreluAlpha:a};return r==null?Xr((K,F,z)=>{const V=G.runKernel(nh,$,B);return z([K,F,V]),{value:de(V,b),gradFunc:A}})(w,C):Xr((K,F,z,V)=>{const H=G.runKernel(nh,$,B);return V([K,F,H,z]),{value:de(H,b),gradFunc:A}})(w,C,M)}const Rw=W({fusedMatMul_:Aw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iw(n){return ug(n,.54,.46)}const $X=W({hammingWindow_:Iw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nw(n){return ug(n,.5,.5)}const Lw=W({hannWindow_:Nw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pw(n,e,t,s=!1,r=0){let i=0;const o=[];for(;i+e<=n.size;)o.push(dt(n,i,e)),i+=t;if(s)for(;i<n.size;){const a=i+e-n.size,l=Sn([dt(n,i,e-a),kh([a],r)]);o.push(l),i+=t}return o.length===0?jr([],[0,e]):de(Sn(o),[o.length,e])}const Dw=W({frame_:Pw});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kw(n,e,t,s,r=Lw){s==null&&(s=xw(e));const i=Dw(n,e,t),o=tt(i,r(e));return sg(o,s)}const FX=W({stft_:kw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $w(n,e,t,s,r="bilinear",i=0){const o=P(n,"image","cropAndResize"),a=P(e,"boxes","cropAndResize","float32"),l=P(t,"boxInd","cropAndResize","int32"),c=a.shape[0];O(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),O(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),O(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),O(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),O(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),O(r==="bilinear"||r==="nearest",()=>`method must be bilinear or nearest, but was ${r}`);const u={image:o,boxes:a,boxInd:l},h={method:r,extrapolationValue:i,cropSize:s};return G.runKernel(x0,u,h)}const Fw=W({cropAndResize_:$w});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ow(n){const e=P(n,"image","flipLeftRight","float32");O(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return G.runKernel(D0,t,{})}const Bw=W({flipLeftRight_:Ow});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zw(n){const e=P(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];O(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),O(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const r=new Array(e.rank);return r.fill(1,0,t),r[t]=3,Ka(e,r)}const Uw=W({grayscaleToRGB_:zw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vw(n,e,t=0,s=.5){const r=P(n,"image","rotateWithOffset","float32");O(r.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${r.rank}.`);const i={image:r},o={radians:e,fillValue:t,center:s};return G.runKernel(g1,i,o)}const Gw=W({rotateWithOffset_:Vw});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eo(n,e,t,s,r,i){s==null&&(s=.5),r==null&&(r=Number.NEGATIVE_INFINITY),i==null&&(i=0);const o=n.shape[0];return t=Math.min(t,o),O(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),O(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),O(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),O(e.rank===1,()=>"scores must be a 1D tensor"),O(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),O(0<=i&&i<=1,()=>`softNmsSigma must be in [0, 1], but was '${i}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ww(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=P(n,"boxes","nonMaxSuppression","float32"),o=P(e,"scores","nonMaxSuppression","float32"),a=Eo(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:r};return G.runKernel(mm,{boxes:i,scores:o},l)}const Hw=W({nonMaxSuppression_:Ww});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xw(n,e,t){const s=jw(n,e,t),r=s<0?-(s+1):s;n.splice(r,0,e)}function jw(n,e,t){return Kw(n,e,t||qw)}function qw(n,e){return n>e?1:n<e?-1:0}function Kw(n,e,t){let s=0,r=n.length,i=0,o=!1;for(;s<r;){i=s+(r-s>>>1);const a=t(e,n[i]);a>0?s=i+1:(r=i,o=!a)}return o?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hg(n,e,t,s,r){return Hh(n,e,t,s,r,0)}function dg(n,e,t,s,r,i){return Hh(n,e,t,s,r,0,!1,i,!0)}function pg(n,e,t,s,r,i){return Hh(n,e,t,s,r,i,!0)}function Hh(n,e,t,s,r,i,o=!1,a=!1,l=!1){const c=[];for(let y=0;y<e.length;y++)e[y]>r&&c.push({score:e[y],boxIndex:y,suppressBeginIndex:0});c.sort(fg);const u=i>0?-.5/i:0,h=[],d=[];for(;h.length<t&&c.length>0;){const y=c.pop(),{score:g,boxIndex:x,suppressBeginIndex:b}=y;if(g<r)break;let w=!1;for(let C=h.length-1;C>=b;--C){const M=Yw(n,x,h[C]);if(M>=s){w=!0;break}if(y.score=y.score*Zw(s,u,M),y.score<=r)break}y.suppressBeginIndex=h.length,w||(y.score===g?(h.push(x),d.push(y.score)):y.score>r&&Xw(c,y,fg))}const p=h.length,f=t-p;a&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),l&&(m.validOutputs=p),m}function Yw(n,e,t){const s=n.subarray(e*4,e*4+4),r=n.subarray(t*4,t*4+4),i=Math.min(s[0],s[2]),o=Math.min(s[1],s[3]),a=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(a-i)*(l-o),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(i,c),y=Math.max(o,u),g=Math.min(a,h),x=Math.min(l,d),b=Math.max(g-m,0)*Math.max(x-y,0);return b/(p+f-b)}function Zw(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function fg(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function Jw(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY){const i=P(n,"boxes","nonMaxSuppressionAsync"),o=P(e,"scores","nonMaxSuppressionAsync"),a=Eo(i,o,t,s,r);t=a.maxOutputSize,s=a.iouThreshold,r=a.scoreThreshold;const l=await Promise.all([i.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:h}=hg(c,u,t,s,r);return i!==n&&i.dispose(),o!==e&&o.dispose(),cn(h,"int32")}const Qw=Jw;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e_(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=P(n,"boxes","nonMaxSuppression"),a=P(e,"scores","nonMaxSuppression"),l=Eo(o,a,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:t,iouThreshold:s,scoreThreshold:r,softNmsSigma:i},h=G.runKernel(xm,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const t_=W({nonMaxSuppressionWithScore_:e_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function n_(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=0){const o=P(n,"boxes","nonMaxSuppressionAsync"),a=P(e,"scores","nonMaxSuppressionAsync"),l=Eo(o,a,t,s,r,i);t=l.maxOutputSize,s=l.iouThreshold,r=l.scoreThreshold,i=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=pg(u,h,t,s,r,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:cn(d,"int32"),selectedScores:cn(p)}}const s_=n_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r_(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=P(n,"boxes","nonMaxSuppression"),a=P(e,"scores","nonMaxSuppression"),l=Eo(o,a,t,s,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:o,scores:a},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:i},f=G.runKernel(gm,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const i_=W({nonMaxSuppressionPadded_:r_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function o_(n,e,t,s=.5,r=Number.NEGATIVE_INFINITY,i=!1){const o=P(n,"boxes","nonMaxSuppressionAsync"),a=P(e,"scores","nonMaxSuppressionAsync"),l=Eo(o,a,t,s,r,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([o.data(),a.data()]),{selectedIndices:f,validOutputs:m}=dg(d,p,c,u,h,i);return o!==n&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:cn(f,"int32"),validOutputs:Mt(m,"int32")}}const a_=o_;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(n,e,t=!1,s=!1){const r=P(n,"images","resizeBilinear");O(r.rank===3||r.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),O(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=de(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},c=G.runKernel(Nm,a,l);return o?de(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const c_=W({resizeBilinear_:l_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_(n,e,t=!1,s=!1){const r=P(n,"images","resizeNearestNeighbor");O(r.rank===3||r.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${r.rank}.`),O(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),O(r.dtype==="float32"||r.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),O(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let i=r,o=!1;r.rank===3&&(o=!0,i=de(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const a={images:i},l={alignCorners:t,halfPixelCenters:s,size:e},c=G.runKernel(Im,a,l);return o?de(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const h_=W({resizeNearestNeighbor_:u_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d_(n,e="binary",t=!1,s=.5){const r=P(n,"image","threshold"),i=.2989,o=.587,a=.114,l=r.shape[0]*r.shape[1];let c=tt(cn([s]),255),u,h,d,p;if(O(r.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${r.rank}.`),O(r.shape[2]===3||r.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${r.shape[2]}.`),O(r.dtype==="int32"||r.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${r.dtype}.`),O(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),r.shape[2]===3){[u,h,d]=Qa(r,[1,1,1],-1);const y=tt(u,i),g=tt(h,o),x=tt(d,a);p=_n(_n(y,g),x)}else p=n;if(e==="otsu"){const y=A2(Xt(tg(p),"int32"),Vr([]),256);c=p_(y,l)}const f=t?Fh(p,c):uc(p,c);return Xt(tt(f,255),"int32")}function p_(n,e){let t=cn([-1]),s=cn([0]),r=cn([0]),i,o,a,l,c,u;for(let h=0;h<n.size-1;h++){i=dt(n,0,h+1),o=dt(n,h+1),c=rn(Vt(i),e),u=rn(Vt(o),e);const d=Vt(tt(i,Ja(0,i.size)));a=rn(d,Vt(i));const p=kh(o.shape,i.size),f=_n(Ja(0,o.size),p),m=tt(o,f);l=rn(Vt(m),Vt(o));const y=pt(a,l),g=pt(a,l),x=tt(c,u);r=tt(tt(x,y),g);const b=uc(r,s);s=So(b,r,s),t=So(b,cn([h]),t)}return t}const f_=W({threshold_:d_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m_(n,e,t="nearest",s="constant",r=0,i){const o=P(n,"image","transform","float32"),a=P(e,"transforms","transform","float32");O(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),O(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),O(i==null||i.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${i}.`);const l={image:o,transforms:a},c={interpolation:t,fillMode:s,fillValue:r,outputShape:i};return G.runKernel(u1,l,c)}const g_=W({transform_:m_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x_(n,e,t){O(e%1==0,()=>`bandPart(): numLower must be an integer, got ${e}.`),O(t%1==0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const s=P(n,"a","bandPart");O(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const r=s.shape,[i,o]=s.shape.slice(-2);if(!(e<=i))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${i}).`);if(!(t<=o))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${o}).`);e<0&&(e=i),t<0&&(t=o);const a=de(Ja(0,i,1,"int32"),[-1,1]),l=Ja(0,o,1,"int32"),c=pt(a,l),u=B2(Fh(c,Mt(+e,"int32")),k2(c,Mt(-t,"int32"))),h=Di([i,o],s.dtype);return de(vr($i(de(s,[-1,i,o])).map(d=>So(u,d,h))),r)}const OX=W({bandPart_:x_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_(n){let e;if(Array.isArray(n)){e=!1,O(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const r=n[0].shape[0];for(let i=1;i<n.length;++i)O(n[i].shape[0]===r,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[i].shape[0]} vs. ${r})`)}else e=!0,n=Qa(n,n.shape[0],0).map(r=>Ds(r,[0]));O(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let r=0;r<n.length;++r)t.push(G.tidy(()=>{let i=s[r];if(r>0)for(let o=0;o<r;++o){const a=tt(Vt(tt(t[o],i)),t[o]);i=pt(i,a)}return rn(i,lg(i,"euclidean"))}));return e?vr(t,0):t}const BX=W({gramSchmidt_:y_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_(n,e=!1){if(O(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return mg(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=$i(de(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),r=[],i=[];s.forEach(l=>{const[c,u]=mg(l,e);r.push(c),i.push(u)});const o=de(vr(r,0),n.shape),a=de(vr(i,0),n.shape);return[o,a]}}function mg(n,e=!1){return G.tidy(()=>{O(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let r=nb(t),i=Ri(n);const o=jr([[1]],[1,1]);let a=Ri(o);const l=t>=s?s:t;for(let c=0;c<l;++c){const u=i,h=a,d=r;[a,i,r]=G.tidy(()=>{const p=dt(i,[c,c],[t-c,1]),f=lg(p),m=dt(i,[c,c],[1,1]),y=So(uc(m,0),jr([[-1]]),jr([[1]])),g=pt(m,tt(y,f)),x=rn(p,g);x.shape[0]===1?a=Ri(o):a=Sn([o,dt(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const b=Za(rn(ln(y,g),f)),w=dt(i,[c,0],[t-c,s]),C=tt(b,a),M=Eh(a);if(c===0)i=pt(w,ln(C,ln(M,w)));else{const $=pt(w,ln(C,ln(M,w)));i=Sn([dt(i,[0,0],[c,s]),$],0)}const E=Eh(C),A=dt(r,[0,c],[t,r.shape[1]-c]);if(c===0)r=pt(A,ln(ln(A,a),E));else{const $=pt(A,ln(ln(A,a),E));r=Sn([dt(r,[0,0],[t,c]),$],1)}return[a,i,r]}),pv([u,h,d])}return!e&&t>s&&(r=dt(r,[0,0],[t,s]),i=dt(i,[0,0],[s,s])),[r,i]})}const zX=W({qr_:v_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var zn;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(zn||(zn={}));function b_(n,e,t=zn.SUM_BY_NONZERO_WEIGHTS){const s=P(n,"losses","computeWeightedLoss");let r=null;e!=null&&(r=P(e,"weights","computeWeightedLoss"));const i=r==null?s:tt(s,r);if(t===zn.NONE)return i;if(t===zn.SUM)return Vt(i);if(t===zn.MEAN){if(r==null)return z2(i);{const o=s.size/r.size,a=rn(Vt(i),Vt(r));return o>1?rn(a,Mt(o)):a}}if(t===zn.SUM_BY_NONZERO_WEIGHTS){if(r==null)return rn(Vt(i),Mt(s.size));{const o=tt(r,zh(s.shape)),a=Xt(Vt(V2(o,Mt(0))),"float32");return rn(Vt(i),a)}}throw Error(`Unknown reduction: ${t}`)}const qr=W({computeWeightedLoss_:b_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_(n,e,t,s=zn.SUM_BY_NONZERO_WEIGHTS){const r=P(n,"labels","absoluteDifference"),i=P(e,"predictions","absoluteDifference");let o=null;t!=null&&(o=P(t,"weights","absoluteDifference")),As(r.shape,i.shape,"Error in absoluteDifference: ");const a=ps(pt(r,i));return qr(a,o,s)}const UX=W({absoluteDifference_:w_});function __(n,e,t,s,r=zn.SUM_BY_NONZERO_WEIGHTS){const i=P(n,"labels","cosineDistance"),o=P(e,"predictions","cosineDistance");let a=null;s!=null&&(a=P(s,"weights","cosineDistance")),As(i.shape,o.shape,"Error in cosineDistance: ");const l=Mt(1),c=pt(l,Vt(tt(i,o),t,!0));return qr(c,a,r)}const VX=W({cosineDistance_:__});function S_(n,e,t,s=zn.SUM_BY_NONZERO_WEIGHTS){let r=P(n,"labels","hingeLoss");const i=P(e,"predictions","hingeLoss");let o=null;t!=null&&(o=P(t,"weights","hingeLoss")),As(r.shape,i.shape,"Error in hingeLoss: ");const a=Mt(1);r=pt(tt(Mt(2),r),a);const l=dc(pt(a,tt(r,i)));return qr(l,o,s)}const GX=W({hingeLoss_:S_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T_(n,e,t,s=1,r=zn.SUM_BY_NONZERO_WEIGHTS){const i=P(n,"labels","huberLoss"),o=P(e,"predictions","huberLoss");let a=null;t!=null&&(a=P(t,"weights","huberLoss")),As(i.shape,o.shape,"Error in huberLoss: ");const l=Mt(s),c=ps(pt(o,i)),u=U2(c,l),h=pt(c,u),d=_n(tt(Mt(.5),Vh(u)),tt(l,h));return qr(d,a,r)}const WX=W({huberLoss_:T_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_(n,e,t,s=1e-7,r=zn.SUM_BY_NONZERO_WEIGHTS){const i=P(n,"labels","logLoss"),o=P(e,"predictions","logLoss");let a=null;t!=null&&(a=P(t,"weights","logLoss")),As(i.shape,o.shape,"Error in logLoss: ");const l=Mt(1),c=Mt(s),u=Za(tt(i,Ya(_n(o,c)))),h=tt(pt(l,i),Ya(_n(pt(l,o),c))),d=pt(u,h);return qr(d,a,r)}const HX=W({logLoss_:E_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C_(n,e,t,s=zn.SUM_BY_NONZERO_WEIGHTS){const r=P(n,"labels","meanSquaredError"),i=P(e,"predictions","meanSquaredError");let o=null;t!=null&&(o=P(t,"weights","meanSquaredError")),As(r.shape,i.shape,"Error in meanSquaredError: ");const a=rg(r,i);return qr(a,o,s)}const XX=W({meanSquaredError_:C_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M_(n,e){const t=P(n,"labels","sigmoidCrossEntropyWithLogits"),s=P(e,"logits","sigmoidCrossEntropyWithLogits");As(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=dc(s),i=tt(s,t),o=F2(Pi(Za(ps(s))));return _n(pt(r,i),o)}function A_(n,e,t,s=0,r=zn.SUM_BY_NONZERO_WEIGHTS){let i=P(n,"multiClassLabels","sigmoidCrossEntropy");const o=P(e,"logits","sigmoidCrossEntropy");let a=null;if(t!=null&&(a=P(t,"weights","sigmoidCrossEntropy")),As(i.shape,o.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=Mt(s),u=Mt(1),h=Mt(.5);i=_n(tt(i,pt(u,c)),tt(h,c))}const l=M_(i,o);return qr(l,a,r)}const jX=W({sigmoidCrossEntropy_:A_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R_(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return Xr((r,i,o)=>{const l=Rb(i,[t],!0),c=pt(Xt(i,"float32"),l);o([r,c]);const u=Za(tt(c,r));return{value:Vt(u,[t]),gradFunc:(p,f)=>{const[m,y]=f,g=ms(p.shape,[t]);return[tt(de(p,g),pt(Xt(m,"float32"),Pi(y))),tt(de(p,g),pt(Pi(y),Xt(m,"float32")))]}}})(n,e)}function I_(n,e,t,s=0,r=zn.SUM_BY_NONZERO_WEIGHTS){let i=P(n,"onehotLabels","softmaxCrossEntropy");const o=P(e,"logits","softmaxCrossEntropy");let a=null;if(t!=null&&(a=P(t,"weights","softmaxCrossEntropy")),As(i.shape,o.shape,"Error in softmaxCrossEntropy: "),s>0){const c=Mt(s),u=Mt(1),h=Mt(i.shape[1]);i=_n(tt(i,pt(u,c)),rn(c,h))}const l=R_(i,o);return qr(l,a,r)}const qX=W({softmaxCrossEntropy_:I_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N_(n,e,t,s){const r=P(n,"indices","sparseFillEmptyRows","int32"),i=P(e,"values","sparseFillEmptyRows"),o=P(t,"denseShape","sparseFillEmptyRows","int32"),a=P(s,"defaultValue","sparseFillEmptyRows",i.dtype);if(r.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${i.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:r,values:i,denseShape:o,defaultValue:a},c=G.runKernel(Ym,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const L_=W({sparseFillEmptyRows_:N_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P_(n,e,t){const s=P(n,"inputIndices","sparseReshape","int32"),r=P(e,"inputShape","sparseReshape","int32"),i=P(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(r.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${r.shape}`);if(i.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${i.shape}`);const o={inputIndices:s,inputShape:r,newShape:i},a=G.runKernel(Zm,o);return{outputIndices:a[0],outputShape:a[1]}}const D_=W({sparseReshape_:P_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k_(n,e,t){const s=P(n,"data","sparseSegmentMean"),r=P(e,"indices","sparseSegmentMean","int32"),i=P(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return G.runKernel(Jm,o)}const $_=W({sparseSegmentMean_:k_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_(n,e,t){const s=P(n,"data","sparseSegmentSum"),r=P(e,"indices","sparseSegmentSum","int32"),i=P(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${r.shape}`);if(i.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${i.shape}`);const o={data:s,indices:r,segmentIds:i};return G.runKernel(Qm,o)}const O_=W({sparseSegmentSum_:F_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B_(n,e,t,s,r,i,o,a){const l=P(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=P(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:s,leftPad:r,rightPad:i,padWidth:o,preserveShortSequences:a},h={data:l,dataSplits:c},d=G.runKernel(s1,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}const z_=W({stringNGrams_:B_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_(n,e,t=!0){const s=P(n,"input","stringSplit","string"),r=P(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(r.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${r.shape}`);const i={skipEmpty:t},o={input:s,delimiter:r},a=G.runKernel(r1,o,i);return{indices:a[0],values:a[1],shape:a[2]}}const V_=W({stringSplit_:U_});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_(n,e){const t=P(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const r={input:t};return G.runKernel(i1,r,s)}const W_=W({stringToHashBucketFast_:G_});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ys={flipLeftRight:Bw,grayscaleToRGB:Uw,resizeNearestNeighbor:h_,resizeBilinear:c_,rotateWithOffset:Gw,cropAndResize:Fw,nonMaxSuppression:Hw,nonMaxSuppressionAsync:Qw,nonMaxSuppressionWithScore:t_,nonMaxSuppressionWithScoreAsync:s_,nonMaxSuppressionPadded:i_,nonMaxSuppressionPaddedAsync:a_,threshold:f_,transform:g_},yc={sparseFillEmptyRows:L_,sparseReshape:D_,sparseSegmentMean:$_,sparseSegmentSum:O_},Xh={stringNGrams:z_,stringSplit:V_,stringToHashBucketFast:W_};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gg(n,e){const t=n[0].length;n.forEach((r,i)=>{O(r.length===t,()=>`Error in concat${t}D: rank of tensors[${i}] must be the same as the rank of the rest (${t})`)}),O(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((r,i)=>{for(let o=0;o<t;o++)O(o===e||r[o]===s[o],()=>`Error in concat${t}D: Shape of tensors[${i}] (${r}) does not match the shape of the rest (${s}) along the non-concatenated axis ${i}.`)})}function Fi(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jh=30;function vc(n){return n<=jh?n:Xu(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xg(n,e,t){const s=t*(typeof n=="number"?n:n[0]),r=e*(typeof n=="number"?n:n[1]);return[s,r]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qh(n,e,t,s=!0){let r=[];if(s)r=r.concat(e.slice(0)),r.push(n[0]/t),r=r.concat(n.slice(1));else{r=r.concat(n[0]);const i=e.length;for(let o=0;o<i;++o)r=r.concat([n[o+1]/e[o],e[o]]);r=r.concat(n.slice(i+1))}return r}function Kh(n,e,t=!0){const s=[];if(t){s.push(e);for(let r=e+1;r<n;++r)r<=2*e?(s.push(r),s.push(r-(e+1))):s.push(r)}else{const r=[],i=[];for(let o=1;o<n;++o)o>=e*2+1||o%2==1?i.push(o):r.push(o);s.push(...r),s.push(0),s.push(...i)}return s}function Yh(n,e,t,s=!0){const r=[];s?r.push(n[0]/t):r.push(n[0]*t);for(let i=1;i<n.length;++i)i<=e.length?s?r.push(e[i-1]*n[i]):r.push(n[i]/e[i-1]):r.push(n[i]);return r}function yg(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function vg(n,e,t){const s=n.slice(0,1);for(let r=0;r<t;++r)s.push(n[r+1]-e[r][0]-e[r][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bg=1.7580993408473768,wg=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _g=.3275911,Sg=.254829592,Tg=-.284496736,Eg=1.421413741,Cg=-1.453152027,Mg=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zh(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function H_(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function X_(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=0;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function j_(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let r=2;r<n.length;r+=4)t[Math.floor(r/4)]=n[r],s[Math.floor(r/4)]=n[r+1];return{real:t,imag:s}}function q_(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function K_(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function Y_(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let r=0;r<Math.ceil(n/2);r++){const i=(e?2:-2)*Math.PI*(r/n);t[r]=Math.cos(i),s[r]=Math.sin(i)}return{real:t,imag:s}}function Z_(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),r=Math.cos(s),i=Math.sin(s);return{real:r,imag:i}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jh="->",J_=/->/g,Ag=",",Rg="...";function Ig(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(J_,"").length)/Jh.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Jh}").`);const[s,r]=n.split(Jh);O(s.indexOf(Rg)===-1,()=>`The ellipsis notation ("${Rg}") is not supported yet.`);const i=s.split(Ag),o=i.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let d=0;d<r.length;++d){const p=r[d];if(!i.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);a.indexOf(p)===-1&&a.push(p)}for(let d=0;d<s.length;++d){const p=s[d];a.indexOf(p)===-1&&p!==Ag&&a.push(p)}const l=new Array(i.length);for(let d=0;d<o;++d){if(new Set(i[d].split("")).size!==i[d].length)throw new Error(`Found duplicate axes in input component ${i[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<i[d].length;++p)l[d].push(a.indexOf(i[d][p]))}const c=a.length,u=r.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:a,summedDims:h,idDims:l}}function Ng(n,e){let t=new Array(n);t.fill(-1);for(let r=0;r<e.length;++r)t[e[r]]=r;const s=[];for(let r=0;r<n;++r)t[r]===-1&&s.push(r);return t=t.filter(r=>r!==-1),{permutationIndices:t,expandDims:s}}function Lg(n,e,t){const s=new Array(n);for(let r=0;r<t.length;++r){const i=t[r].shape;for(let o=0;o<e[r].length;++o)s[e[r][o]]===void 0?s[e[r][o]]=i[o]:O(s[e[r][o]]===i[o],()=>`Expected dimension ${s[e[r][o]]} at axis ${o} of input shaped ${JSON.stringify(i)}, but got dimension ${i[o]}`)}}function Pg(n,e){const t=n,s=[];let r=0;n.length===0&&t.push(-1),r=n.length+1;for(let o=0;o<r;++o)s.push([]);const i=[];for(let o=0;o<t.length;++o){const a=t[o],l=Q_(e,a);for(const c of l)i.indexOf(c)===-1&&(s[o].push(c),i.push(c))}return{path:t,steps:s}}function Dg(n){return n.every((e,t)=>e===t)}function Q_(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function kg(n,e,t=0){let s=[];if(typeof e=="number")O(n.shape[t]%e==0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const r=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);O(r<=1,()=>"There should be only one negative value in split array.");const i=e.indexOf(-1);if(i!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[i]=n.shape[t]-o}O(n.shape[t]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $g(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function Fg(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function Og(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bg(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function zg(n,e){return`size ${n} must be non-negative, not ${e}`}function Ug(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function Vg(n,e){const t=Se(n),s=Se(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function Gg(n,e){const t=Se(n),s=Se(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(){return"segment ids must be >= 0"}function Wg(){return"segment ids are not increasing"}function Hg(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function Xg(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jg(n,e){let t=!1,s;for(n<=jh?(s=n,t=!0):s=Xu(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=Xu(n,s+1);return s}function qg(n,e,t){const s=[],r=n.length;for(let i=0;i<r;i++)i!==e?s.push(n[i]):s.push(t);return s}function Kg(n,e,t,s){const r=e.shape.length,i=n.shape.length;if(s!==0&&(s<-r||s>r))throw new Error(`Expect batchDims in the range of [-${r}, ${r}], but got ${s}`);if(s<0&&(s+=r),s>i)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${i}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const o=n.shape[t],a=[];let l=1,c=1,u=1;for(let h=0;h<s;++h)a.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)a.push(n.shape[h]),c*=n.shape[h];for(let h=s;h<r;h++)a.push(e.shape[h]);for(let h=t+1;h<i;h++)a.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}var eS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",segOpComputeOptimalWindowSize:jg,computeOutShape:qg,collectGatherOpShapeInfo:Kg});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(n){try{return n.map(e=>Oa(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function Yg(n){return n.map(e=>Ti(e))}var tS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",slice_util:dv,segment_util:eS,fromUint8ToStringArray:el,fromStringArrayToUint8:Yg,upcastType:Hs,axesAreInnerMostDims:Oh,combineLocations:O2,computeOutAndReduceShapes:Xs,expandShapeToKeepDim:ms,assertAxesAreInnerMostDims:Ps,getAxesPermutation:gs,getUndoAxesPermutation:Bh,getInnerMostAxes:xs,getBroadcastDims:ac,getReductionAxes:a2,assertAndGetBroadcastShape:Ct,assertParamsConsistent:gg,computeOutShape:Fi,computeDilation2DInfo:C2,computePool2DInfo:bo,computePool3DInfo:Xa,computeConv2DInfo:ns,computeConv3DInfo:ja,computeDefaultPad:Ih,tupleValuesAreOne:qa,eitherStridesOrDilationsAreOne:ss,convertConv2DDataFormat:_o,checkPadOnDimRoundingMode:fs,getFusedDyActivation:fc,getFusedBiasGradient:mc,applyActivation:gc,shouldFuse:xc,PARALLELIZE_THRESHOLD:jh,computeOptimalWindowSize:vc,getImageCenter:xg,getReshaped:qh,getPermuted:Kh,getReshapedPermuted:Yh,getSliceBeginCoords:yg,getSliceSize:vg,prepareAndValidate:c2,validateUpdateShape:u2,validateInput:h2,calculateShapes:Ch,SELU_SCALEALPHA:bg,SELU_SCALE:wg,ERF_P:_g,ERF_A1:Sg,ERF_A2:Tg,ERF_A3:Eg,ERF_A4:Cg,ERF_A5:Mg,warn:Rs,log:W9,mergeRealAndImagArrays:Zh,splitRealAndImagArrays:H_,complexWithEvenIndex:X_,complexWithOddIndex:j_,getComplexWithIndex:q_,assignToTypedArray:K_,exponents:Y_,exponent:Z_,decodeEinsumEquation:Ig,getEinsumPermutation:Ng,checkEinsumDimSizes:Lg,getEinsumComputePath:Pg,isIdentityPermutation:Dg,prepareSplitSize:kg,getSparseFillEmptyRowsIndicesDenseShapeMismatch:$g,getSparseFillEmptyRowsNegativeIndexErrorMessage:Fg,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:Og,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:Bg,getSparseReshapeNegativeOutputDimErrorMessage:zg,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:Ug,getSparseReshapeInputOutputMultipleErrorMessage:Vg,getSparseReshapeInputOutputMismatchErrorMessage:Gg,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:Qh,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:Wg,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:Hg,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:Xg});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nS=ee();nS.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var vs;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(vs||(vs={}));var Zg;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(Zg||(Zg={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sS={};function Jg(n){return sS[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S(n,e,t,s,r){const i=e.inputParams[n];if(i&&i.inputIndexStart!==void 0){const a=i.inputIndexStart,l=i.inputIndexEnd===0?void 0:i.inputIndexEnd===void 0?a+1:i.inputIndexEnd;if(i.type==="tensor")return An(e.inputNames[i.inputIndexStart],t,s,r);if(i.type==="tensors")return e.inputNames.slice(a,l).map(d=>An(d,t,s,r));const c=An(e.inputNames.slice(a)[0],t,s,r),u=c.dataSync();return i.type==="number"?u[0]:ju(c.shape,u)}const o=e.attrParams[n];return o&&o.value}function An(n,e,t,s){const[r,i]=qn(n);if(s!=null){const a=s.getHashTableHandleByName(r);if(a!=null)return a}const o=t.currentContextIds.find(a=>!!e[bc(r,a)]);return o!==void 0?e[bc(r,o)][i]:void 0}function rS(n,e,t){return e[bc(n,t.currentContextId)]}function js(n,e){const[t,s,r]=qn(n);return[bc(t,e&&e.currentContextId),s,r]}function bc(n,e){return e?`${n}-${e}`:n}function qn(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],s=e.length===3?e[1]:void 0,r=Number(e[e.length-1]);return[t,r,s]}function wc(n,e,t){let s=S("pad",n,e,t);if(s==="explicit"){s=S("explicitPaddings",n,e,t);const r=[[0,0],[0,0],[0,0],[0,0]];for(let i=0;i<4;i++)r[i][0]=s[i*2],r[i][1]=s[i*2+1];return r}return s}function br(n){return n.kept?n:Ri(n)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iS=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var oS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:iS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aS=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var lS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:aS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cS=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}];var uS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:cS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hS=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number"}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}];var dS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:hS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pS=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}];var fS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:pS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mS=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var gS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:mS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xS=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}];var yS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:xS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vS=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}];var bS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:vS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wS=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}];var _S=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:wS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SS=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}];var TS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:SS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ES=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}];var CS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:ES});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MS=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}];var AS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:MS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RS=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}];var IS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:RS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NS=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}];var LS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:NS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PS=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}];var DS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:PS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kS=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}];var $S=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:kS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FS=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}];var OS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:FS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BS=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}];var zS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:BS});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const US=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];var VS=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",json:US});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qg{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[oS,lS,uS,dS,fS,gS,yS,bS,_S,TS,CS,AS,IS,LS,DS,$S,OS,zS,VS],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,r)=>(s[r.tfOpName]=r,s),{})}transformGraph(e,t={}){const s=e.node,r=[],i=[],o=[],a=s.reduce((m,y)=>(m[y.name]=this.mapNode(y),y.op.startsWith("Placeholder")?r.push(m[y.name]):y.op==="Const"?i.push(m[y.name]):(y.input==null||y.input.length===0)&&o.push(m[y.name]),m),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(a);d.forEach(m=>{const y=a[m];y.inputNames.forEach((g,x)=>{const[b,,w]=js(g),C=a[b];if(C.outputs!=null){const M=C.outputs.indexOf(w);if(M!==-1){const E=`${b}:${M}`;y.inputNames[x]=E}}y.inputs.push(C),C.children.push(y)})}),Object.keys(h).length===0?d.forEach(m=>{const y=a[m];y.children.length===0&&c.push(y)}):Object.keys(h).forEach(m=>{const[y]=js(m),g=a[y];g!=null&&(g.signatureKey=h[m],c.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(m=>{const[y]=js(m),g=a[y];g&&(g.signatureKey=u[m],l.push(g))}):l=r;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((m,y)=>(m[y.signature.name]=this.mapFunction(y),m),{}));const f={nodes:a,inputs:l,outputs:c,weights:i,placeholders:r,signature:t,functions:p};return o.length>0&&(f.initNodes=o),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=Jg(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(r=>r.startsWith("^")?r.substr(1):r),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((r,i)=>(r[i.name]={type:i.type,inputIndexStart:i.start,inputIndexEnd:i.end},r),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((r,i)=>{const o=i.type;let a;switch(i.type){case"string":a=ed(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=ed(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"string[]":a=ld(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=ld(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number":a=nd(e.attr,i.tfName,i.defaultValue||0),a===void 0&&!!i.tfDeprecatedName&&(a=nd(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"number[]":a=ad(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=ad(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool":a=td(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=td(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"bool[]":a=ud(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=ud(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape":a=od(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=od(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"shape[]":a=cd(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=cd(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype":a=rd(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=rd(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"dtype[]":a=id(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=id(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"func":a=t3(e.attr,i.tfName,i.defaultValue),a===void 0&&!!i.tfDeprecatedName&&(a=t3(e.attr,i.tfDeprecatedName,i.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${i.type} for op: ${e.op}`)}return r[i.name]={value:a,type:o},r},{})),s}mapFunction(e){const t=e.nodeDef,s=[],r=[];let i={};t!=null&&(i=t.reduce((h,d)=>(h[d.name]=this.mapNode(d),d.op==="Const"&&r.push(h[d.name]),h),{}));const o=[],a=[];e.signature.inputArg.forEach(h=>{const[d]=js(h.name),p={name:d,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:sd(h.type),type:"dtype"}},children:[]};p.signatureKey=h.name,o.push(p),i[d]=p}),Object.keys(i).forEach(h=>{const d=i[h];d.inputNames.forEach((p,f)=>{const[m,,y]=js(p),g=i[m];if(g.outputs!=null){const x=g.outputs.indexOf(y);if(x!==-1){const b=`${m}:${x}`;d.inputNames[f]=b}}d.inputs.push(g),g.children.push(d)})});const c=e.ret;e.signature.outputArg.forEach(h=>{const[d,p]=js(c[h.name]),f=i[d];f!=null&&(f.defaultOutput=p,a.push(f))});const u=this.mapArgsToSignature(e);return{nodes:i,inputs:o,outputs:a,weights:r,placeholders:s,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function GS(n){const e=ee().global;if(typeof e.atob!="undefined")return e.atob(n);if(typeof Buffer!="undefined")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function e3(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):GS(n);return e?t:t.toLowerCase()}function ed(n,e,t,s=!1){const r=n[e];return r!=null?e3(r.s,s):t}function td(n,e,t){const s=n[e];return s?s.b:t}function nd(n,e,t){const s=n[e]||{},r=s.i!=null?s.i:s.f!=null?s.f:t;return typeof r=="number"?r:parseInt(r,10)}function sd(n){switch(typeof n=="string"&&(n=vs[n]),n){case vs.DT_FLOAT:case vs.DT_HALF:return"float32";case vs.DT_INT32:case vs.DT_INT64:case vs.DT_INT8:case vs.DT_UINT8:return"int32";case vs.DT_BOOL:return"bool";case vs.DT_DOUBLE:return"float32";case vs.DT_STRING:return"string";default:return null}}function t3(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function rd(n,e,t){const s=n[e];return s&&s.type?sd(s.type):t}function id(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(r=>sd(r)):t}function n3(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function od(n,e,t){const s=n[e];return s&&s.shape?n3(s.shape):t}function ad(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(r=>typeof r=="number"?r:parseInt(r,10)):t}function ld(n,e,t,s=!1){const r=n[e];return r&&r.list&&r.list.s?r.list.s.map(i=>e3(i,s)):t}function cd(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(r=>n3(r)):t}function ud(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WS{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(r=>this.getInput(r)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((r,i)=>(r[i]=this.getAttr(i),r),{}))}getInput(e){return An(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return An(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return nd(this.node.rawAttrs,e,t);if(s.s!=null)return ed(this.node.rawAttrs,e,t);if(s.b!=null)return td(this.node.rawAttrs,e,t);if(s.shape!=null)return od(this.node.rawAttrs,e,t);if(s.type!=null)return rd(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return ad(this.node.rawAttrs,e,t);if(s.list.s!=null)return ld(this.node.rawAttrs,e,t);if(s.list.shape!=null)return cd(this.node.rawAttrs,e,t);if(s.list.b!=null)return ud(this.node.rawAttrs,e,t);if(s.list.type!=null)return id(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HS=(n,e,t)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[_n(S("a",n,e,t),S("b",n,e,t))];case"AddN":return[Mv(S("tensors",n,e,t))];case"FloorMod":case"Mod":return[Kb(S("a",n,e,t),S("b",n,e,t))];case"Mul":return[tt(S("a",n,e,t),S("b",n,e,t))];case"RealDiv":case"Div":return[rn(S("a",n,e,t),S("b",n,e,t))];case"DivNoNan":return[W8(S("a",n,e,t),S("b",n,e,t))];case"FloorDiv":return[E2(S("a",n,e,t),S("b",n,e,t))];case"Sub":return[pt(S("a",n,e,t),S("b",n,e,t))];case"Minimum":return[U2(S("a",n,e,t),S("b",n,e,t))];case"Maximum":return[Vb(S("a",n,e,t),S("b",n,e,t))];case"Pow":return[G2(S("a",n,e,t),S("b",n,e,t))];case"SquaredDifference":return[rg(S("a",n,e,t),S("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XS=(n,e,t)=>{switch(n.op){case"Abs":case"ComplexAbs":return[ps(S("x",n,e,t))];case"Acos":return[Sv(S("x",n,e,t))];case"Acosh":return[Ev(S("x",n,e,t))];case"Asin":return[Fv(S("x",n,e,t))];case"Asinh":return[Bv(S("x",n,e,t))];case"Atan":return[Uv(S("x",n,e,t))];case"Atan2":return[Gv(S("x",n,e,t),S("y",n,e,t))];case"Atanh":return[Hv(S("x",n,e,t))];case"Ceil":return[m8(S("x",n,e,t))];case"Complex":return[Ei(S("real",n,e,t),S("imag",n,e,t))];case"Cos":return[A8(S("x",n,e,t))];case"Cosh":return[I8(S("x",n,e,t))];case"Elu":return[P2(S("x",n,e,t))];case"Erf":return[K8(S("x",n,e,t))];case"Exp":return[Pi(S("x",n,e,t))];case"Expm1":return[Q8(S("x",n,e,t))];case"Floor":return[rb(S("x",n,e,t))];case"Log":return[Ya(S("x",n,e,t))];case"Log1p":return[F2(S("x",n,e,t))];case"Imag":return[$h(S("x",n,e,t))];case"Neg":return[Za(S("x",n,e,t))];case"Reciprocal":return[w7(S("x",n,e,t))];case"Real":return[hc(S("x",n,e,t))];case"Relu":return[dc(S("x",n,e,t))];case"Round":return[tg(S("x",n,e,t))];case"Selu":return[R7(S("x",n,e,t))];case"Sigmoid":return[Lh(S("x",n,e,t))];case"Sin":return[k7(S("x",n,e,t))];case"Sign":return[P7(S("x",n,e,t))];case"Sinh":return[F7(S("x",n,e,t))];case"Softplus":return[_b(S("x",n,e,t))];case"Sqrt":return[Wh(S("x",n,e,t))];case"Square":return[Vh(S("x",n,e,t))];case"Tanh":return[i8(S("x",n,e,t))];case"Tan":return[tw(S("x",n,e,t))];case"ClipByValue":return[x8(S("x",n,e,t),S("clipValueMin",n,e,t),S("clipValueMax",n,e,t))];case"Relu6":return[eg(S("x",n,e,t))];case"Rsqrt":return[M7(An(n.inputNames[0],e,t))];case"Prod":return[H2(S("x",n,e,t),S("axes",n,e,t))];case"LeakyRelu":return[$2(S("x",n,e,t),S("alpha",n,e,t))];case"Prelu":return[W2(S("x",n,e,t),S("alpha",n,e,t))];case"IsNan":return[ub(An(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bs(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){O(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const r=n[s],i=e[s];O(r<0||i<0||r===i,()=>t+` Shapes ${n} and ${e} must match`)}}}function s3(n){return!(typeof n=="number"||n.some(e=>e<0))}function tl(n,e,t){let s=hd(n,t);const r=!s3(s);if(r&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(r&&e.forEach(i=>{s=hd(i.shape,s)}),!s3(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function hd(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const r=n[s],i=e[s];if(r>=0&&i>=0&&r!==i)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=r>=0?r:i}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jS{constructor(e,t,s,r,i,o,a){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=r,this.identicalElementShapes=i,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=Mt(0),Hr(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),bs(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,Hr(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,r)=>this.write(s,t[r]))}gather(e,t){if(!!t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let r=0;r<this.size();r++)e.push(r)}if(e.length===0)return Vr([],[0].concat(this.elementShape));const s=this.readMany(e);return bs(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),vr(s,0)}concat(e){if(!!e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Vr([],[0].concat(this.elementShape));const t=[];for(let r=0;r<this.size();r++)t.push(r);const s=this.readMany(t);return bs(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),Sn(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,$i(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const r=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const i=s===0?0:t.size/s,o=[];xt(()=>{t=de(t,[1,s,i]);for(let l=0;l<e.length;++l){const c=l===0?0:r[l-1],u=[0,c,0],h=[1,e[l],i];o[l]=de(dt(t,u,h),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Co{constructor(e,t,s,r=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(i=>{if(s!==i.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${i.dtype}`);bs(t,i.shape,"TensorList shape mismatch: "),Hr(i)}),this.idTensor=Mt(0),this.maxNumElements=r,Hr(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Co([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);bs(e,this.elementShape,"TensorList shape mismatch: ");const r=tl(this.elementShape,this.tensors,e);return xt(()=>{const i=this.tensors.map(o=>de(o,r));return vr(i,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=tl(this.elementShape,this.tensors,e),r=this.tensors.pop();return bs(r.shape,e,"TensorList shape mismatch: "),de(r,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(bs(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");Hr(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=e}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);bs(this.tensors[e].shape,t,"TensorList shape mismatch: ");const r=tl(this.elementShape,this.tensors,t);return de(this.tensors[e],r)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);bs(this.elementShape,t.shape,"TensorList shape mismatch: "),Hr(t),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);bs(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const r=tl(this.elementShape,this.tensors,s);return e.length===0?Vr([],[0].concat(r)):xt(()=>{const i=e.map(o=>de(this.tensors[o],r));return vr(i,0)})}concat(e,t){if(!!e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);bs(this.elementShape,t,"TensorList shape mismatch: ");const s=tl(this.elementShape,this.tensors,t);return this.size()===0?Vr([],[0].concat(s)):xt(()=>{const r=this.tensors.map(i=>de(i,s));return Sn(r,0)})}}function qS(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const r=n.shape.slice(1);bs(r,e,"TensorList shape mismatch: ");const i=$i(n);return new Co(i,e,s)}function KS(n,e,t){return new Co([],n,e,t)}function YS(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(s!=null&&s!==-1&&r>=s)throw new Error(`Max index must be < array size (${r}  vs. ${s})`);const i=new Co([],t,n.dtype,s),o=$i(n,0);return e.forEach((a,l)=>{i.setItem(a,o[l])}),i}function ZS(n,e,t){let s=0;const r=e.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const i=n.shape.slice(1),o=hd(i,t),a=s===0?0:n.size/s,l=xt(()=>{const u=[];n=de(n,[1,s,a]);for(let h=0;h<e.length;++h){const d=h===0?0:r[h-1],p=[0,d,0],f=[1,e[h],a];u[h]=de(dt(n,p,f),o)}return n.dispose(),u}),c=new Co([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JS=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=S("thenBranch",n,e,t),r=S("elseBranch",n,e,t),i=S("cond",n,e,t),o=S("args",n,e,t);return(await i.data())[0]?t.functionMap[s].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap):t.functionMap[r].executeFunctionAsync(o,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=S("body",n,e,t),r=S("cond",n,e,t),i=S("args",n,e,t),o=await t.functionMap[r].executeFunctionAsync(i,t.tensorArrayMap,t.tensorListMap),a=i.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=i;for(;l[0];){const u=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[r].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&a.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{const s=S("pred",n,e,t);return[br(s)]}case"Switch":{const s=S("pred",n,e,t);let r=S("data",n,e,t);return r.kept||(r=br(r)),(await s.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const s=n.inputNames.find(r=>An(r,e,t)!==void 0);if(s){const r=An(s,e,t);return[br(r)]}return}case"Enter":{const s=S("frameName",n,e,t),r=S("tensor",n,e,t);return t.enterFrame(s),[br(r)]}case"Exit":{const s=S("tensor",n,e,t);return t.exitFrame(),[br(s)]}case"NextIteration":{const s=S("tensor",n,e,t);return t.nextIteration(),[br(s)]}case"TensorArrayV3":{const s=S("size",n,e,t),r=S("dtype",n,e,t),i=S("elementShape",n,e,t),o=S("dynamicSize",n,e,t),a=S("clearAfterRead",n,e,t),l=S("identicalElementShapes",n,e,t),c=S("name",n,e,t),u=new jS(c,r,s,i,l,o,a);return t.addTensorArray(u),[u.idTensor,Mt(1)]}case"TensorArrayWriteV3":{const s=S("tensorArrayId",n,e,t),r=S("index",n,e,t),i=S("tensor",n,e,t),o=t.getTensorArray(s.id);return o.write(r,i),[o.idTensor]}case"TensorArrayReadV3":{const s=S("tensorArrayId",n,e,t),r=S("index",n,e,t);return[t.getTensorArray(s.id).read(r)]}case"TensorArrayGatherV3":{const s=S("tensorArrayId",n,e,t),r=S("indices",n,e,t),i=S("dtype",n,e,t);return[t.getTensorArray(s.id).gather(r,i)]}case"TensorArrayScatterV3":{const s=S("tensorArrayId",n,e,t),r=S("indices",n,e,t),i=S("tensor",n,e,t),o=t.getTensorArray(s.id);return o.scatter(r,i),[o.idTensor]}case"TensorArrayConcatV3":{const s=S("tensorArrayId",n,e,t),r=t.getTensorArray(s.id),i=S("dtype",n,e,t);return[r.concat(i)]}case"TensorArraySplitV3":{const s=S("tensorArrayId",n,e,t),r=S("tensor",n,e,t),i=S("lengths",n,e,t),o=t.getTensorArray(s.id);return o.split(i,r),[o.idTensor]}case"TensorArraySizeV3":{const s=S("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return[Mt(r.size(),"int32")]}case"TensorArrayCloseV3":{const s=S("tensorArrayId",n,e,t),r=t.getTensorArray(s.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const s=S("tensorListId",n,e,t),r=S("index",n,e,t),i=S("tensor",n,e,t),o=t.getTensorList(s.id);return o.setItem(r,i),[o.idTensor]}case"TensorListGetItem":{const s=S("tensorListId",n,e,t),r=S("index",n,e,t),i=S("elementShape",n,e,t),o=S("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(r,i,o)]}case"TensorListScatterV2":case"TensorListScatter":{const s=S("indices",n,e,t),r=S("tensor",n,e,t),i=S("elementShape",n,e,t),o=S("numElements",n,e,t),a=YS(r,s,i,o);return t.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=S("elementShape",n,e,t),r=S("elementDType",n,e,t);let i;n.op==="TensorListReserve"?i="numElements":i="maxNumElements";const o=S(i,n,e,t),a=KS(s,r,o);return t.addTensorList(a),[a.idTensor]}case"TensorListGather":{const s=S("tensorListId",n,e,t),r=S("indices",n,e,t),i=S("elementShape",n,e,t),o=S("elementDType",n,e,t);return[t.getTensorList(s.id).gather(r,o,i)]}case"TensorListStack":{const s=S("tensorListId",n,e,t),r=S("elementShape",n,e,t),i=S("elementDType",n,e,t),o=S("numElements",n,e,t);return[t.getTensorList(s.id).stack(r,i,o)]}case"TensorListFromTensor":{const s=S("tensor",n,e,t),r=S("elementShape",n,e,t),i=S("elementDType",n,e,t),o=qS(s,r,i);return t.addTensorList(o),[o.idTensor]}case"TensorListConcat":{const s=S("tensorListId",n,e,t),r=t.getTensorList(s.id),i=S("dtype",n,e,t),o=S("elementShape",n,e,t);return[r.concat(i,o)]}case"TensorListPushBack":{const s=S("tensorListId",n,e,t),r=S("tensor",n,e,t),i=t.getTensorList(s.id);return i.pushBack(r),[i.idTensor]}case"TensorListPopBack":{const s=S("tensorListId",n,e,t),r=S("elementShape",n,e,t),i=S("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(r,i)]}case"TensorListSplit":{const s=S("tensor",n,e,t),r=S("elementShape",n,e,t),i=S("lengths",n,e,t),o=ZS(s,i,r);return t.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r3(n,e,t){const[s,r]=S("fusedOps",n,e,t),i=s==="biasadd",o=!i,a=r==="prelu",l=s==="fusedbatchnorm",c=S("numArgs",n,e,t);if(i){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&i&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=S("strides",n,e,t),h=wc(n,e,t),d=S("dataFormat",n,e,t).toUpperCase(),p=S("dilations",n,e,t);let[f,m]=S("args",n,e,t);o&&(m=f,f=void 0);const y=S("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:y}}const QS=(n,e,t)=>{switch(n.op){case"Conv1D":{const s=S("stride",n,e,t),r=S("pad",n,e,t),i=S("dataFormat",n,e,t).toUpperCase(),o=S("dilation",n,e,t);return[w8(S("x",n,e,t),S("filter",n,e,t),s,r,i,o)]}case"Conv2D":{const s=S("strides",n,e,t),r=wc(n,e,t),i=S("dataFormat",n,e,t).toUpperCase(),o=S("dilations",n,e,t);return[Ph(S("x",n,e,t),S("filter",n,e,t),[s[1],s[2]],r,i,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:s,pad:r,dataFormat:i,dilations:o,biasArg:a,preluArg:l,activationFunc:c,leakyreluAlpha:u}=r3(n,e,t);return[ww({x:S("x",n,e,t),filter:S("filter",n,e,t),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[o[1],o[2]],bias:a,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"FusedDepthwiseConv2dNative":{const{stride:s,pad:r,dataFormat:i,dilations:o,biasArg:a,preluArg:l,activationFunc:c,leakyreluAlpha:u}=r3(n,e,t);return[Mw({x:S("x",n,e,t),filter:S("filter",n,e,t),strides:[s[1],s[2]],pad:r,dataFormat:i,dilations:[o[1],o[2]],bias:a,activation:c,preluActivationWeights:l,leakyreluAlpha:u})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const s=S("outputShape",n,e,t),r=S("strides",n,e,t),i=wc(n,e,t);return[T8(S("x",n,e,t),S("filter",n,e,t),s,[r[1],r[2]],i)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const s=S("strides",n,e,t),r=wc(n,e,t),i=S("dilations",n,e,t),o=S("dataFormat",n,e,t).toUpperCase();return[N2(S("input",n,e,t),S("filter",n,e,t),[s[1],s[2]],r,o,[i[1],i[2]])]}case"Conv3D":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("dataFormat",n,e,t).toUpperCase(),o=S("dilations",n,e,t);return[C8(S("x",n,e,t),S("filter",n,e,t),[s[1],s[2],s[3]],r,i,[o[1],o[2],o[3]])]}case"AvgPool":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[Jv(S("x",n,e,t),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPool":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[$b(S("x",n,e,t),[i[1],i[2]],[s[1],s[2]],r)]}case"MaxPoolWithArgmax":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("kernelSize",n,e,t),o=S("includeBatchInIndex",n,e,t),{result:a,indexes:l}=zb(S("x",n,e,t),[i[1],i[2]],[s[1],s[2]],r,o);return[a,l]}case"AvgPool3D":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[e8(S("x",n,e,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"MaxPool3D":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("kernelSize",n,e,t);return[Ob(S("x",n,e,t),[i[1],i[2],i[3]],[s[1],s[2],s[3]],r)]}case"Dilation2D":{const s=S("strides",n,e,t),r=S("pad",n,e,t),i=S("dilations",n,e,t),o=s[1],a=s[2],l=i[1],c=i[2];return[B8(S("x",n,e,t),S("filter",n,e,t),[o,a],r,[l,c],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=(n,e,t)=>{switch(n.op){case"Fill":{const s=S("shape",n,e,t),r=S("dtype",n,e,t),i=S("value",n,e,t);return[kh(s,i,r)]}case"LinSpace":{const s=S("start",n,e,t),r=S("stop",n,e,t),i=S("num",n,e,t);return[mb(s,r,i)]}case"Multinomial":{const s=S("logits",n,e,t),r=S("numSamples",n,e,t),i=S("seed",n,e,t);return[Jb(s,r,i)]}case"OneHot":{const s=S("indices",n,e,t),r=S("depth",n,e,t),i=S("onValue",n,e,t),o=S("offValue",n,e,t);return[rv(s,r,i,o)]}case"Ones":return[zh(S("shape",n,e,t),S("dtype",n,e,t))];case"OnesLike":return[t7(S("x",n,e,t))];case"RandomUniform":return[y7(S("shape",n,e,t),S("minval",n,e,t),S("maxval",n,e,t),S("dtype",n,e,t))];case"Range":{const s=S("start",n,e,t),r=S("stop",n,e,t),i=S("step",n,e,t);return[Ja(s,r,i,S("dtype",n,e,t))]}case"TruncatedNormal":{const s=S("shape",n,e,t),r=S("mean",n,e,t),i=S("stdDev",n,e,t),o=S("seed",n,e,t);return[iw(s,r,i,S("dtype",n,e,t),o)]}case"Zeros":return[Di(S("shape",n,e,t),S("dtype",n,e,t))];case"ZerosLike":return[Dh(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dd(n,e,t){const s=S("boxes",n,e,t),r=S("scores",n,e,t),i=S("maxOutputSize",n,e,t),o=S("iouThreshold",n,e,t),a=S("scoreThreshold",n,e,t),l=S("softNmsSigma",n,e,t);return{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const tT=async(n,e,t)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}=dd(n,e,t),c=await ys.nonMaxSuppressionWithScoreAsync(s,r,i,o,a,l);return[c.selectedIndices,c.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a}=dd(n,e,t),l=S("padToMaxOutputSize",n,e,t),c=await ys.nonMaxSuppressionPaddedAsync(s,r,i,o,a,l);return[c.selectedIndices,c.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:r,maxOutputSize:i,iouThreshold:o,scoreThreshold:a}=dd(n,e,t);return[await ys.nonMaxSuppressionAsync(s,r,i,o,a)]}case"Where":{const s=Xt(S("condition",n,e,t),"bool"),r=[await cw(s)];return s.dispose(),r}case"ListDiff":return N7(S("x",n,e,t),S("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nT=(n,e,t)=>{switch(n.op){case"TopKV2":{const s=S("x",n,e,t),r=S("k",n,e,t),i=S("sorted",n,e,t),o=sw(s,r,i);return[o.values,o.indices]}case"Unique":{const s=S("x",n,e,t),r=ig(s);return[r.values,r.indices]}case"UniqueV2":{const s=S("x",n,e,t),r=S("axis",n,e,t),i=ig(s,r);return[i.values,i.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sT=(n,e,t)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const s=S("default",n,e,t);return[An(n.name,e,t)||s];case"Placeholder":return[An(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const c=S("x",n,e,t);return[br(c)]}case"IdentityN":return S("x",n,e,t).map(c=>br(c));case"Snapshot":const r=S("x",n,e,t);return[br(r)];case"Shape":return[cn(S("x",n,e,t).shape,"int32")];case"ShapeN":return S("x",n,e,t).map(c=>cn(c.shape));case"Size":return[Mt(S("x",n,e,t).size,"int32")];case"Rank":return[Mt(S("x",n,e,t).rank,"int32")];case"NoOp":return[Mt(1)];case"Print":const i=S("x",n,e,t),o=S("data",n,e,t),a=S("message",n,e,t),l=S("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(a);for(let c=0;c<o.length;c++)console.log(Array.prototype.slice.call(o[c].dataSync()).slice(0,l));return[i];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rT{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Mt(0),this.tensorMap=new Map,Hr(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Mt(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(r=>r.dispose()),this.tensorMap.clear(),xt(()=>{const r=$i(t),i=s.length,o=r.length;O(i===o,()=>`The number of elements doesn't match, keys has ${i} elements, the values has ${o} elements.`);for(let a=0;a<i;a++){const l=s[a],c=r[a];Hr(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return xt(()=>{const r=[];for(let i=0;i<s.length;i++){const o=s[i],a=this.findWithDefault(o,t);r.push(a)}return vr(r)})}findWithDefault(e,t){const s=this.tensorMap.get(e);return s!=null?s:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iT=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const r=S("keyDType",n,e,t),i=S("valueDType",n,e,t),o=new rT(r,i);return s.addHashTable(n.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=S("tableHandle",n,e,t,s),i=S("keys",n,e,t),o=S("values",n,e,t);return[await s.getHashTableById(r.id).import(i,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=S("tableHandle",n,e,t,s),i=S("keys",n,e,t),o=S("defaultValue",n,e,t);return[await s.getHashTableById(r.id).find(i,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=S("tableHandle",n,e,t,s);return[s.getHashTableById(r.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT=(n,e,t)=>{switch(n.op){case"ResizeBilinear":{const s=S("images",n,e,t),r=S("size",n,e,t),i=S("alignCorners",n,e,t),o=S("halfPixelCenters",n,e,t);return[ys.resizeBilinear(s,[r[0],r[1]],i,o)]}case"ResizeNearestNeighbor":{const s=S("images",n,e,t),r=S("size",n,e,t),i=S("alignCorners",n,e,t),o=S("halfPixelCenters",n,e,t);return[ys.resizeNearestNeighbor(s,[r[0],r[1]],i,o)]}case"CropAndResize":{const s=S("image",n,e,t),r=S("boxes",n,e,t),i=S("boxInd",n,e,t),o=S("cropSize",n,e,t),a=S("method",n,e,t),l=S("extrapolationValue",n,e,t);return[ys.cropAndResize(s,r,i,o,a,l)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aT=(n,e,t)=>{switch(n.op){case"Equal":return[L2(S("a",n,e,t),S("b",n,e,t))];case"NotEqual":return[V2(S("a",n,e,t),S("b",n,e,t))];case"Greater":return[uc(S("a",n,e,t),S("b",n,e,t))];case"GreaterEqual":return[k2(S("a",n,e,t),S("b",n,e,t))];case"Less":return[pb(S("a",n,e,t),S("b",n,e,t))];case"LessEqual":return[Fh(S("a",n,e,t),S("b",n,e,t))];case"LogicalAnd":return[B2(S("a",n,e,t),S("b",n,e,t))];case"LogicalNot":return[Lb(S("a",n,e,t))];case"LogicalOr":return[Db(S("a",n,e,t),S("b",n,e,t))];case"Select":case"SelectV2":return[So(S("condition",n,e,t),S("a",n,e,t),S("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lT=(n,e,t)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[ln(S("a",n,e,t),S("b",n,e,t),S("transposeA",n,e,t),S("transposeB",n,e,t))];case"Einsum":return[X8(S("equation",n,e,t),...S("tensors",n,e,t))];case"Transpose":return[Eh(S("x",n,e,t),S("perm",n,e,t))];case"_FusedMatMul":const[s,r]=S("fusedOps",n,e,t),i=s==="biasadd",o=r==="prelu",a=S("numArgs",n,e,t),l=S("leakyreluAlpha",n,e,t);if(i){if(o&&a!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&a!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[c,u]=S("args",n,e,t);return[Rw({a:S("a",n,e,t),b:S("b",n,e,t),transposeA:S("transposeA",n,e,t),transposeB:S("transposeB",n,e,t),bias:c,activation:r,preluActivationWeights:u,leakyreluAlpha:l})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cT=(n,e,t)=>{switch(n.op){case"FusedBatchNorm":case"FusedBatchNormV2":return[M2(S("x",n,e,t),S("mean",n,e,t),S("variance",n,e,t),S("offset",n,e,t),S("scale",n,e,t),S("epsilon",n,e,t))];case"FusedBatchNormV3":return[M2(S("x",n,e,t),S("mean",n,e,t),S("variance",n,e,t),S("offset",n,e,t),S("scale",n,e,t),S("epsilon",n,e,t))];case"LRN":return[xb(S("x",n,e,t),S("radius",n,e,t),S("bias",n,e,t),S("alpha",n,e,t),S("beta",n,e,t))];case"Softmax":return[B7(S("x",n,e,t))];case"LogSoftmax":return[Mb(S("x",n,e,t))];case"SparseToDense":return[cg(S("sparseIndices",n,e,t),S("outputShape",n,e,t),S("sparseValues",n,e,t),S("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uT=(n,e,t)=>{switch(n.op){case"Max":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[To(S("x",n,e,t),o,a)]}case"Mean":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[z2(S("x",n,e,t),o,a)]}case"Min":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[Uh(S("x",n,e,t),o,a)]}case"Sum":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[Vt(S("x",n,e,t),o,a)]}case"All":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[Rv(S("x",n,e,t),o,a)]}case"Any":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[Nv(S("x",n,e,t),o,a)]}case"ArgMax":{const o=S("axis",n,e,t);return[Pv(S("x",n,e,t),o)]}case"ArgMin":{const o=S("axis",n,e,t);return[kv(S("x",n,e,t),o)]}case"Prod":{const o=S("axis",n,e,t),a=S("keepDims",n,e,t);return[H2(S("x",n,e,t),o,a)]}case"Cumsum":{const o=S("axis",n,e,t),a=S("exclusive",n,e,t),l=S("reverse",n,e,t);return[L8(S("x",n,e,t),o,a,l)]}case"Bincount":const s=S("x",n,e,t),r=S("weights",n,e,t),i=S("size",n,e,t);return[A2(s,r,i)];case"DenseBincount":{const o=S("x",n,e,t),a=S("weights",n,e,t),l=S("size",n,e,t),c=S("binaryOutput",n,e,t);return[D8(o,a,l,c)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hT=(n,e,t)=>{switch(n.op){case"ConcatV2":case"Concat":{const s=S("n",n,e,t),r=S("axis",n,e,t);let i=S("tensors",n,e,t);return i=i.slice(0,s),[Sn(i,r)]}case"Gather":{const s=S("x",n,e,t),r=S("indices",n,e,t);return[D2(s,Xt(r,"int32"),0)]}case"GatherV2":{const s=S("axis",n,e,t),r=S("batchDims",n,e,t),i=S("x",n,e,t),o=S("indices",n,e,t);return[D2(i,Xt(o,"int32"),s,r)]}case"Reverse":{const s=S("dims",n,e,t),r=[];for(let o=0;o<s.length;o++)s[o]&&r.push(o);const i=S("x",n,e,t);return[pc(i,r)]}case"ReverseV2":{const s=S("axis",n,e,t),r=S("x",n,e,t);return[pc(r,s)]}case"Slice":{const s=S("begin",n,e,t),r=S("size",n,e,t);return[dt(S("x",n,e,t),s,r)]}case"StridedSlice":{const s=S("begin",n,e,t),r=S("end",n,e,t),i=S("strides",n,e,t),o=S("beginMask",n,e,t),a=S("endMask",n,e,t),l=S("ellipsisMask",n,e,t),c=S("newAxisMask",n,e,t),u=S("shrinkAxisMask",n,e,t),h=S("x",n,e,t);return[Q7(h,s,r,i,o,a,l,c,u)]}case"Pack":return xt(()=>{const s=S("axis",n,e,t),r=S("tensors",n,e,t),i=r[0].shape,o=Ds(r[0]).shape,a=r.map(l=>{const c=Qt(l.shape,i);if(!c&&!Qt(Ds(l).shape,o))throw new Error("the input tensors shape does not match");return c?l:de(l,i)});return[vr(a,s)]});case"Unpack":{const s=S("axis",n,e,t),r=S("tensor",n,e,t);return $i(r,s)}case"Tile":{const s=S("reps",n,e,t);return[Ka(S("x",n,e,t),s)]}case"Split":case"SplitV":{const s=S("axis",n,e,t),r=S("numOrSizeSplits",n,e,t),i=S("x",n,e,t);return Qa(i,r,s)}case"ScatterNd":{const s=S("indices",n,e,t),r=S("values",n,e,t),i=S("shape",n,e,t);return[dw(s,r,i)]}case"GatherNd":{const s=S("x",n,e,t),r=S("indices",n,e,t);return[gw(s,r)]}case"SparseToDense":{const s=S("sparseIndices",n,e,t),r=S("outputShape",n,e,t),i=S("sparseValues",n,e,t),o=S("defaultValue",n,e,t);return[cg(s,i,r,i.dtype===o.dtype?o:Xt(o,i.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dT=(n,e,t)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:s,outputValues:r,emptyRowIndicator:i,reverseIndexMap:o}=yc.sparseFillEmptyRows(S("indices",n,e,t),S("values",n,e,t),S("denseShape",n,e,t),S("defaultValue",n,e,t));return[s,r,i,o]}case"SparseReshape":{const{outputIndices:s,outputShape:r}=yc.sparseReshape(S("inputIndices",n,e,t),S("inputShape",n,e,t),S("newShape",n,e,t));return[s,r]}case"SparseSegmentMean":return[yc.sparseSegmentMean(S("data",n,e,t),S("indices",n,e,t),S("segmentIds",n,e,t))];case"SparseSegmentSum":return[yc.sparseSegmentSum(S("data",n,e,t),S("indices",n,e,t),S("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pT=(n,e,t)=>{switch(n.op){case"FFT":return[ng(S("x",n,e,t))];case"IFFT":return[Gh(S("x",n,e,t))];case"RFFT":return[sg(S("x",n,e,t))];case"IRFFT":return[G7(S("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fT=(n,e,t)=>{switch(n.op){case"StringNGrams":{const{nGrams:s,nGramsSplits:r}=Xh.stringNGrams(S("data",n,e,t),S("dataSplits",n,e,t),S("separator",n,e,t),S("nGramWidths",n,e,t),S("leftPad",n,e,t),S("rightPad",n,e,t),S("padWidth",n,e,t),S("preserveShortSequences",n,e,t));return[s,r]}case"StringSplit":{const{indices:s,values:r,shape:i}=Xh.stringSplit(S("input",n,e,t),S("delimiter",n,e,t),S("skipEmpty",n,e,t));return[s,r,i]}case"StringToHashBucketFast":return[Xh.stringToHashBucketFast(S("input",n,e,t),S("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mT=(n,e,t)=>{switch(n.op){case"Cast":return[Xt(S("x",n,e,t),S("dtype",n,e,t))];case"ExpandDims":{const s=S("axis",n,e,t);return[yr(S("x",n,e,t),s)]}case"Squeeze":{const s=S("axis",n,e,t);return[Ds(S("x",n,e,t),s)]}case"Reshape":return[de(S("x",n,e,t),S("shape",n,e,t))];case"MirrorPad":return[jb(S("x",n,e,t),S("padding",n,e,t),S("mode",n,e,t))];case"PadV2":case"Pad":return[s7(S("x",n,e,t),S("padding",n,e,t),S("constantValue",n,e,t))];case"SpaceToBatchND":{const s=S("blockShape",n,e,t),r=S("paddings",n,e,t);return[i7(S("x",n,e,t),s,r)]}case"BatchToSpaceND":{const s=S("blockShape",n,e,t),r=S("crops",n,e,t);return[a8(S("x",n,e,t),s,r)]}case"DepthToSpace":{const s=S("blockSize",n,e,t),r=S("dataFormat",n,e,t).toUpperCase();return[$8(S("x",n,e,t),s,r)]}case"BroadcastTo":return[cc(S("x",n,e,t),S("shape",n,e,t))];case"BroadcastArgs":return[d8(S("s0",n,e,t),S("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i3(n,e,t,s){const r=((i,o,a)=>{switch(i.category){case"arithmetic":return xt(()=>HS(i,o,a));case"basic_math":return xt(()=>XS(i,o,a));case"control":return JS(i,o,a);case"convolution":return xt(()=>QS(i,o,a));case"creation":return xt(()=>eT(i,o,a));case"dynamic":return tT(i,o,a);case"evaluation":return xt(()=>nT(i,o,a));case"image":return xt(()=>oT(i,o,a));case"graph":return xt(()=>sT(i,o,a));case"logical":return xt(()=>aT(i,o,a));case"matrices":return xt(()=>lT(i,o,a));case"normalization":return xt(()=>cT(i,o,a));case"reduction":return xt(()=>uT(i,o,a));case"slice_join":return xt(()=>hT(i,o,a));case"sparse":return xt(()=>dT(i,o,a));case"spectral":return xt(()=>pT(i,o,a));case"string":return xt(()=>fT(i,o,a));case"transformation":return xt(()=>mT(i,o,a));case"hash_table":return iT(i,o,a,s);case"custom":const l=Jg(i.op);if(l&&l.customExecutor)return l.customExecutor(new WS(i,o,a));throw TypeError(`Custom op ${i.op} is not registered.`);default:throw TypeError(`Unknown op '${i.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Fa(r)?r.then(i=>[].concat(i)):[].concat(r)}class o3{constructor(e={},t={},s={},r={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=r,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a3(n,e,t,s){const r=new Set,i=[];let o=null,a=null;const l=new Set,c=Object.keys(n).map(d=>qn(d)[0]);let u=[];s!=null&&(u=s.map(d=>qn(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((l3(d)||bT(d)||wT(d))&&o==null&&(o=d,a=o.children.map(p=>p.name).filter(p=>r.has(p))),r.add(d.name),t[d.name]==null&&c.indexOf(d.name)===-1&&u.indexOf(d.name)===-1){if(d.inputs.length===0){i.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:r,missingInputs:i,dynamicNode:o,syncInputs:a}}function gT(n,e,t){const{usedNodes:s,inputs:r}=t,i=[],o=Object.keys(r).map(u=>qn(u)[0]).map(u=>n.nodes[u]),a=n.initNodes;o.forEach(u=>{s.has(u.name)&&i.push(u)}),n.weights.forEach(u=>{s.has(u.name)&&i.push(u)}),a!=null&&a.forEach(u=>{s.has(u.name)&&i.push(u)});const l=new Set,c=[];for(;i.length>0;){const u=i.pop();l.add(u.name),e[u.name]||c.push(u),u.children.forEach(h=>{!l.has(h.name)&&s.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&i.push(h)})}return c}const xT=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],yT=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],vT=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function l3(n){return xT.indexOf(n.op)>=0}function bT(n){return yT.indexOf(n.op)>=0}function wT(n){return vT.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _c{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new _c(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(r=>r.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const s=e.map(i=>i.name).sort(),r=t.map(i=>i.name).sort();return s.join(this.SEPERATOR)+"--"+r.join(this.SEPERATOR)}compile(e,t){const s=a3(e,t,this.weightMap,this._initNodes),{missingInputs:r,dynamicNode:i,syncInputs:o}=s;if(i!=null)throw new Error(`This execution contains the node '${i.name}', which has the dynamic op '${i.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(r.length>0){const a=t.map(c=>c.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${r}]`)}return gT(this.graph,this.weightMap,s)}execute(e,t){e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const r=s.map(h=>this.graph.nodes[qn(h)[0]]),i=t.map(h=>qn(h)[0]);let o=i.map(h=>this.graph.nodes[h]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const a=this.getCompilationKey(r,o);let l=this.compiledMap.get(a);l==null&&(l=this.compile(e,o),this.compiledMap.set(a,l));const c={},u={};return xt(()=>{const h=new o3(this.weightMap,c,u,this.functionExecutorMap),d=Object.assign({},this.weightMap);Object.keys(e).forEach(m=>{const[y,g]=qn(m),x=[];x[g]=e[m],d[y]=x});const p=this.getFrozenTensorIds(d),f={};for(let m=0;m<l.length;m++){const y=l[m];if(!d[y.name]){const g=i3(y,d,h,this._resourceManager);if(Fa(g))throw new Error(`The execution of the op '${y.op}' returned a promise. Please use model.executeAsync() instead.`);d[y.name]=g,this.checkTensorForDisposal(y.name,y,d,h,p,i,f)}}return this.parent==null&&h.dispose(p),t.map(m=>An(m,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(r=>r.id)));return new Set(t)}checkTensorForDisposal(e,t,s,r,i,o,a){t.category==="control"||o.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(a[l.id]=(a[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const c=rS(l.name,s,r);c!=null&&c.forEach(u=>{if(u&&!u.kept&&!i.has(u.id)){const h=a[u.id];if(h===1){if(!this.keepTensorForDebug)u.dispose();else{const[d,p]=js(t.name,r);this.intermediateTensors[d]?this.intermediateTensors[d][p]=u:(this.intermediateTensors[d]=[],this.intermediateTensors[d][p]=u)}delete a[u.id]}else h!=null&&a[u.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){!this.intermediateTensors||(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(t=>t.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){!this.tensorsMap||Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(s=>{s&&!s.kept&&!s.isDisposed&&!this.keepIds.has(s.id)&&s.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(t=>t.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,t,s=!1,r={},i={}){s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();const o=new o3(this.weightMap,r,i,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,o,t,s);const a=t.map(u=>An(u,this.tensorsMap,o)),l=a.map(u=>u.id),c=Object.keys(e).map(u=>e[u].id);return this.keepIds=new Set([...l,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),a}async executeFunctionAsync(e,t,s){const r=e.reduce((i,o,a)=>(i[this.inputs[a].name]=o,i),{});return this._executeAsync(r,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,r){const i=Object.keys(e),o=i.map(b=>this.graph.nodes[qn(b)[0]]),a=s.map(b=>qn(b)[0]);let l=a.map(b=>this.graph.nodes[b]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:u,dynamicNode:h,syncInputs:d}=a3(e,l,this.weightMap,this._initNodes),p=[...o,...this.graph.weights,...this._initNodes||[]].map(b=>({node:b,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(b=>{const[w,C]=qn(b),M=[];M[C]=e[b],f[w]=M});const m={},y=this.getFrozenTensorIds(f),g={};for(;p.length>0;){const b=this.processStack(o,p,t,f,g,y,a,m,c);await Promise.all(b)}h==null&&!r&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const x=l.filter(b=>!l3(b)&&!An(b.name,f,t)).map(b=>b.name);if(x.length>0){let b="";throw h!=null&&(b=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${x}] from the provided inputs [${i}]. Consider providing the following inputs: [${u}]. ${b}`)}return f}processStack(e,t,s,r,i,o,a,l,c){const u=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&S("isConstant",h.node,r,s)&&([d]=js(h.node.name,s)),r[h.node.name]==null){const p=i3(h.node,r,s,this._resourceManager);d||([d]=js(h.node.name,s));const f=s.currentContext;Fa(p)?u.push(p.then(m=>(r[d]=m,s.currentContext=f,this.checkTensorForDisposal(d,h.node,r,s,o,a,l),this.processChildNodes(h.node,t,s,r,i,c),m))):(r[d]=p,this.checkTensorForDisposal(d,h.node,r,s,o,a,l),this.processChildNodes(h.node,t,s,r,i,c))}else this.processChildNodes(h.node,t,s,r,i,c)}return u}processChildNodes(e,t,s,r,i,o){e.children.forEach(a=>{const[l]=js(a.name,s);i[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!An(c,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:a})):a.inputNames.every(c=>!!An(c,r,s))&&(i[l]=!0,t.push({contexts:s.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[r]=qn(t),i=this.graph.nodes[r];if(i.attrParams.shape&&i.attrParams.shape.value){const o=i.attrParams.shape.value,a=o.length===s.shape.length&&s.shape.every((l,c)=>o[c]===-1||o[c]===l);O(a,()=>`The shape of dict['${i.name}'] provided in model.execute(dict) must be [${o}], but was [${s.shape}]`)}i.attrParams.dtype&&i.attrParams.dtype.value&&O(s.dtype===i.attrParams.dtype.value,()=>`The dtype of dict['${i.name}'] provided in model.execute(dict) must be ${i.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){const t={};for(const s in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[s]!=null){const r=this._signature.inputs[s];t[r.name]=e[s]}else t[s]=e[s];return t}checkInputs(e){const t=Object.keys(e).filter(s=>{const[r]=qn(s);return this.graph.nodes[r]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[t]!=null?this._signature.outputs[t].name:t,{})}checkOutputs(e){e.forEach(t=>{const[s]=qn(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class _T{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ST="?tfjs-format=file",TT="model.json";class ET{constructor(e,t={}){this.modelUrl=e,this.loadOptions=t,this.version="n/a",t==null&&(this.loadOptions={}),this.resourceManager=new _T}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=o2(e,this.loadOptions);else{const t=A6(e,this.loadOptions);if(t.length===0)t.push(o2(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}async load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=await this.handler.load();return this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s;this.artifacts.userDefinedMetadata!=null&&this.artifacts.userDefinedMetadata.signature!=null?s=this.artifacts.userDefinedMetadata.signature:s=this.artifacts.signature,this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const r=y6(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new _c(Qg.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(r),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const i=Qg.Instance.transformGraph(e.modelInitializer);this.initializer=new _c(i),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if(typeof e=="string"){const s=M6(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){return this.execute(e,this.outputNodes)}normalizeInputs(e){if(!(e instanceof Zt)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((t,s,r)=>(t[s]=e[r],t),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function Mo(n,e={}){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&n.load==null&&(n.endsWith("/")||(n=n+"/"),n=`${n}${TT}${ST}`);const t=new ET(n,e);return await t.load(),t}/**
    * @license
    * Copyright 2021 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var pd=function(){return(pd=Object.assign||function(n){for(var e,t=1,s=arguments.length;t<s;t++)for(var r in e=arguments[t])Object.prototype.hasOwnProperty.call(e,r)&&(n[r]=e[r]);return n}).apply(this,arguments)};function wr(n,e,t,s){return new(t||(t=Promise))(function(r,i){function o(c){try{l(s.next(c))}catch(u){i(u)}}function a(c){try{l(s.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?r(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((s=s.apply(n,e||[])).next())})}function _r(n,e){var t,s,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,s&&(r=2&u[0]?s.return:u[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,u[1])).done)return r;switch(s=0,r&&(u=[2&u[0],r.value]),u[0]){case 0:case 1:r=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,s=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(r=o.trys,!((r=r.length>0&&r[r.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!r||u[1]>r[0]&&u[1]<r[3])){o.label=u[1];break}if(u[0]===6&&o.label<r[1]){o.label=r[1],r=u;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(u);break}r[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],s=0}finally{t=r=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function Ao(n,e,t,s){return new(t||(t=Promise))(function(r,i){function o(c){try{l(s.next(c))}catch(u){i(u)}}function a(c){try{l(s.throw(c))}catch(u){i(u)}}function l(c){var u;c.done?r(c.value):(u=c.value,u instanceof t?u:new t(function(h){h(u)})).then(o,a)}l((s=s.apply(n,e||[])).next())})}function Ro(n,e){var t,s,r,i,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return i={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(i[Symbol.iterator]=function(){return this}),i;function a(l){return function(c){return function(u){if(t)throw new TypeError("Generator is already executing.");for(;o;)try{if(t=1,s&&(r=2&u[0]?s.return:u[0]?s.throw||((r=s.return)&&r.call(s),0):s.next)&&!(r=r.call(s,u[1])).done)return r;switch(s=0,r&&(u=[2&u[0],r.value]),u[0]){case 0:case 1:r=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,s=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(r=(r=o.trys).length>0&&r[r.length-1])&&(u[0]===6||u[0]===2)){o=0;continue}if(u[0]===3&&(!r||u[1]>r[0]&&u[1]<r[3])){o.label=u[1];break}if(u[0]===6&&o.label<r[1]){o.label=r[1],r=u;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(u);break}r[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(n,o)}catch(h){u=[6,h],s=0}finally{t=r=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}var c3=function(n){return{startEndTensor:n,startPoint:dt(n,[0,0],[-1,2]),endPoint:dt(n,[0,2],[-1,2])}},CT={strides:[8,16],anchors:[2,6]};function u3(n,e){var t,s,r;if(n.topLeft instanceof Zt&&n.bottomRight instanceof Zt){var i=xt(function(){return[Sn([dt(pt(e-1,n.topLeft),0,1),dt(n.topLeft,1,1)]),Sn([pt(e-1,dt(n.bottomRight,0,1)),dt(n.bottomRight,1,1)])]});t=i[0],s=i[1],n.landmarks!=null&&(r=xt(function(){var p=pt(cn([e-1,0]),n.landmarks),f=cn([1,-1]);return tt(p,f)}))}else{var o=n.topLeft,a=o[0],l=o[1],c=n.bottomRight,u=c[0],h=c[1];t=[e-1-a,l],s=[e-1-u,h],n.landmarks!=null&&(r=n.landmarks.map(function(p){return[e-1-p[0],p[1]]}))}var d={topLeft:t,bottomRight:s};return r!=null&&(d.landmarks=r),n.probability!=null&&(d.probability=n.probability instanceof Zt?n.probability.clone():n.probability),d}function h3(n,e){return xt(function(){var t;return t=n.hasOwnProperty("box")?n.box:n,Ds(function(s,r){var i=tt(s.startPoint,r),o=tt(s.endPoint,r),a=R2([i,o],1);return c3(a)}(t,e).startEndTensor)})}var MT=function(){function n(e,t,s,r,i,o){this.blazeFaceModel=e,this.width=t,this.height=s,this.maxFaces=r,this.anchorsData=function(a,l,c){for(var u=[],h=0;h<c.strides.length;h++)for(var d=c.strides[h],p=Math.floor((l+d-1)/d),f=Math.floor((a+d-1)/d),m=c.anchors[h],y=0;y<p;y++)for(var g=d*(y+.5),x=0;x<f;x++)for(var b=d*(x+.5),w=0;w<m;w++)u.push([b,g]);return u}(t,s,CT),this.anchors=jr(this.anchorsData),this.inputSizeData=[t,s],this.inputSize=cn([t,s]),this.iouThreshold=i,this.scoreThreshold=o}return n.prototype.getBoundingBoxes=function(e,t,s){return s===void 0&&(s=!0),Ao(this,void 0,void 0,function(){var r,i,o,a,l,c,u,h,d,p,f,m,y,g,x=this;return Ro(this,function(b){switch(b.label){case 0:return r=xt(function(){var w=ys.resizeBilinear(e,[x.width,x.height]),C=tt(pt(rn(w,255),.5),2),M=x.blazeFaceModel.predict(C),E=Ds(M),A=function(B,R,K){var F=dt(B,[0,1],[-1,2]),z=_n(F,R),V=dt(B,[0,3],[-1,2]),H=rn(V,K),j=rn(z,K),ae=rn(H,2),fe=pt(j,ae),Q=_n(j,ae),te=tt(fe,K),Te=tt(Q,K);return R2([te,Te],1)}(E,x.anchors,x.inputSize),$=dt(E,[0,0],[-1,1]);return[E,A,Ds(Lh($))]}),i=r[0],o=r[1],a=r[2],l=console.warn,console.warn=function(){},c=ys.nonMaxSuppression(o,a,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,c.array()];case 1:return u=b.sent(),c.dispose(),h=u.map(function(w){return dt(o,[w,0],[1,-1])}),t?[3,3]:[4,Promise.all(h.map(function(w){return Ao(x,void 0,void 0,function(){var C;return Ro(this,function(M){switch(M.label){case 0:return[4,w.array()];case 1:return C=M.sent(),w.dispose(),[2,C]}})})}))];case 2:h=b.sent(),b.label=3;case 3:for(d=e.shape[1],p=e.shape[2],f=t?rn([p,d],this.inputSize):[p/this.inputSizeData[0],d/this.inputSizeData[1]],m=[],y=function(w){var C=h[w],M=xt(function(){var E=c3(C instanceof Zt?C:jr(C));if(!s)return E;var A,$=u[w];return A=t?dt(x.anchors,[$,0],[1,2]):x.anchorsData[$],{box:E,landmarks:de(Ds(dt(i,[$,5],[1,-1])),[6,-1]),probability:dt(a,[$],[1]),anchor:A}});m.push(M)},g=0;g<h.length;g++)y(g);return o.dispose(),a.dispose(),i.dispose(),[2,{boxes:m,scaleFactor:f}]}})})},n.prototype.estimateFaces=function(e,t,s,r){return t===void 0&&(t=!1),s===void 0&&(s=!1),r===void 0&&(r=!0),Ao(this,void 0,void 0,function(){var i,o,a,l,c,u,h=this;return Ro(this,function(d){switch(d.label){case 0:return i=function(p){return p instanceof Zt?[p.shape[0],p.shape[1]]:[p.height,p.width]}(e),o=i[1],a=xt(function(){return e instanceof Zt||(e=l2(e)),yr(Xt(e,"float32"),0)}),[4,this.getBoundingBoxes(a,t,r)];case 1:return l=d.sent(),c=l.boxes,u=l.scaleFactor,a.dispose(),t?[2,c.map(function(p){var f=h3(p,u),m={topLeft:dt(f,[0],[2]),bottomRight:dt(f,[2],[2])};if(r){var y=p,g=y.landmarks,x=y.probability,b=y.anchor,w=tt(_n(g,b),u);m.landmarks=w,m.probability=x}return s&&(m=u3(m,o)),m})]:[2,Promise.all(c.map(function(p){return Ao(h,void 0,void 0,function(){var f,m,y,g,x,b,w,C,M,E,A,$=this;return Ro(this,function(B){switch(B.label){case 0:return f=h3(p,u),r?[3,2]:[4,f.array()];case 1:return x=B.sent(),m={topLeft:x.slice(0,2),bottomRight:x.slice(2)},[3,4];case 2:return[4,Promise.all([p.landmarks,f,p.probability].map(function(R){return Ao($,void 0,void 0,function(){return Ro(this,function(K){return[2,R.array()]})})}))];case 3:y=B.sent(),g=y[0],x=y[1],b=y[2],w=p.anchor,M=(C=u)[0],E=C[1],A=g.map(function(R){return[(R[0]+w[0])*M,(R[1]+w[1])*E]}),m={topLeft:x.slice(0,2),bottomRight:x.slice(2),landmarks:A,probability:b},function(R){R.startEndTensor.dispose(),R.startPoint.dispose(),R.endPoint.dispose()}(p.box),p.landmarks.dispose(),p.probability.dispose(),B.label=4;case 4:return f.dispose(),s&&(m=u3(m,o)),[2,m]}})})}))]}})})},n}();function AT(n){var e=n===void 0?{}:n,t=e.maxFaces,s=t===void 0?10:t,r=e.inputWidth,i=r===void 0?128:r,o=e.inputHeight,a=o===void 0?128:o,l=e.iouThreshold,c=l===void 0?.3:l,u=e.scoreThreshold,h=u===void 0?.75:u,d=e.modelUrl;return Ao(this,void 0,void 0,function(){var p;return Ro(this,function(f){switch(f.label){case 0:return d==null?[3,2]:[4,Mo(d)];case 1:return p=f.sent(),[3,4];case 2:return[4,Mo("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:p=f.sent(),f.label=4;case 4:return[2,new MT(p,i,a,s,c,h)]}})})}var Sr={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function Sc(n){return[Math.abs(n.endPoint[0]-n.startPoint[0]),Math.abs(n.endPoint[1]-n.startPoint[1])]}function Tc(n){return[n.startPoint[0]+(n.endPoint[0]-n.startPoint[0])/2,n.startPoint[1]+(n.endPoint[1]-n.startPoint[1])/2]}function fd(n,e){e===void 0&&(e=1.5);var t=Tc(n),s=Sc(n),r=[e*s[0]/2,e*s[1]/2];return{startPoint:[t[0]-r[0],t[1]-r[1]],endPoint:[t[0]+r[0],t[1]+r[1]],landmarks:n.landmarks}}function md(n){var e=Tc(n),t=Sc(n),s=Math.max.apply(Math,t)/2;return{startPoint:[e[0]-s,e[1]-s],endPoint:[e[0]+s,e[1]+s],landmarks:n.landmarks}}var RT=[[1,0,0],[0,1,0],[0,0,1]];function IT(n,e){var t,s=Math.PI/2-Math.atan2(-(e[1]-n[1]),e[0]-n[0]);return(t=s)-2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function d3(n,e){return[[1,0,n],[0,1,e],[0,0,1]]}function Oi(n,e){for(var t=0,s=0;s<n.length;s++)t+=n[s]*e[s];return t}function NT(n,e){for(var t=[],s=0;s<n.length;s++)t.push(n[s][e]);return t}function p3(n,e){for(var t=[],s=n.length,r=0;r<s;r++){t.push([]);for(var i=0;i<s;i++)t[r].push(Oi(n[r],NT(e,i)))}return t}function f3(n,e){var t=Math.cos(n),s=Math.sin(n),r=[[t,-s,0],[s,t,0],[0,0,1]],i=p3(d3(e[0],e[1]),r);return p3(i,d3(-e[0],-e[1]))}var m3=[13,Sr.midwayBetweenEyes[0]],g3=[3,2],gd=Sr.leftEyeLower0,xd=[gd[0],gd[gd.length-1]],yd=Sr.rightEyeLower0,vd=[yd[0],yd[yd.length-1]],x3=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}];function Ec(n,e,t,s){for(var r=0;r<x3.length;r++){var i=x3[r],o=i.key,a=i.indices,l=Sr[""+t+o];if(s==null||s.includes(o))for(var c=0;c<a.length;c++){var u=a[c];n[l[c]]=[e[u][0],e[u][1],(e[u][2]+n[l[c]][2])/2]}}}var LT=function(){function n(e,t,s,r,i,o,a){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=e,this.meshDetector=t,this.irisModel=a,this.meshWidth=s,this.meshHeight=r,this.maxContinuousChecks=i,this.maxFaces=o}return n.prototype.transformRawCoords=function(e,t,s,r){var i,o,a,l,c=this,u=Sc({startPoint:t.startPoint,endPoint:t.endPoint}),h=[u[0]/this.meshWidth,u[1]/this.meshHeight],d=e.map(function(x){return[h[0]*(x[0]-c.meshWidth/2),h[1]*(x[1]-c.meshHeight/2),x[2]]}),p=f3(s,[0,0]),f=d.map(function(x){return function(b,w){return[Oi(b,w[0]),Oi(b,w[1])]}(x,p).concat([x[2]])}),m=(o=[[(i=r)[0][0],i[1][0]],[i[0][1],i[1][1]]],a=[i[0][2],i[1][2]],l=[-Oi(o[0],a),-Oi(o[1],a)],[o[0].concat(l[0]),o[1].concat(l[1]),[0,0,1]]),y=Tc({startPoint:t.startPoint,endPoint:t.endPoint}).concat([1]),g=[Oi(y,m[0]),Oi(y,m[1])];return f.map(function(x){return[x[0]+g[0],x[1]+g[1],x[2]]})},n.prototype.getLeftToRightEyeDepthDifference=function(e){return e[xd[0]][2]-e[vd[0]][2]},n.prototype.getEyeBox=function(e,t,s,r,i){i===void 0&&(i=!1);var o=md(fd(this.calculateLandmarksBoundingBox([e[s],e[r]]),2.3)),a=Sc(o),l=ys.cropAndResize(t,[[o.startPoint[1]/this.meshHeight,o.startPoint[0]/this.meshWidth,o.endPoint[1]/this.meshHeight,o.endPoint[0]/this.meshWidth]],[0],[64,64]);return i&&(l=ys.flipLeftRight(l)),{box:o,boxSize:a,crop:l}},n.prototype.getEyeCoords=function(e,t,s,r){r===void 0&&(r=!1);for(var i=[],o=0;o<76;o++){var a=e[3*o],l=e[3*o+1],c=e[3*o+2];i.push([(r?1-a/64:a/64)*s[0]+t.startPoint[0],l/64*s[1]+t.startPoint[1],c])}return{rawCoords:i,iris:i.slice(71)}},n.prototype.getAdjustedIrisCoords=function(e,t,s){var r=e[Sr[s+"EyeUpper0"][3]][2],i=e[Sr[s+"EyeLower0"][4]][2],o=(r+i)/2;return t.map(function(a,l){var c=o;return l===2?c=r:l===4&&(c=i),[a[0],a[1],c]})},n.prototype.predict=function(e,t){return wr(this,void 0,void 0,function(){var s,r,i,o,a=this;return _r(this,function(l){switch(l.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(e,!1,!0)]:[3,2];case 1:return s=l.sent(),r=s.boxes,i=s.scaleFactor,r.length===0?(this.regionsOfInterest=[],[2,null]):(o=r.map(function(c){var u,h,d={startPoint:Ds(c.box.startPoint).arraySync(),endPoint:Ds(c.box.endPoint).arraySync()},p=md(fd((h=i,{startPoint:[(u=d).startPoint[0]*h[0],u.startPoint[1]*h[1]],endPoint:[u.endPoint[0]*h[0],u.endPoint[1]*h[1]]})));return pd({},p,{landmarks:c.landmarks.arraySync()})}),r.forEach(function(c){c!=null&&c.startPoint!=null&&(c.startEndTensor.dispose(),c.startPoint.dispose(),c.endPoint.dispose())}),this.updateRegionsOfInterest(o),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,l.label=3;case 3:return[2,xt(function(){return a.regionsOfInterest.map(function(c,u){var h,d=c.landmarks.length>=468,p=m3[0],f=m3[1];d===!1&&(p=g3[0],f=g3[1]),h=IT(c.landmarks[p],c.landmarks[f]);var m=Tc({startPoint:c.startPoint,endPoint:c.endPoint}),y=[m[0]/e.shape[2],m[1]/e.shape[1]],g=e,x=RT;h!==0&&(g=ys.rotateWithOffset(e,h,0,y),x=f3(-h,m));var b={startPoint:c.startPoint,endPoint:c.endPoint},w=rn(function(he,ye,Re){var ve=ye.shape[1],We=ye.shape[2],Ue=[[he.startPoint[1]/ve,he.startPoint[0]/We,he.endPoint[1]/ve,he.endPoint[0]/We]];return ys.cropAndResize(ye,Ue,[0],Re,"bilinear",0)}(b,g,[a.meshHeight,a.meshWidth]),255),C=a.meshDetector.predict(w),M=C[1],E=C[2],A=de(E,[-1,3]).arraySync();if(t){var $=a.getEyeBox(A,w,xd[0],xd[1],!0),B=$.box,R=$.boxSize,K=$.crop,F=a.getEyeBox(A,w,vd[0],vd[1]),z=F.box,V=F.boxSize,H=F.crop,j=a.irisModel.predict(Sn([K,H])).dataSync(),ae=j.slice(0,228),fe=a.getEyeCoords(ae,B,R,!0),Q=fe.rawCoords,te=fe.iris,Te=j.slice(228),we=a.getEyeCoords(Te,z,V),Pe=we.rawCoords,it=we.iris,le=a.getLeftToRightEyeDepthDifference(A);Math.abs(le)<30?(Ec(A,Q,"left"),Ec(A,Pe,"right")):le<1?Ec(A,Q,"left",["EyeUpper0","EyeLower0"]):Ec(A,Pe,"right",["EyeUpper0","EyeLower0"]);var et=a.getAdjustedIrisCoords(A,te,"left"),Ge=a.getAdjustedIrisCoords(A,it,"right");A=A.concat(et).concat(Ge)}var Ae=a.transformRawCoords(A,c,h,x),Fe=jr(Ae),nt=fd(a.calculateLandmarksBoundingBox(Ae)),ne=md(nt);return a.regionsOfInterest[u]=pd({},ne,{landmarks:Fe.arraySync()}),{coords:jr(A,[A.length,3]),scaledCoords:Fe,box:nt,flag:Ds(M)}})})]}})})},n.prototype.updateRegionsOfInterest=function(e){for(var t=0;t<e.length;t++){var s=e[t],r=this.regionsOfInterest[t],i=0;if(r&&r.startPoint){var o=s.startPoint,a=o[0],l=o[1],c=s.endPoint,u=c[0],h=c[1],d=r.startPoint,p=d[0],f=d[1],m=r.endPoint,y=m[0],g=m[1],x=Math.max(a,p),b=Math.max(l,f),w=(Math.min(u,y)-x)*(Math.min(h,g)-b);i=w/((u-a)*(h-l)+(y-p)*(g-l)-w)}i<.25&&(this.regionsOfInterest[t]=s)}this.regionsOfInterest=this.regionsOfInterest.slice(0,e.length)},n.prototype.clearRegionOfInterest=function(e){this.regionsOfInterest[e]!=null&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,e).concat(this.regionsOfInterest.slice(e+1)))},n.prototype.shouldUpdateRegionsOfInterest=function(){var e=this.regionsOfInterest.length,t=e===0;return this.maxFaces===1||t?t:e!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},n.prototype.calculateLandmarksBoundingBox=function(e){var t=e.map(function(r){return r[0]}),s=e.map(function(r){return r[1]});return{startPoint:[Math.min.apply(Math,t),Math.min.apply(Math,s)],endPoint:[Math.max.apply(Math,t),Math.max.apply(Math,s)]}},n}(),PT=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function DT(n){return wr(this,void 0,void 0,function(){var e,t,s,r,i,o,a,l,c,u,h,d,p,f,m,y;return _r(this,function(g){switch(g.label){case 0:return e=n.maxContinuousChecks,t=e===void 0?5:e,s=n.detectionConfidence,r=s===void 0?.9:s,i=n.maxFaces,o=i===void 0?10:i,a=n.iouThreshold,l=a===void 0?.3:a,c=n.scoreThreshold,u=c===void 0?.75:c,h=n.shouldLoadIrisModel,d=h===void 0||h,p=n.modelUrl,f=n.detectorModelUrl,m=n.irisModelUrl,d?[4,Promise.all([y3(f,o,l,u),v3(p),kT(m)])]:[3,2];case 1:return y=g.sent(),[3,4];case 2:return[4,Promise.all([y3(f,o,l,u),v3(p)])];case 3:y=g.sent(),g.label=4;case 4:return[2,new $T(y[0],y[1],t,r,o,d?y[2]:null)]}})})}function y3(n,e,t,s){return wr(this,void 0,void 0,function(){return _r(this,function(r){return[2,AT({modelUrl:n,maxFaces:e,iouThreshold:t,scoreThreshold:s})]})})}function v3(n){return wr(this,void 0,void 0,function(){return _r(this,function(e){return n!=null?[2,Mo(n)]:[2,Mo("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]})})}function kT(n){return wr(this,void 0,void 0,function(){return _r(this,function(e){return n!=null?[2,Mo(n)]:[2,Mo("https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2",{fromTFHub:!0})]})})}function b3(n,e){if(n.mesh instanceof Zt){var t=xt(function(){var a=cn([e-1,0,0]),l=cn([1,-1,1]);return xt(function(){return[Sn([pt(e-1,dt(n.boundingBox.topLeft,0,1)),dt(n.boundingBox.topLeft,1,1)]),Sn([pt(e-1,dt(n.boundingBox.bottomRight,0,1)),dt(n.boundingBox.bottomRight,1,1)]),tt(pt(a,n.mesh),l),tt(pt(a,n.scaledMesh),l)]})}),s=t[0],r=t[1],i=t[2],o=t[3];return Object.assign({},n,{boundingBox:{topLeft:s,bottomRight:r},mesh:i,scaledMesh:o})}return Object.assign({},n,{boundingBox:{topLeft:[e-1-n.boundingBox.topLeft[0],n.boundingBox.topLeft[1]],bottomRight:[e-1-n.boundingBox.bottomRight[0],n.boundingBox.bottomRight[1]]},mesh:n.mesh.map(function(a){var l=a.slice(0);return l[0]=e-1-a[0],l}),scaledMesh:n.scaledMesh.map(function(a){var l=a.slice(0);return l[0]=e-1-a[0],l})})}var nl,$T=function(){function n(e,t,s,r,i,o){this.kind="MediaPipeFaceMesh",this.pipeline=new LT(e,t,192,192,s,i,o),this.detectionConfidence=r}return n.getAnnotations=function(){return Sr},n.getUVCoords=function(){return PT},n.prototype.estimateFaces=function(e){return wr(this,void 0,void 0,function(){var t,s,r,i,o,a,l,c,u,h,d,p,f=this;return _r(this,function(m){switch(m.label){case 0:if(t=e.returnTensors,s=t!==void 0&&t,r=e.flipHorizontal,i=r!==void 0&&r,o=e.predictIrises,a=o===void 0||o,l=e.input,a&&this.pipeline.irisModel==null)throw new Error("The iris model was not loaded as part of facemesh. Please initialize the model with facemesh.load({shouldLoadIrisModel: true}).");return c=function(y){return y instanceof Zt?[y.shape[0],y.shape[1]]:[y.height,y.width]}(l),u=c[1],h=xt(function(){return l instanceof Zt||(l=l2(l)),yr(Xt(l,"float32"),0)}),mv()!=="webgl"?[3,2]:(p=ee().get("WEBGL_PACK_DEPTHWISECONV"),ee().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(h,a)]);case 1:return d=m.sent(),ee().set("WEBGL_PACK_DEPTHWISECONV",p),[3,4];case 2:return[4,this.pipeline.predict(h,a)];case 3:d=m.sent(),m.label=4;case 4:return h.dispose(),d!=null&&d.length>0?[2,Promise.all(d.map(function(y,g){return wr(f,void 0,void 0,function(){var x,b,w,C,M,E,A,$,B,R,K,F,z,V,H=this;return _r(this,function(j){switch(j.label){case 0:return x=y.coords,b=y.scaledCoords,w=y.box,C=y.flag,M=[C],s||(M=M.concat([x,b])),[4,Promise.all(M.map(function(ae){return wr(H,void 0,void 0,function(){return _r(this,function(fe){return[2,ae.array()]})})}))];case 1:if(E=j.sent(),A=E[0],C.dispose(),A<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(g),s)return $={kind:"MediaPipePredictionTensors",faceInViewConfidence:A,mesh:x,scaledMesh:b,boundingBox:{topLeft:cn(w.startPoint),bottomRight:cn(w.endPoint)}},i?[2,b3($,u)]:[2,$];for(V in B=E.slice(1),R=B[0],K=B[1],b.dispose(),x.dispose(),F={kind:"MediaPipePredictionValues",faceInViewConfidence:A,boundingBox:{topLeft:w.startPoint,bottomRight:w.endPoint},mesh:R,scaledMesh:K},i&&(F=b3(F,u)),z={},Sr)(a||V.includes("Iris")===!1)&&(z[V]=Sr[V].map(function(ae){return F.scaledMesh[ae]}));return F.annotations=z,[2,F]}})})}))]:[2,[]]}})})},n}();function FT(n,e){return n===void 0&&(n=nl.mediapipeFacemesh),e===void 0&&(e={}),wr(this,void 0,void 0,function(){return _r(this,function(t){if(n===nl.mediapipeFacemesh)return[2,DT(e)];throw new Error(n+" is not a valid package name.")})})}(function(n){n.mediapipeFacemesh="mediapipe-facemesh"})(nl||(nl={}));(function(){var n;function e(v){var _=0;return function(){return _<v.length?{done:!1,value:v[_++]}:{done:!0}}}var t=typeof Object.defineProperties=="function"?Object.defineProperty:function(v,_,T){return v==Array.prototype||v==Object.prototype||(v[_]=T.value),v};function s(v){v=[typeof globalThis=="object"&&globalThis,v,typeof window=="object"&&window,typeof self=="object"&&self,typeof gr=="object"&&gr];for(var _=0;_<v.length;++_){var T=v[_];if(T&&T.Math==Math)return T}throw Error("Cannot find global object")}var r=s(this);function i(v,_){if(_)e:{var T=r;v=v.split(".");for(var D=0;D<v.length-1;D++){var X=v[D];if(!(X in T))break e;T=T[X]}v=v[v.length-1],D=T[v],_=_(D),_!=D&&_!=null&&t(T,v,{configurable:!0,writable:!0,value:_})}}i("Symbol",function(v){function _(se){if(this instanceof _)throw new TypeError("Symbol is not a constructor");return new T(D+(se||"")+"_"+X++,se)}function T(se,q){this.g=se,t(this,"description",{configurable:!0,writable:!0,value:q})}if(v)return v;T.prototype.toString=function(){return this.g};var D="jscomp_symbol_"+(1e9*Math.random()>>>0)+"_",X=0;return _}),i("Symbol.iterator",function(v){if(v)return v;v=Symbol("Symbol.iterator");for(var _="Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "),T=0;T<_.length;T++){var D=r[_[T]];typeof D=="function"&&typeof D.prototype[v]!="function"&&t(D.prototype,v,{configurable:!0,writable:!0,value:function(){return o(e(this))}})}return v});function o(v){return v={next:v},v[Symbol.iterator]=function(){return this},v}function a(v){var _=typeof Symbol!="undefined"&&Symbol.iterator&&v[Symbol.iterator];return _?_.call(v):{next:e(v)}}function l(v){if(!(v instanceof Array)){v=a(v);for(var _,T=[];!(_=v.next()).done;)T.push(_.value);v=T}return v}var c=typeof Object.create=="function"?Object.create:function(v){function _(){}return _.prototype=v,new _},u;if(typeof Object.setPrototypeOf=="function")u=Object.setPrototypeOf;else{var h;e:{var d={a:!0},p={};try{p.__proto__=d,h=p.a;break e}catch{}h=!1}u=h?function(v,_){if(v.__proto__=_,v.__proto__!==_)throw new TypeError(v+" is not extensible");return v}:null}var f=u;function m(v,_){if(v.prototype=c(_.prototype),v.prototype.constructor=v,f)f(v,_);else for(var T in _)if(T!="prototype")if(Object.defineProperties){var D=Object.getOwnPropertyDescriptor(_,T);D&&Object.defineProperty(v,T,D)}else v[T]=_[T];v.ea=_.prototype}function y(){this.l=!1,this.i=null,this.h=void 0,this.g=1,this.s=this.m=0,this.j=null}function g(v){if(v.l)throw new TypeError("Generator is already running");v.l=!0}y.prototype.o=function(v){this.h=v};function x(v,_){v.j={U:_,V:!0},v.g=v.m||v.s}y.prototype.return=function(v){this.j={return:v},this.g=this.s};function b(v,_,T){return v.g=T,{value:_}}function w(v){this.g=new y,this.h=v}function C(v,_){g(v.g);var T=v.g.i;return T?M(v,"return"in T?T.return:function(D){return{value:D,done:!0}},_,v.g.return):(v.g.return(_),E(v))}function M(v,_,T,D){try{var X=_.call(v.g.i,T);if(!(X instanceof Object))throw new TypeError("Iterator result "+X+" is not an object");if(!X.done)return v.g.l=!1,X;var se=X.value}catch(q){return v.g.i=null,x(v.g,q),E(v)}return v.g.i=null,D.call(v.g,se),E(v)}function E(v){for(;v.g.g;)try{var _=v.h(v.g);if(_)return v.g.l=!1,{value:_.value,done:!1}}catch(T){v.g.h=void 0,x(v.g,T)}if(v.g.l=!1,v.g.j){if(_=v.g.j,v.g.j=null,_.V)throw _.U;return{value:_.return,done:!0}}return{value:void 0,done:!0}}function A(v){this.next=function(_){return g(v.g),v.g.i?_=M(v,v.g.i.next,_,v.g.o):(v.g.o(_),_=E(v)),_},this.throw=function(_){return g(v.g),v.g.i?_=M(v,v.g.i.throw,_,v.g.o):(x(v.g,_),_=E(v)),_},this.return=function(_){return C(v,_)},this[Symbol.iterator]=function(){return this}}function $(v,_){return _=new A(new w(_)),f&&v.prototype&&f(_,v.prototype),_}function B(v,_){v instanceof String&&(v+="");var T=0,D=!1,X={next:function(){if(!D&&T<v.length){var se=T++;return{value:_(se,v[se]),done:!1}}return D=!0,{done:!0,value:void 0}}};return X[Symbol.iterator]=function(){return X},X}var R=typeof Object.assign=="function"?Object.assign:function(v,_){for(var T=1;T<arguments.length;T++){var D=arguments[T];if(D)for(var X in D)Object.prototype.hasOwnProperty.call(D,X)&&(v[X]=D[X])}return v};i("Object.assign",function(v){return v||R}),i("Promise",function(v){function _(q){this.h=0,this.i=void 0,this.g=[],this.o=!1;var re=this.j();try{q(re.resolve,re.reject)}catch(ge){re.reject(ge)}}function T(){this.g=null}function D(q){return q instanceof _?q:new _(function(re){re(q)})}if(v)return v;T.prototype.h=function(q){if(this.g==null){this.g=[];var re=this;this.i(function(){re.l()})}this.g.push(q)};var X=r.setTimeout;T.prototype.i=function(q){X(q,0)},T.prototype.l=function(){for(;this.g&&this.g.length;){var q=this.g;this.g=[];for(var re=0;re<q.length;++re){var ge=q[re];q[re]=null;try{ge()}catch(Ne){this.j(Ne)}}}this.g=null},T.prototype.j=function(q){this.i(function(){throw q})},_.prototype.j=function(){function q(Ne){return function(Je){ge||(ge=!0,Ne.call(re,Je))}}var re=this,ge=!1;return{resolve:q(this.C),reject:q(this.l)}},_.prototype.C=function(q){if(q===this)this.l(new TypeError("A Promise cannot resolve to itself"));else if(q instanceof _)this.F(q);else{e:switch(typeof q){case"object":var re=q!=null;break e;case"function":re=!0;break e;default:re=!1}re?this.u(q):this.m(q)}},_.prototype.u=function(q){var re=void 0;try{re=q.then}catch(ge){this.l(ge);return}typeof re=="function"?this.G(re,q):this.m(q)},_.prototype.l=function(q){this.s(2,q)},_.prototype.m=function(q){this.s(1,q)},_.prototype.s=function(q,re){if(this.h!=0)throw Error("Cannot settle("+q+", "+re+"): Promise already settled in state"+this.h);this.h=q,this.i=re,this.h===2&&this.D(),this.A()},_.prototype.D=function(){var q=this;X(function(){if(q.B()){var re=r.console;typeof re!="undefined"&&re.error(q.i)}},1)},_.prototype.B=function(){if(this.o)return!1;var q=r.CustomEvent,re=r.Event,ge=r.dispatchEvent;return typeof ge=="undefined"?!0:(typeof q=="function"?q=new q("unhandledrejection",{cancelable:!0}):typeof re=="function"?q=new re("unhandledrejection",{cancelable:!0}):(q=r.document.createEvent("CustomEvent"),q.initCustomEvent("unhandledrejection",!1,!0,q)),q.promise=this,q.reason=this.i,ge(q))},_.prototype.A=function(){if(this.g!=null){for(var q=0;q<this.g.length;++q)se.h(this.g[q]);this.g=null}};var se=new T;return _.prototype.F=function(q){var re=this.j();q.J(re.resolve,re.reject)},_.prototype.G=function(q,re){var ge=this.j();try{q.call(re,ge.resolve,ge.reject)}catch(Ne){ge.reject(Ne)}},_.prototype.then=function(q,re){function ge(ut,rt){return typeof ut=="function"?function(Be){try{Ne(ut(Be))}catch(Qe){Je(Qe)}}:rt}var Ne,Je,It=new _(function(ut,rt){Ne=ut,Je=rt});return this.J(ge(q,Ne),ge(re,Je)),It},_.prototype.catch=function(q){return this.then(void 0,q)},_.prototype.J=function(q,re){function ge(){switch(Ne.h){case 1:q(Ne.i);break;case 2:re(Ne.i);break;default:throw Error("Unexpected state: "+Ne.h)}}var Ne=this;this.g==null?se.h(ge):this.g.push(ge),this.o=!0},_.resolve=D,_.reject=function(q){return new _(function(re,ge){ge(q)})},_.race=function(q){return new _(function(re,ge){for(var Ne=a(q),Je=Ne.next();!Je.done;Je=Ne.next())D(Je.value).J(re,ge)})},_.all=function(q){var re=a(q),ge=re.next();return ge.done?D([]):new _(function(Ne,Je){function It(Be){return function(Qe){ut[Be]=Qe,rt--,rt==0&&Ne(ut)}}var ut=[],rt=0;do ut.push(void 0),rt++,D(ge.value).J(It(ut.length-1),Je),ge=re.next();while(!ge.done)})},_}),i("Object.is",function(v){return v||function(_,T){return _===T?_!==0||1/_==1/T:_!==_&&T!==T}}),i("Array.prototype.includes",function(v){return v||function(_,T){var D=this;D instanceof String&&(D=String(D));var X=D.length;for(T=T||0,0>T&&(T=Math.max(T+X,0));T<X;T++){var se=D[T];if(se===_||Object.is(se,_))return!0}return!1}}),i("String.prototype.includes",function(v){return v||function(_,T){if(this==null)throw new TypeError("The 'this' value for String.prototype.includes must not be null or undefined");if(_ instanceof RegExp)throw new TypeError("First argument to String.prototype.includes must not be a regular expression");return this.indexOf(_,T||0)!==-1}}),i("Array.prototype.keys",function(v){return v||function(){return B(this,function(_){return _})}});var K=this||self;function F(v,_){v=v.split(".");var T=K;v[0]in T||typeof T.execScript=="undefined"||T.execScript("var "+v[0]);for(var D;v.length&&(D=v.shift());)v.length||_===void 0?T[D]&&T[D]!==Object.prototype[D]?T=T[D]:T=T[D]={}:T[D]=_}function z(v,_){return _=String.fromCharCode.apply(null,_),v==null?_:v+_}var V,H=typeof TextDecoder!="undefined",j,ae=typeof TextEncoder!="undefined";function fe(v){if(ae)v=(j||(j=new TextEncoder)).encode(v);else{var _=void 0;_=_===void 0?!1:_;for(var T=0,D=new Uint8Array(3*v.length),X=0;X<v.length;X++){var se=v.charCodeAt(X);if(128>se)D[T++]=se;else{if(2048>se)D[T++]=se>>6|192;else{if(55296<=se&&57343>=se){if(56319>=se&&X<v.length){var q=v.charCodeAt(++X);if(56320<=q&&57343>=q){se=1024*(se-55296)+q-56320+65536,D[T++]=se>>18|240,D[T++]=se>>12&63|128,D[T++]=se>>6&63|128,D[T++]=se&63|128;continue}else X--}if(_)throw Error("Found an unpaired surrogate");se=65533}D[T++]=se>>12|224,D[T++]=se>>6&63|128}D[T++]=se&63|128}}v=D.subarray(0,T)}return v}var Q={},te=null;function Te(v,_){_===void 0&&(_=0),it(),_=Q[_];for(var T=Array(Math.floor(v.length/3)),D=_[64]||"",X=0,se=0;X<v.length-2;X+=3){var q=v[X],re=v[X+1],ge=v[X+2],Ne=_[q>>2];q=_[(q&3)<<4|re>>4],re=_[(re&15)<<2|ge>>6],ge=_[ge&63],T[se++]=Ne+q+re+ge}switch(Ne=0,ge=D,v.length-X){case 2:Ne=v[X+1],ge=_[(Ne&15)<<2]||D;case 1:v=v[X],T[se]=_[v>>2]+_[(v&3)<<4|Ne>>4]+ge+D}return T.join("")}function we(v){var _=v.length,T=3*_/4;T%3?T=Math.floor(T):"=.".indexOf(v[_-1])!=-1&&(T="=.".indexOf(v[_-2])!=-1?T-2:T-1);var D=new Uint8Array(T),X=0;return Pe(v,function(se){D[X++]=se}),D.subarray(0,X)}function Pe(v,_){function T(ge){for(;D<v.length;){var Ne=v.charAt(D++),Je=te[Ne];if(Je!=null)return Je;if(!/^[\s\xa0]*$/.test(Ne))throw Error("Unknown base64 encoding at char: "+Ne)}return ge}it();for(var D=0;;){var X=T(-1),se=T(0),q=T(64),re=T(64);if(re===64&&X===-1)break;_(X<<2|se>>4),q!=64&&(_(se<<4&240|q>>2),re!=64&&_(q<<6&192|re))}}function it(){if(!te){te={};for(var v="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""),_=["+/=","+/","-_=","-_.","-_"],T=0;5>T;T++){var D=v.concat(_[T].split(""));Q[T]=D;for(var X=0;X<D.length;X++){var se=D[X];te[se]===void 0&&(te[se]=X)}}}}var le=typeof Uint8Array.prototype.slice=="function",et;function Ge(v,_,T){return _===T?et||(et=new Uint8Array(0)):le?v.slice(_,T):new Uint8Array(v.subarray(_,T))}var Ae=0,Fe=0;function nt(v,_){_=_===void 0?{}:_,_=_.v===void 0?!1:_.v,this.h=null,this.g=this.j=this.l=0,this.m=!1,this.v=_,v&&ne(this,v)}function ne(v,_){_=_.constructor===Uint8Array?_:_.constructor===ArrayBuffer?new Uint8Array(_):_.constructor===Array?new Uint8Array(_):_.constructor===String?we(_):_ instanceof Uint8Array?new Uint8Array(_.buffer,_.byteOffset,_.byteLength):new Uint8Array(0),v.h=_,v.l=0,v.j=v.h.length,v.g=v.l}nt.prototype.reset=function(){this.g=this.l};function he(v){for(var _=128,T=0,D=0,X=0;4>X&&128<=_;X++)_=v.h[v.g++],T|=(_&127)<<7*X;if(128<=_&&(_=v.h[v.g++],T|=(_&127)<<28,D|=(_&127)>>4),128<=_)for(X=0;5>X&&128<=_;X++)_=v.h[v.g++],D|=(_&127)<<7*X+3;if(128>_)return v=T>>>0,_=D>>>0,(D=_&2147483648)&&(v=~v+1>>>0,_=~_>>>0,v==0&&(_=_+1>>>0)),v=4294967296*_+(v>>>0),D?-v:v;v.m=!0}nt.prototype.i=function(){var v=this.h,_=v[this.g],T=_&127;return 128>_?(this.g+=1,T):(_=v[this.g+1],T|=(_&127)<<7,128>_?(this.g+=2,T):(_=v[this.g+2],T|=(_&127)<<14,128>_?(this.g+=3,T):(_=v[this.g+3],T|=(_&127)<<21,128>_?(this.g+=4,T):(_=v[this.g+4],T|=(_&15)<<28,128>_?(this.g+=5,T>>>0):(this.g+=5,128<=v[this.g++]&&128<=v[this.g++]&&128<=v[this.g++]&&128<=v[this.g++]&&this.g++,T)))))},nt.prototype.o=function(){var v=this.h[this.g],_=this.h[this.g+1],T=this.h[this.g+2],D=this.h[this.g+3];return this.g+=4,T=(v<<0|_<<8|T<<16|D<<24)>>>0,v=2*(T>>31)+1,_=T>>>23&255,T&=8388607,_==255?T?NaN:1/0*v:_==0?v*Math.pow(2,-149)*T:v*Math.pow(2,_-150)*(T+Math.pow(2,23))};var ye=[];function Re(){this.g=new Uint8Array(64),this.h=0}Re.prototype.push=function(v){if(!(this.h+1<this.g.length)){var _=this.g;this.g=new Uint8Array(Math.ceil(1+2*this.g.length)),this.g.set(_)}this.g[this.h++]=v},Re.prototype.length=function(){return this.h},Re.prototype.end=function(){var v=this.g,_=this.h;return this.h=0,Ge(v,0,_)};function ve(v,_){for(;127<_;)v.push(_&127|128),_>>>=7;v.push(_)}function We(v){var _={},T=_.N===void 0?!1:_.N;this.o={v:_.v===void 0?!1:_.v},this.N=T,_=this.o,ye.length?(T=ye.pop(),_&&(T.v=_.v),v&&ne(T,v),v=T):v=new nt(v,_),this.g=v,this.m=this.g.g,this.h=this.i=this.l=-1,this.j=!1}We.prototype.reset=function(){this.g.reset(),this.h=this.l=-1};function Ue(v){var _=v.g;if((_=_.g==_.j)||(_=v.j)||(_=v.g,_=_.m||0>_.g||_.g>_.j),_)return!1;v.m=v.g.g,_=v.g.i();var T=_&7;return T!=0&&T!=5&&T!=1&&T!=2&&T!=3&&T!=4?(v.j=!0,!1):(v.i=_,v.l=_>>>3,v.h=T,!0)}function st(v){switch(v.h){case 0:if(v.h!=0)st(v);else{for(v=v.g;v.h[v.g]&128;)v.g++;v.g++}break;case 1:v.h!=1?st(v):(v=v.g,v.g+=8);break;case 2:if(v.h!=2)st(v);else{var _=v.g.i();v=v.g,v.g+=_}break;case 5:v.h!=5?st(v):(v=v.g,v.g+=4);break;case 3:_=v.l;do{if(!Ue(v)){v.j=!0;break}if(v.h==4){v.l!=_&&(v.j=!0);break}st(v)}while(1);break;default:v.j=!0}}function At(v,_,T){var D=v.g.j,X=v.g.i(),se=v.g.g+X;if(v.g.j=se,T(_,v),T=se-v.g.g,T!==0)throw Error("Message parsing ended unexpectedly. Expected to read "+X+" bytes, instead read "+(X-T)+" bytes, either the data ended unexpectedly or the message misreported its own length");return v.g.g=se,v.g.j=D,_}function k(v){return v.g.o()}function N(v){var _=v.g.i();v=v.g;var T=v.g;v.g+=_,v=v.h;var D;if(H)(D=V)||(D=V=new TextDecoder("utf-8",{fatal:!1})),D=D.decode(v.subarray(T,T+_));else{_=T+_;for(var X=[],se=null,q,re,ge;T<_;)q=v[T++],128>q?X.push(q):224>q?T>=_?X.push(65533):(re=v[T++],194>q||(re&192)!=128?(T--,X.push(65533)):X.push((q&31)<<6|re&63)):240>q?T>=_-1?X.push(65533):(re=v[T++],(re&192)!=128||q===224&&160>re||q===237&&160<=re||((D=v[T++])&192)!=128?(T--,X.push(65533)):X.push((q&15)<<12|(re&63)<<6|D&63)):244>=q?T>=_-2?X.push(65533):(re=v[T++],(re&192)!=128||(q<<28)+(re-144)>>30!=0||((D=v[T++])&192)!=128||((ge=v[T++])&192)!=128?(T--,X.push(65533)):(q=(q&7)<<18|(re&63)<<12|(D&63)<<6|ge&63,q-=65536,X.push((q>>10&1023)+55296,(q&1023)+56320))):X.push(65533),8192<=X.length&&(se=z(se,X),X.length=0);D=z(se,X)}return D}function ce(v,_,T){var D=v.g.i();for(D=v.g.g+D;v.g.g<D;)T.push(_.call(v.g))}function oe(v,_){v.h==2?ce(v,nt.prototype.o,_):_.push(k(v))}function ke(){this.h=[],this.i=0,this.g=new Re}function Ie(v,_){_.length!==0&&(v.h.push(_),v.i+=_.length)}function U(v){var _=v.i+v.g.length();if(_===0)return new Uint8Array(0);_=new Uint8Array(_);for(var T=v.h,D=T.length,X=0,se=0;se<D;se++){var q=T[se];q.length!==0&&(_.set(q,X),X+=q.length)}return T=v.g,D=T.h,D!==0&&(_.set(T.g.subarray(0,D),X),T.h=0),v.h=[_],_}function me(v,_,T){if(T!=null){ve(v.g,8*_+5),v=v.g;var D=T;D=(T=0>D?1:0)?-D:D,D===0?0<1/D?Ae=Fe=0:(Fe=0,Ae=2147483648):isNaN(D)?(Fe=0,Ae=2147483647):34028234663852886e22<D?(Fe=0,Ae=(T<<31|2139095040)>>>0):11754943508222875e-54>D?(D=Math.round(D/Math.pow(2,-149)),Fe=0,Ae=(T<<31|D)>>>0):(_=Math.floor(Math.log(D)/Math.LN2),D*=Math.pow(2,-_),D=Math.round(8388608*D),16777216<=D&&++_,Fe=0,Ae=(T<<31|_+127<<23|D&8388607)>>>0),T=Ae,v.push(T>>>0&255),v.push(T>>>8&255),v.push(T>>>16&255),v.push(T>>>24&255)}}var ue=typeof Uint8Array=="function";function Ee(v,_,T){if(v!=null)return typeof v=="object"?ue&&v instanceof Uint8Array?T(v):_e(v,_,T):_(v)}function _e(v,_,T){if(Array.isArray(v)){for(var D=Array(v.length),X=0;X<v.length;X++)D[X]=Ee(v[X],_,T);return Array.isArray(v)&&v.W&&qe(D),D}D={};for(X in v)D[X]=Ee(v[X],_,T);return D}function $e(v){return typeof v=="number"?isFinite(v)?v:String(v):v}var Oe={W:{value:!0,configurable:!0}};function qe(v){return Array.isArray(v)&&!Object.isFrozen(v)&&Object.defineProperties(v,Oe),v}var Ht;function Xe(v,_,T){var D=Ht;Ht=null,v||(v=D),D=this.constructor.ca,v||(v=D?[D]:[]),this.j=D?0:-1,this.m=this.g=null,this.h=v;e:{if(D=this.h.length,v=D-1,D&&(D=this.h[v],!(D===null||typeof D!="object"||Array.isArray(D)||ue&&D instanceof Uint8Array))){this.l=v-this.j,this.i=D;break e}_!==void 0&&-1<_?(this.l=Math.max(_,v+1-this.j),this.i=null):this.l=Number.MAX_VALUE}if(T)for(_=0;_<T.length;_++)v=T[_],v<this.l?(v+=this.j,(D=this.h[v])?qe(D):this.h[v]=Cn):(Hn(this),(D=this.i[v])?qe(D):this.i[v]=Cn)}var Cn=Object.freeze(qe([]));function Hn(v){var _=v.l+v.j;v.h[_]||(v.i=v.h[_]={})}function Ft(v,_,T){return _===-1?null:(T===void 0?0:T)||_>=v.l?v.i?v.i[_]:void 0:v.h[_+v.j]}function yi(v,_){var T=T===void 0?!1:T,D=Ft(v,_,T);return D==null&&(D=Cn),D===Cn&&(D=qe([]),lt(v,_,D,T)),D}function Pa(v){var _=yi(v,3);if(v.m||(v.m={}),!v.m[3]){for(var T=0;T<_.length;T++)_[T]=+_[T];v.m[3]=!0}return _}function Fn(v,_,T){return v=Ft(v,_),v==null?T:v}function es(v,_,T){return v=Ft(v,_),v=v==null?v:+v,v==null?T===void 0?0:T:v}function lt(v,_,T,D){(D===void 0?0:D)||_>=v.l?(Hn(v),v.i[_]=T):v.h[_+v.j]=T}function Kl(v,_,T){if(T===-1)return null;if(v.g||(v.g={}),!v.g[T]){var D=Ft(v,T,!1);D&&(v.g[T]=new _(D))}return v.g[T]}function dr(v,_){v.g||(v.g={});var T=v.g[1];if(!T){var D=yi(v,1);T=[];for(var X=0;X<D.length;X++)T[X]=new _(D[X]);v.g[1]=T}return T}function Yl(v,_,T){var D=D===void 0?!1:D;v.g||(v.g={});var X=T&&Bs(T);v.g[_]=T,lt(v,_,X,D)}function ao(v,_,T,D){var X=dr(v,T);_=_||new T,v=yi(v,1),D!=null?(X.splice(D,0,_),v.splice(D,0,Bs(_))):(X.push(_),v.push(Bs(_)))}Xe.prototype.toJSON=function(){var v=Bs(this);return _e(v,$e,Te)};function Bs(v,_){if(v.g)for(var T in v.g){var D=v.g[T];if(Array.isArray(D))for(var X=0;X<D.length;X++)D[X]&&Bs(D[X]);else D&&Bs(D)}return v.h}Xe.prototype.toString=function(){return Bs(this).toString()};function Da(v,_){if(v=v.o){Ie(_,_.g.end());for(var T=0;T<v.length;T++)Ie(_,v[T])}}function zs(v,_){if(_.h==4)return!1;var T=_.m;return st(_),_.N||(_=Ge(_.g.h,T,_.g.g),(T=v.o)?T.push(_):v.o=[_]),!0}function pr(v){Xe.call(this,v,-1,Y)}m(pr,Xe),pr.prototype.getRows=function(){return Ft(this,1)},pr.prototype.getCols=function(){return Ft(this,2)},pr.prototype.getPackedDataList=function(){return Pa(this)},pr.prototype.getLayout=function(){return Fn(this,4,0)};function I(v,_){for(;Ue(_);)switch(_.i){case 8:var T=_.g.i();lt(v,1,T);break;case 16:T=_.g.i(),lt(v,2,T);break;case 29:case 26:oe(_,v.getPackedDataList());break;case 32:T=he(_.g),lt(v,4,T);break;default:if(!zs(v,_))return v}return v}var Y=[3];function Z(v,_){var T=void 0;return new(T||(T=Promise))(function(D,X){function se(ge){try{re(_.next(ge))}catch(Ne){X(Ne)}}function q(ge){try{re(_.throw(ge))}catch(Ne){X(Ne)}}function re(ge){ge.done?D(ge.value):new T(function(Ne){Ne(ge.value)}).then(se,q)}re((_=_.apply(v,void 0)).next())})}function J(v){Xe.call(this,v)}m(J,Xe);function ie(v,_){for(;Ue(_);)switch(_.i){case 8:var T=_.g.i();lt(v,1,T);break;case 21:T=k(_),lt(v,2,T);break;case 26:T=N(_),lt(v,3,T);break;case 34:T=N(_),lt(v,4,T);break;default:if(!zs(v,_))return v}return v}function je(v){Xe.call(this,v,-1,He)}m(je,Xe),je.prototype.addClassification=function(v,_){return ao(this,v,J,_),this};var He=[1];function Ze(v){Xe.call(this,v)}m(Ze,Xe);function Ke(v,_){for(;Ue(_);)switch(_.i){case 13:var T=k(_);lt(v,1,T);break;case 21:T=k(_),lt(v,2,T);break;case 29:T=k(_),lt(v,3,T);break;case 37:T=k(_),lt(v,4,T);break;case 45:T=k(_),lt(v,5,T);break;default:if(!zs(v,_))return v}return v}function mt(v){Xe.call(this,v,-1,gt)}m(mt,Xe);function ot(v){e:{var _=new mt;for(v=new We(v);Ue(v);)switch(v.i){case 10:var T=At(v,new Ze,Ke);ao(_,T,Ze,void 0);break;default:if(!zs(_,v))break e}}return _}var gt=[1];function Ot(v){Xe.call(this,v)}m(Ot,Xe);function On(v){Xe.call(this,v,-1,vi)}m(On,Xe),On.prototype.getVertexType=function(){return Fn(this,1,0)},On.prototype.getPrimitiveType=function(){return Fn(this,2,0)},On.prototype.getVertexBufferList=function(){return Pa(this)},On.prototype.getIndexBufferList=function(){return yi(this,4)};function St(v,_){for(;Ue(_);)switch(_.i){case 8:var T=he(_.g);lt(v,1,T);break;case 16:T=he(_.g),lt(v,2,T);break;case 29:case 26:oe(_,v.getVertexBufferList());break;case 32:case 34:T=_;var D=v.getIndexBufferList();T.h==2?ce(T,nt.prototype.i,D):D.push(T.g.i());break;default:if(!zs(v,_))return v}return v}var vi=[3,4];function Rt(v){Xe.call(this,v)}m(Rt,Xe),Rt.prototype.getMesh=function(){return Kl(this,On,1)},Rt.prototype.getPoseTransformMatrix=function(){return Kl(this,pr,2)};function fr(v){e:{var _=new Rt;for(v=new We(v);Ue(v);)switch(v.i){case 10:var T=At(v,new On,St);Yl(_,1,T);break;case 18:T=At(v,new pr,I),Yl(_,2,T);break;default:if(!zs(_,v))break e}}return _}function Us(v,_,T){if(T=v.createShader(T===0?v.VERTEX_SHADER:v.FRAGMENT_SHADER),v.shaderSource(T,_),v.compileShader(T),!v.getShaderParameter(T,v.COMPILE_STATUS))throw Error(`Could not compile WebGL shader.

`+v.getShaderInfoLog(T));return T}function mr(v){return dr(v,J).map(function(_){return{index:Fn(_,1,0),Y:es(_,2),label:Ft(_,3)!=null?Fn(_,3,""):void 0,displayName:Ft(_,4)!=null?Fn(_,4,""):void 0}})}function Ms(v){return{x:es(v,1),y:es(v,2),z:es(v,3),visibility:Ft(v,4)!=null?es(v,4):void 0}}function Bt(v,_){this.h=v,this.g=_,this.l=0}function Fr(v,_,T){return ts(v,_),typeof v.g.canvas.transferToImageBitmap=="function"?Promise.resolve(v.g.canvas.transferToImageBitmap()):T?Promise.resolve(v.g.canvas):typeof createImageBitmap=="function"?createImageBitmap(v.g.canvas):(v.i===void 0&&(v.i=document.createElement("canvas")),new Promise(function(D){v.i.height=v.g.canvas.height,v.i.width=v.g.canvas.width,v.i.getContext("2d",{}).drawImage(v.g.canvas,0,0,v.g.canvas.width,v.g.canvas.height),D(v.i)}))}function ts(v,_){var T=v.g;if(v.m===void 0){var D=Us(T,`
  attribute vec2 aVertex;
  attribute vec2 aTex;
  varying vec2 vTex;
  void main(void) {
    gl_Position = vec4(aVertex, 0.0, 1.0);
    vTex = aTex;
  }`,0),X=Us(T,`
  precision mediump float;
  varying vec2 vTex;
  uniform sampler2D sampler0;
  void main(){
    gl_FragColor = texture2D(sampler0, vTex);
  }`,1),se=T.createProgram();if(T.attachShader(se,D),T.attachShader(se,X),T.linkProgram(se),!T.getProgramParameter(se,T.LINK_STATUS))throw Error(`Could not compile WebGL program.

`+T.getProgramInfoLog(se));D=v.m=se,T.useProgram(D),X=T.getUniformLocation(D,"sampler0"),v.j={I:T.getAttribLocation(D,"aVertex"),H:T.getAttribLocation(D,"aTex"),da:X},v.s=T.createBuffer(),T.bindBuffer(T.ARRAY_BUFFER,v.s),T.enableVertexAttribArray(v.j.I),T.vertexAttribPointer(v.j.I,2,T.FLOAT,!1,0,0),T.bufferData(T.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,1,1,-1]),T.STATIC_DRAW),T.bindBuffer(T.ARRAY_BUFFER,null),v.o=T.createBuffer(),T.bindBuffer(T.ARRAY_BUFFER,v.o),T.enableVertexAttribArray(v.j.H),T.vertexAttribPointer(v.j.H,2,T.FLOAT,!1,0,0),T.bufferData(T.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),T.STATIC_DRAW),T.bindBuffer(T.ARRAY_BUFFER,null),T.uniform1i(X,0)}D=v.j,T.useProgram(v.m),T.canvas.width=_.width,T.canvas.height=_.height,T.viewport(0,0,_.width,_.height),T.activeTexture(T.TEXTURE0),v.h.bindTexture2d(_.glName),T.enableVertexAttribArray(D.I),T.bindBuffer(T.ARRAY_BUFFER,v.s),T.vertexAttribPointer(D.I,2,T.FLOAT,!1,0,0),T.enableVertexAttribArray(D.H),T.bindBuffer(T.ARRAY_BUFFER,v.o),T.vertexAttribPointer(D.H,2,T.FLOAT,!1,0,0),T.bindFramebuffer(T.DRAW_FRAMEBUFFER?T.DRAW_FRAMEBUFFER:T.FRAMEBUFFER,null),T.clearColor(0,0,0,0),T.clear(T.COLOR_BUFFER_BIT),T.colorMask(!0,!0,!0,!0),T.drawArrays(T.TRIANGLE_FAN,0,4),T.disableVertexAttribArray(D.I),T.disableVertexAttribArray(D.H),T.bindBuffer(T.ARRAY_BUFFER,null),v.h.bindTexture2d(0)}function D5(v){this.g=v}var k5=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,9,1,7,0,65,0,253,15,26,11]);function $5(v,_){return _+v}function pf(v,_){window[v]=_}function F5(v){var _=document.createElement("script");return _.setAttribute("src",v),_.setAttribute("crossorigin","anonymous"),new Promise(function(T){_.addEventListener("load",function(){T()},!1),_.addEventListener("error",function(){T()},!1),document.body.appendChild(_)})}function O5(){return Z(this,function v(){return $(v,function(_){switch(_.g){case 1:return _.m=2,b(_,WebAssembly.instantiate(k5),4);case 4:_.g=3,_.m=0;break;case 2:return _.m=0,_.j=null,_.return(!1);case 3:return _.return(!0)}})})}function zu(v){if(this.g=v,this.listeners={},this.j={},this.F={},this.m={},this.s={},this.G=this.o=this.R=!0,this.C=Promise.resolve(),this.P="",this.B={},this.locateFile=v&&v.locateFile||$5,typeof window=="object")var _=window.location.pathname.toString().substring(0,window.location.pathname.toString().lastIndexOf("/"))+"/";else if(typeof location!="undefined")_=location.pathname.toString().substring(0,location.pathname.toString().lastIndexOf("/"))+"/";else throw Error("solutions can only be loaded on a web page or in a web worker");if(this.S=_,v.options){_=a(Object.keys(v.options));for(var T=_.next();!T.done;T=_.next()){T=T.value;var D=v.options[T].default;D!==void 0&&(this.j[T]=typeof D=="function"?D():D)}}}n=zu.prototype,n.close=function(){return this.i&&this.i.delete(),Promise.resolve()};function B5(v,_){return v.g.files===void 0?[]:typeof v.g.files=="function"?v.g.files(_):v.g.files}function z5(v){return Z(v,function _(){var T=this,D,X,se,q,re,ge,Ne,Je,It,ut,rt;return $(_,function(Be){switch(Be.g){case 1:return D=T,T.R?(X=B5(T,T.j),b(Be,O5(),2)):Be.return();case 2:if(se=Be.h,typeof window=="object")return pf("createMediapipeSolutionsWasm",{locateFile:T.locateFile}),pf("createMediapipeSolutionsPackedAssets",{locateFile:T.locateFile}),ge=X.filter(function(Qe){return Qe.data!==void 0}),Ne=X.filter(function(Qe){return Qe.data===void 0}),Je=Promise.all(ge.map(function(Qe){var ct=Uu(D,Qe.url);if(Qe.path!==void 0){var yt=Qe.path;ct=ct.then(function(mn){return D.overrideFile(yt,mn),Promise.resolve(mn)})}return ct})),It=Promise.all(Ne.map(function(Qe){return Qe.simd===void 0||Qe.simd&&se||!Qe.simd&&!se?F5(D.locateFile(Qe.url,D.S)):Promise.resolve()})).then(function(){return Z(D,function Qe(){var ct,yt,mn=this;return $(Qe,function(Pt){if(Pt.g==1)return ct=window.createMediapipeSolutionsWasm,yt=window.createMediapipeSolutionsPackedAssets,b(Pt,ct(yt),2);mn.h=Pt.h,Pt.g=0})})}),ut=function(){return Z(D,function Qe(){var ct=this;return $(Qe,function(yt){return ct.g.graph&&ct.g.graph.url?yt=b(yt,Uu(ct,ct.g.graph.url),0):(yt.g=0,yt=void 0),yt})})}(),b(Be,Promise.all([It,Je,ut]),7);if(typeof importScripts!="function")throw Error("solutions can only be loaded on a web page or in a web worker");return q=X.filter(function(Qe){return Qe.simd===void 0||Qe.simd&&se||!Qe.simd&&!se}).map(function(Qe){return D.locateFile(Qe.url,D.S)}),importScripts.apply(null,l(q)),b(Be,createMediapipeSolutionsWasm(Module),6);case 6:T.h=Be.h,T.l=new OffscreenCanvas(1,1),T.h.canvas=T.l,re=T.h.GL.createContext(T.l,{antialias:!1,alpha:!1,ba:typeof WebGL2RenderingContext!="undefined"?2:1}),T.h.GL.makeContextCurrent(re),Be.g=4;break;case 7:if(T.l=document.createElement("canvas"),rt=T.l.getContext("webgl2",{}),!rt&&(rt=T.l.getContext("webgl",{}),!rt))return alert("Failed to create WebGL canvas context when passing video frame."),Be.return();T.D=rt,T.h.canvas=T.l,T.h.createContext(T.l,!0,!0,{});case 4:T.i=new T.h.SolutionWasm,T.R=!1,Be.g=0}})})}function U5(v){return Z(v,function _(){var T=this,D,X,se,q,re,ge,Ne,Je;return $(_,function(It){if(It.g==1){if(T.g.graph&&T.g.graph.url&&T.P===T.g.graph.url)return It.return();if(T.o=!0,!T.g.graph||!T.g.graph.url){It.g=2;return}return T.P=T.g.graph.url,b(It,Uu(T,T.g.graph.url),3)}for(It.g!=2&&(D=It.h,T.i.loadGraph(D)),X=a(Object.keys(T.B)),se=X.next();!se.done;se=X.next())q=se.value,T.i.overrideFile(q,T.B[q]);if(T.B={},T.g.listeners)for(re=a(T.g.listeners),ge=re.next();!ge.done;ge=re.next())Ne=ge.value,H5(T,Ne);Je=T.j,T.j={},T.setOptions(Je),It.g=0})})}n.reset=function(){return Z(this,function v(){var _=this;return $(v,function(T){_.i&&(_.i.reset(),_.m={},_.s={}),T.g=0})})},n.setOptions=function(v,_){var T=this;if(_=_||this.g.options){for(var D=[],X=[],se={},q=a(Object.keys(v)),re=q.next();!re.done;se={K:se.K,L:se.L},re=q.next()){var ge=re.value;ge in this.j&&this.j[ge]===v[ge]||(this.j[ge]=v[ge],re=_[ge],re!==void 0&&(re.onChange&&(se.K=re.onChange,se.L=v[ge],D.push(function(Ne){return function(){return Z(T,function Je(){var It,ut=this;return $(Je,function(rt){if(rt.g==1)return b(rt,Ne.K(Ne.L),2);It=rt.h,It===!0&&(ut.o=!0),rt.g=0})})}}(se))),re.graphOptionXref&&(ge={valueNumber:re.type===1?v[ge]:0,valueBoolean:re.type===0?v[ge]:!1,valueString:re.type===2?v[ge]:""},re=Object.assign(Object.assign(Object.assign({},{calculatorName:"",calculatorIndex:0}),re.graphOptionXref),ge),X.push(re))))}(D.length!==0||X.length!==0)&&(this.o=!0,this.A=(this.A===void 0?[]:this.A).concat(X),this.u=(this.u===void 0?[]:this.u).concat(D))}};function V5(v){return Z(v,function _(){var T=this,D,X,se,q,re,ge,Ne;return $(_,function(Je){switch(Je.g){case 1:if(!T.o)return Je.return();if(!T.u){Je.g=2;break}D=a(T.u),X=D.next();case 3:if(X.done){Je.g=5;break}return se=X.value,b(Je,se(),4);case 4:X=D.next(),Je.g=3;break;case 5:T.u=void 0;case 2:if(T.A){for(q=new T.h.GraphOptionChangeRequestList,re=a(T.A),ge=re.next();!ge.done;ge=re.next())Ne=ge.value,q.push_back(Ne);T.i.changeOptions(q),q.delete(),T.A=void 0}T.o=!1,Je.g=0}})})}n.initialize=function(){return Z(this,function v(){var _=this;return $(v,function(T){return T.g==1?b(T,z5(_),2):T.g!=3?b(T,U5(_),3):b(T,V5(_),0)})})};function Uu(v,_){return Z(v,function T(){var D=this,X,se;return $(T,function(q){return _ in D.F?q.return(D.F[_]):(X=D.locateFile(_,""),se=fetch(X).then(function(re){return re.arrayBuffer()}),D.F[_]=se,q.return(se))})})}n.overrideFile=function(v,_){this.i?this.i.overrideFile(v,_):this.B[v]=_},n.clearOverriddenFiles=function(){this.B={},this.i&&this.i.clearOverriddenFiles()},n.send=function(v,_){return Z(this,function T(){var D=this,X,se,q,re,ge,Ne,Je,It,ut;return $(T,function(rt){switch(rt.g){case 1:return D.g.inputs?(X=1e3*(_==null?performance.now():_),b(rt,D.C,2)):rt.return();case 2:return b(rt,D.initialize(),3);case 3:for(se=new D.h.PacketDataList,q=a(Object.keys(v)),re=q.next();!re.done;re=q.next())if(ge=re.value,Ne=D.g.inputs[ge]){e:{var Be=D,Qe=v[ge];switch(Ne.type){case"video":var ct=Be.m[Ne.stream];if(ct||(ct=new Bt(Be.h,Be.D),Be.m[Ne.stream]=ct),Be=ct,Be.l===0&&(Be.l=Be.h.createTexture()),typeof HTMLVideoElement!="undefined"&&Qe instanceof HTMLVideoElement){var yt=Qe.videoWidth;ct=Qe.videoHeight}else typeof HTMLImageElement!="undefined"&&Qe instanceof HTMLImageElement?(yt=Qe.naturalWidth,ct=Qe.naturalHeight):(yt=Qe.width,ct=Qe.height);ct={glName:Be.l,width:yt,height:ct},yt=Be.g,yt.canvas.width=ct.width,yt.canvas.height=ct.height,yt.activeTexture(yt.TEXTURE0),Be.h.bindTexture2d(Be.l),yt.texImage2D(yt.TEXTURE_2D,0,yt.RGBA,yt.RGBA,yt.UNSIGNED_BYTE,Qe),Be.h.bindTexture2d(0),Be=ct;break e;case"detections":for(ct=Be.m[Ne.stream],ct||(ct=new D5(Be.h),Be.m[Ne.stream]=ct),Be=ct,Be.data||(Be.data=new Be.g.DetectionListData),Be.data.reset(Qe.length),ct=0;ct<Qe.length;++ct){yt=Qe[ct];var mn=Be.data,Pt=mn.setBoundingBox,Bn=ct,Jt=yt.T,at=new Ot;lt(at,1,Jt.Z),lt(at,2,Jt.$),lt(at,3,Jt.height),lt(at,4,Jt.width),lt(at,5,Jt.rotation),lt(at,6,Jt.X);var wt=Jt=new ke;me(wt,1,Ft(at,1)),me(wt,2,Ft(at,2)),me(wt,3,Ft(at,3)),me(wt,4,Ft(at,4)),me(wt,5,Ft(at,5));var Tt=Ft(at,6);if(Tt!=null&&Tt!=null){ve(wt.g,48);var ht=wt.g,_t=Tt;Tt=0>_t,_t=Math.abs(_t);var Et=_t>>>0;for(_t=Math.floor((_t-Et)/4294967296),_t>>>=0,Tt&&(_t=~_t>>>0,Et=(~Et>>>0)+1,4294967295<Et&&(Et=0,_t++,4294967295<_t&&(_t=0))),Ae=Et,Fe=_t,Tt=Ae,Et=Fe;0<Et||127<Tt;)ht.push(Tt&127|128),Tt=(Tt>>>7|Et<<25)>>>0,Et>>>=7;ht.push(Tt)}if(Da(at,wt),Jt=U(Jt),Pt.call(mn,Bn,Jt),yt.O)for(mn=0;mn<yt.O.length;++mn)at=yt.O[mn],wt=!!at.visibility,Pt=Be.data,Bn=Pt.addNormalizedLandmark,Jt=ct,at=Object.assign(Object.assign({},at),{visibility:wt?at.visibility:0}),wt=new Ze,lt(wt,1,at.x),lt(wt,2,at.y),lt(wt,3,at.z),at.visibility&&lt(wt,4,at.visibility),ht=at=new ke,me(ht,1,Ft(wt,1)),me(ht,2,Ft(wt,2)),me(ht,3,Ft(wt,3)),me(ht,4,Ft(wt,4)),me(ht,5,Ft(wt,5)),Da(wt,ht),at=U(at),Bn.call(Pt,Jt,at);if(yt.M)for(mn=0;mn<yt.M.length;++mn){if(Pt=Be.data,Bn=Pt.addClassification,Jt=ct,at=yt.M[mn],wt=new J,lt(wt,2,at.Y),at.index&&lt(wt,1,at.index),at.label&&lt(wt,3,at.label),at.displayName&&lt(wt,4,at.displayName),ht=at=new ke,Et=Ft(wt,1),Et!=null&&Et!=null)if(ve(ht.g,8),Tt=ht.g,0<=Et)ve(Tt,Et);else{for(_t=0;9>_t;_t++)Tt.push(Et&127|128),Et>>=7;Tt.push(1)}me(ht,2,Ft(wt,2)),Tt=Ft(wt,3),Tt!=null&&(Tt=fe(Tt),ve(ht.g,26),ve(ht.g,Tt.length),Ie(ht,ht.g.end()),Ie(ht,Tt)),Tt=Ft(wt,4),Tt!=null&&(Tt=fe(Tt),ve(ht.g,34),ve(ht.g,Tt.length),Ie(ht,ht.g.end()),Ie(ht,Tt)),Da(wt,ht),at=U(at),Bn.call(Pt,Jt,at)}}Be=Be.data;break e;default:Be={}}}switch(Je=Be,It=Ne.stream,Ne.type){case"video":se.pushTexture2d(Object.assign(Object.assign({},Je),{stream:It,timestamp:X}));break;case"detections":ut=Je,ut.stream=It,ut.timestamp=X,se.pushDetectionList(ut);break;default:throw Error("Unknown input config type: '"+Ne.type+"'")}}return D.i.send(se),b(rt,D.C,4);case 4:se.delete(),rt.g=0}})})};function G5(v,_,T){return Z(v,function D(){var X,se,q,re,ge,Ne,Je=this,It,ut,rt,Be,Qe,ct,yt,mn;return $(D,function(Pt){switch(Pt.g){case 1:if(!T)return Pt.return(_);for(X={},se=0,q=a(Object.keys(T)),re=q.next();!re.done;re=q.next())ge=re.value,Ne=T[ge],typeof Ne!="string"&&Ne.type==="texture"&&_[Ne.stream]!==void 0&&++se;1<se&&(Je.G=!1),It=a(Object.keys(T)),re=It.next();case 2:if(re.done){Pt.g=4;break}if(ut=re.value,rt=T[ut],typeof rt=="string")return yt=X,mn=ut,b(Pt,W5(Je,ut,_[rt]),14);if(Be=_[rt.stream],rt.type==="detection_list"){if(Be){for(var Bn=Be.getRectList(),Jt=Be.getLandmarksList(),at=Be.getClassificationsList(),wt=[],Tt=0;Tt<Bn.size();++Tt){var ht=Bn.get(Tt);e:{var _t=new Ot;for(ht=new We(ht);Ue(ht);)switch(ht.i){case 13:var Et=k(ht);lt(_t,1,Et);break;case 21:Et=k(ht),lt(_t,2,Et);break;case 29:Et=k(ht),lt(_t,3,Et);break;case 37:Et=k(ht),lt(_t,4,Et);break;case 45:Et=k(ht),lt(_t,5,Et);break;case 48:Et=he(ht.g),lt(_t,6,Et);break;default:if(!zs(_t,ht))break e}}_t={Z:es(_t,1),$:es(_t,2),height:es(_t,3),width:es(_t,4),rotation:es(_t,5,0),X:Fn(_t,6,0)},ht=dr(ot(Jt.get(Tt)),Ze).map(Ms);var lo=at.get(Tt);e:for(Et=new je,lo=new We(lo);Ue(lo);)switch(lo.i){case 10:Et.addClassification(At(lo,new J,ie));break;default:if(!zs(Et,lo))break e}_t={T:_t,O:ht,M:mr(Et)},wt.push(_t)}Bn=wt}else Bn=[];X[ut]=Bn,Pt.g=7;break}if(rt.type==="proto_list"){if(Be){for(Bn=Array(Be.size()),Jt=0;Jt<Be.size();Jt++)Bn[Jt]=Be.get(Jt);Be.delete()}else Bn=[];X[ut]=Bn,Pt.g=7;break}if(Be===void 0){Pt.g=3;break}if(rt.type==="float_list"){X[ut]=Be,Pt.g=7;break}if(rt.type==="proto"){X[ut]=Be,Pt.g=7;break}if(rt.type!=="texture")throw Error("Unknown output config type: '"+rt.type+"'");return Qe=Je.s[ut],Qe||(Qe=new Bt(Je.h,Je.D),Je.s[ut]=Qe),b(Pt,Fr(Qe,Be,Je.G),13);case 13:ct=Pt.h,X[ut]=ct;case 7:rt.transform&&X[ut]&&(X[ut]=rt.transform(X[ut])),Pt.g=3;break;case 14:yt[mn]=Pt.h;case 3:re=It.next(),Pt.g=2;break;case 4:return Pt.return(X)}})})}function W5(v,_,T){return Z(v,function D(){var X=this,se;return $(D,function(q){return typeof T=="number"||T instanceof Uint8Array||T instanceof X.h.Uint8BlobList?q.return(T):T instanceof X.h.Texture2dDataOut?(se=X.s[_],se||(se=new Bt(X.h,X.D),X.s[_]=se),q.return(Fr(se,T,X.G))):q.return(void 0)})})}function H5(v,_){for(var T=_.name||"$",D=[].concat(l(_.wants)),X=new v.h.StringList,se=a(_.wants),q=se.next();!q.done;q=se.next())X.push_back(q.value);se=v.h.PacketListener.implement({onResults:function(re){for(var ge={},Ne=0;Ne<_.wants.length;++Ne)ge[D[Ne]]=re.get(Ne);var Je=v.listeners[T];Je&&(v.C=G5(v,ge,_.outs).then(function(It){It=Je(It);for(var ut=0;ut<_.wants.length;++ut){var rt=ge[D[ut]];typeof rt=="object"&&rt.hasOwnProperty&&rt.hasOwnProperty("delete")&&rt.delete()}It&&(v.C=It)}))}}),v.i.attachMultiListener(X,se),X.delete()}n.onResults=function(v,_){this.listeners[_||"$"]=v},F("Solution",zu),F("OptionType",{BOOL:0,NUMBER:1,aa:2,0:"BOOL",1:"NUMBER",2:"STRING"});function X5(v){v=fr(v);var _=v.getMesh();if(!_)return v;var T=new Float32Array(_.getVertexBufferList());_.getVertexBufferList=function(){return T};var D=new Uint32Array(_.getIndexBufferList());return _.getIndexBufferList=function(){return D},v}var j5={files:[{url:"face_mesh_solution_packed_assets_loader.js"},{simd:!0,url:"face_mesh_solution_simd_wasm_bin.js"},{simd:!1,url:"face_mesh_solution_wasm_bin.js"}],graph:{url:"face_mesh.binarypb"},listeners:[{wants:["multi_face_geometry","image_transformed","multi_face_landmarks"],outs:{image:"image_transformed",multiFaceGeometry:{type:"proto_list",stream:"multi_face_geometry",transform:function(v){return v.map(X5)}},multiFaceLandmarks:{type:"proto_list",stream:"multi_face_landmarks",transform:function(v){return v.map(function(_){return dr(ot(_),Ze).map(Ms)})}}}}],inputs:{image:{type:"video",stream:"input_frames_gpu"}},options:{useCpuInference:{type:0,graphOptionXref:{calculatorType:"InferenceCalculator",fieldName:"use_cpu_inference"},default:"iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform)||navigator.userAgent.includes("Mac")&&"ontouchend"in document},enableFaceGeometry:{type:0,graphOptionXref:{calculatorName:"EnableFaceGeometryConstant",calculatorType:"ConstantSidePacketCalculator",fieldName:"bool_value"}},selfieMode:{type:0,graphOptionXref:{calculatorType:"GlScalerCalculator",calculatorIndex:1,fieldName:"flip_horizontal"}},maxNumFaces:{type:1,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorNumFaces",fieldName:"int_value"}},refineLandmarks:{type:0,graphOptionXref:{calculatorType:"ConstantSidePacketCalculator",calculatorName:"ConstantSidePacketCalculatorRefineLandmarks",fieldName:"bool_value"}},minDetectionConfidence:{type:1,graphOptionXref:{calculatorType:"TensorsToDetectionsCalculator",calculatorName:"facelandmarkfrontgpu__facedetectionshortrangegpu__facedetectionshortrangecommon__TensorsToDetectionsCalculator",fieldName:"min_score_thresh"}},minTrackingConfidence:{type:1,graphOptionXref:{calculatorType:"ThresholdingCalculator",calculatorName:"facelandmarkfrontgpu__facelandmarkgpu__ThresholdingCalculator",fieldName:"threshold"}},cameraNear:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"near"}},cameraFar:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"far"}},cameraVerticalFovDegrees:{type:1,graphOptionXref:{calculatorType:"FaceGeometryEnvGeneratorCalculator",fieldName:"vertical_fov_degrees"}}}},ff=[[61,146],[146,91],[91,181],[181,84],[84,17],[17,314],[314,405],[405,321],[321,375],[375,291],[61,185],[185,40],[40,39],[39,37],[37,0],[0,267],[267,269],[269,270],[270,409],[409,291],[78,95],[95,88],[88,178],[178,87],[87,14],[14,317],[317,402],[402,318],[318,324],[324,308],[78,191],[191,80],[80,81],[81,82],[82,13],[13,312],[312,311],[311,310],[310,415],[415,308]],mf=[[263,249],[249,390],[390,373],[373,374],[374,380],[380,381],[381,382],[382,362],[263,466],[466,388],[388,387],[387,386],[386,385],[385,384],[384,398],[398,362]],gf=[[276,283],[283,282],[282,295],[295,285],[300,293],[293,334],[334,296],[296,336]],xf=[[33,7],[7,163],[163,144],[144,145],[145,153],[153,154],[154,155],[155,133],[33,246],[246,161],[161,160],[160,159],[159,158],[158,157],[157,173],[173,133]],yf=[[46,53],[53,52],[52,65],[65,55],[70,63],[63,105],[105,66],[66,107]],vf=[[10,338],[338,297],[297,332],[332,284],[284,251],[251,389],[389,356],[356,454],[454,323],[323,361],[361,288],[288,397],[397,365],[365,379],[379,378],[378,400],[400,377],[377,152],[152,148],[148,176],[176,149],[149,150],[150,136],[136,172],[172,58],[58,132],[132,93],[93,234],[234,127],[127,162],[162,21],[21,54],[54,103],[103,67],[67,109],[109,10]],q5=[].concat(l(ff),l(mf),l(gf),l(xf),l(yf),l(vf));function bf(v){v=v||{},v=Object.assign(Object.assign({},j5),v),this.g=new zu(v)}n=bf.prototype,n.close=function(){return this.g.close(),Promise.resolve()},n.onResults=function(v){this.g.onResults(v)},n.initialize=function(){return Z(this,function v(){var _=this;return $(v,function(T){return b(T,_.g.initialize(),0)})})},n.reset=function(){this.g.reset()},n.send=function(v){return Z(this,function _(){var T=this;return $(_,function(D){return b(D,T.g.send(v),0)})})},n.setOptions=function(v){this.g.setOptions(v)},F("FACE_GEOMETRY",{Layout:{COLUMN_MAJOR:0,ROW_MAJOR:1,0:"COLUMN_MAJOR",1:"ROW_MAJOR"},PrimitiveType:{TRIANGLE:0,0:"TRIANGLE"},VertexType:{VERTEX_PT:0,0:"VERTEX_PT"},DEFAULT_CAMERA_PARAMS:{verticalFovDegrees:63,near:1,far:1e4}}),F("FaceMesh",bf),F("FACEMESH_LIPS",ff),F("FACEMESH_LEFT_EYE",mf),F("FACEMESH_LEFT_EYEBROW",gf),F("FACEMESH_LEFT_IRIS",[[474,475],[475,476],[476,477],[477,474]]),F("FACEMESH_RIGHT_EYE",xf),F("FACEMESH_RIGHT_EYEBROW",yf),F("FACEMESH_RIGHT_IRIS",[[469,470],[470,471],[471,472],[472,469]]),F("FACEMESH_FACE_OVAL",vf),F("FACEMESH_CONTOURS",q5),F("FACEMESH_TESSELATION",[[127,34],[34,139],[139,127],[11,0],[0,37],[37,11],[232,231],[231,120],[120,232],[72,37],[37,39],[39,72],[128,121],[121,47],[47,128],[232,121],[121,128],[128,232],[104,69],[69,67],[67,104],[175,171],[171,148],[148,175],[118,50],[50,101],[101,118],[73,39],[39,40],[40,73],[9,151],[151,108],[108,9],[48,115],[115,131],[131,48],[194,204],[204,211],[211,194],[74,40],[40,185],[185,74],[80,42],[42,183],[183,80],[40,92],[92,186],[186,40],[230,229],[229,118],[118,230],[202,212],[212,214],[214,202],[83,18],[18,17],[17,83],[76,61],[61,146],[146,76],[160,29],[29,30],[30,160],[56,157],[157,173],[173,56],[106,204],[204,194],[194,106],[135,214],[214,192],[192,135],[203,165],[165,98],[98,203],[21,71],[71,68],[68,21],[51,45],[45,4],[4,51],[144,24],[24,23],[23,144],[77,146],[146,91],[91,77],[205,50],[50,187],[187,205],[201,200],[200,18],[18,201],[91,106],[106,182],[182,91],[90,91],[91,181],[181,90],[85,84],[84,17],[17,85],[206,203],[203,36],[36,206],[148,171],[171,140],[140,148],[92,40],[40,39],[39,92],[193,189],[189,244],[244,193],[159,158],[158,28],[28,159],[247,246],[246,161],[161,247],[236,3],[3,196],[196,236],[54,68],[68,104],[104,54],[193,168],[168,8],[8,193],[117,228],[228,31],[31,117],[189,193],[193,55],[55,189],[98,97],[97,99],[99,98],[126,47],[47,100],[100,126],[166,79],[79,218],[218,166],[155,154],[154,26],[26,155],[209,49],[49,131],[131,209],[135,136],[136,150],[150,135],[47,126],[126,217],[217,47],[223,52],[52,53],[53,223],[45,51],[51,134],[134,45],[211,170],[170,140],[140,211],[67,69],[69,108],[108,67],[43,106],[106,91],[91,43],[230,119],[119,120],[120,230],[226,130],[130,247],[247,226],[63,53],[53,52],[52,63],[238,20],[20,242],[242,238],[46,70],[70,156],[156,46],[78,62],[62,96],[96,78],[46,53],[53,63],[63,46],[143,34],[34,227],[227,143],[123,117],[117,111],[111,123],[44,125],[125,19],[19,44],[236,134],[134,51],[51,236],[216,206],[206,205],[205,216],[154,153],[153,22],[22,154],[39,37],[37,167],[167,39],[200,201],[201,208],[208,200],[36,142],[142,100],[100,36],[57,212],[212,202],[202,57],[20,60],[60,99],[99,20],[28,158],[158,157],[157,28],[35,226],[226,113],[113,35],[160,159],[159,27],[27,160],[204,202],[202,210],[210,204],[113,225],[225,46],[46,113],[43,202],[202,204],[204,43],[62,76],[76,77],[77,62],[137,123],[123,116],[116,137],[41,38],[38,72],[72,41],[203,129],[129,142],[142,203],[64,98],[98,240],[240,64],[49,102],[102,64],[64,49],[41,73],[73,74],[74,41],[212,216],[216,207],[207,212],[42,74],[74,184],[184,42],[169,170],[170,211],[211,169],[170,149],[149,176],[176,170],[105,66],[66,69],[69,105],[122,6],[6,168],[168,122],[123,147],[147,187],[187,123],[96,77],[77,90],[90,96],[65,55],[55,107],[107,65],[89,90],[90,180],[180,89],[101,100],[100,120],[120,101],[63,105],[105,104],[104,63],[93,137],[137,227],[227,93],[15,86],[86,85],[85,15],[129,102],[102,49],[49,129],[14,87],[87,86],[86,14],[55,8],[8,9],[9,55],[100,47],[47,121],[121,100],[145,23],[23,22],[22,145],[88,89],[89,179],[179,88],[6,122],[122,196],[196,6],[88,95],[95,96],[96,88],[138,172],[172,136],[136,138],[215,58],[58,172],[172,215],[115,48],[48,219],[219,115],[42,80],[80,81],[81,42],[195,3],[3,51],[51,195],[43,146],[146,61],[61,43],[171,175],[175,199],[199,171],[81,82],[82,38],[38,81],[53,46],[46,225],[225,53],[144,163],[163,110],[110,144],[52,65],[65,66],[66,52],[229,228],[228,117],[117,229],[34,127],[127,234],[234,34],[107,108],[108,69],[69,107],[109,108],[108,151],[151,109],[48,64],[64,235],[235,48],[62,78],[78,191],[191,62],[129,209],[209,126],[126,129],[111,35],[35,143],[143,111],[117,123],[123,50],[50,117],[222,65],[65,52],[52,222],[19,125],[125,141],[141,19],[221,55],[55,65],[65,221],[3,195],[195,197],[197,3],[25,7],[7,33],[33,25],[220,237],[237,44],[44,220],[70,71],[71,139],[139,70],[122,193],[193,245],[245,122],[247,130],[130,33],[33,247],[71,21],[21,162],[162,71],[170,169],[169,150],[150,170],[188,174],[174,196],[196,188],[216,186],[186,92],[92,216],[2,97],[97,167],[167,2],[141,125],[125,241],[241,141],[164,167],[167,37],[37,164],[72,38],[38,12],[12,72],[38,82],[82,13],[13,38],[63,68],[68,71],[71,63],[226,35],[35,111],[111,226],[101,50],[50,205],[205,101],[206,92],[92,165],[165,206],[209,198],[198,217],[217,209],[165,167],[167,97],[97,165],[220,115],[115,218],[218,220],[133,112],[112,243],[243,133],[239,238],[238,241],[241,239],[214,135],[135,169],[169,214],[190,173],[173,133],[133,190],[171,208],[208,32],[32,171],[125,44],[44,237],[237,125],[86,87],[87,178],[178,86],[85,86],[86,179],[179,85],[84,85],[85,180],[180,84],[83,84],[84,181],[181,83],[201,83],[83,182],[182,201],[137,93],[93,132],[132,137],[76,62],[62,183],[183,76],[61,76],[76,184],[184,61],[57,61],[61,185],[185,57],[212,57],[57,186],[186,212],[214,207],[207,187],[187,214],[34,143],[143,156],[156,34],[79,239],[239,237],[237,79],[123,137],[137,177],[177,123],[44,1],[1,4],[4,44],[201,194],[194,32],[32,201],[64,102],[102,129],[129,64],[213,215],[215,138],[138,213],[59,166],[166,219],[219,59],[242,99],[99,97],[97,242],[2,94],[94,141],[141,2],[75,59],[59,235],[235,75],[24,110],[110,228],[228,24],[25,130],[130,226],[226,25],[23,24],[24,229],[229,23],[22,23],[23,230],[230,22],[26,22],[22,231],[231,26],[112,26],[26,232],[232,112],[189,190],[190,243],[243,189],[221,56],[56,190],[190,221],[28,56],[56,221],[221,28],[27,28],[28,222],[222,27],[29,27],[27,223],[223,29],[30,29],[29,224],[224,30],[247,30],[30,225],[225,247],[238,79],[79,20],[20,238],[166,59],[59,75],[75,166],[60,75],[75,240],[240,60],[147,177],[177,215],[215,147],[20,79],[79,166],[166,20],[187,147],[147,213],[213,187],[112,233],[233,244],[244,112],[233,128],[128,245],[245,233],[128,114],[114,188],[188,128],[114,217],[217,174],[174,114],[131,115],[115,220],[220,131],[217,198],[198,236],[236,217],[198,131],[131,134],[134,198],[177,132],[132,58],[58,177],[143,35],[35,124],[124,143],[110,163],[163,7],[7,110],[228,110],[110,25],[25,228],[356,389],[389,368],[368,356],[11,302],[302,267],[267,11],[452,350],[350,349],[349,452],[302,303],[303,269],[269,302],[357,343],[343,277],[277,357],[452,453],[453,357],[357,452],[333,332],[332,297],[297,333],[175,152],[152,377],[377,175],[347,348],[348,330],[330,347],[303,304],[304,270],[270,303],[9,336],[336,337],[337,9],[278,279],[279,360],[360,278],[418,262],[262,431],[431,418],[304,408],[408,409],[409,304],[310,415],[415,407],[407,310],[270,409],[409,410],[410,270],[450,348],[348,347],[347,450],[422,430],[430,434],[434,422],[313,314],[314,17],[17,313],[306,307],[307,375],[375,306],[387,388],[388,260],[260,387],[286,414],[414,398],[398,286],[335,406],[406,418],[418,335],[364,367],[367,416],[416,364],[423,358],[358,327],[327,423],[251,284],[284,298],[298,251],[281,5],[5,4],[4,281],[373,374],[374,253],[253,373],[307,320],[320,321],[321,307],[425,427],[427,411],[411,425],[421,313],[313,18],[18,421],[321,405],[405,406],[406,321],[320,404],[404,405],[405,320],[315,16],[16,17],[17,315],[426,425],[425,266],[266,426],[377,400],[400,369],[369,377],[322,391],[391,269],[269,322],[417,465],[465,464],[464,417],[386,257],[257,258],[258,386],[466,260],[260,388],[388,466],[456,399],[399,419],[419,456],[284,332],[332,333],[333,284],[417,285],[285,8],[8,417],[346,340],[340,261],[261,346],[413,441],[441,285],[285,413],[327,460],[460,328],[328,327],[355,371],[371,329],[329,355],[392,439],[439,438],[438,392],[382,341],[341,256],[256,382],[429,420],[420,360],[360,429],[364,394],[394,379],[379,364],[277,343],[343,437],[437,277],[443,444],[444,283],[283,443],[275,440],[440,363],[363,275],[431,262],[262,369],[369,431],[297,338],[338,337],[337,297],[273,375],[375,321],[321,273],[450,451],[451,349],[349,450],[446,342],[342,467],[467,446],[293,334],[334,282],[282,293],[458,461],[461,462],[462,458],[276,353],[353,383],[383,276],[308,324],[324,325],[325,308],[276,300],[300,293],[293,276],[372,345],[345,447],[447,372],[352,345],[345,340],[340,352],[274,1],[1,19],[19,274],[456,248],[248,281],[281,456],[436,427],[427,425],[425,436],[381,256],[256,252],[252,381],[269,391],[391,393],[393,269],[200,199],[199,428],[428,200],[266,330],[330,329],[329,266],[287,273],[273,422],[422,287],[250,462],[462,328],[328,250],[258,286],[286,384],[384,258],[265,353],[353,342],[342,265],[387,259],[259,257],[257,387],[424,431],[431,430],[430,424],[342,353],[353,276],[276,342],[273,335],[335,424],[424,273],[292,325],[325,307],[307,292],[366,447],[447,345],[345,366],[271,303],[303,302],[302,271],[423,266],[266,371],[371,423],[294,455],[455,460],[460,294],[279,278],[278,294],[294,279],[271,272],[272,304],[304,271],[432,434],[434,427],[427,432],[272,407],[407,408],[408,272],[394,430],[430,431],[431,394],[395,369],[369,400],[400,395],[334,333],[333,299],[299,334],[351,417],[417,168],[168,351],[352,280],[280,411],[411,352],[325,319],[319,320],[320,325],[295,296],[296,336],[336,295],[319,403],[403,404],[404,319],[330,348],[348,349],[349,330],[293,298],[298,333],[333,293],[323,454],[454,447],[447,323],[15,16],[16,315],[315,15],[358,429],[429,279],[279,358],[14,15],[15,316],[316,14],[285,336],[336,9],[9,285],[329,349],[349,350],[350,329],[374,380],[380,252],[252,374],[318,402],[402,403],[403,318],[6,197],[197,419],[419,6],[318,319],[319,325],[325,318],[367,364],[364,365],[365,367],[435,367],[367,397],[397,435],[344,438],[438,439],[439,344],[272,271],[271,311],[311,272],[195,5],[5,281],[281,195],[273,287],[287,291],[291,273],[396,428],[428,199],[199,396],[311,271],[271,268],[268,311],[283,444],[444,445],[445,283],[373,254],[254,339],[339,373],[282,334],[334,296],[296,282],[449,347],[347,346],[346,449],[264,447],[447,454],[454,264],[336,296],[296,299],[299,336],[338,10],[10,151],[151,338],[278,439],[439,455],[455,278],[292,407],[407,415],[415,292],[358,371],[371,355],[355,358],[340,345],[345,372],[372,340],[346,347],[347,280],[280,346],[442,443],[443,282],[282,442],[19,94],[94,370],[370,19],[441,442],[442,295],[295,441],[248,419],[419,197],[197,248],[263,255],[255,359],[359,263],[440,275],[275,274],[274,440],[300,383],[383,368],[368,300],[351,412],[412,465],[465,351],[263,467],[467,466],[466,263],[301,368],[368,389],[389,301],[395,378],[378,379],[379,395],[412,351],[351,419],[419,412],[436,426],[426,322],[322,436],[2,164],[164,393],[393,2],[370,462],[462,461],[461,370],[164,0],[0,267],[267,164],[302,11],[11,12],[12,302],[268,12],[12,13],[13,268],[293,300],[300,301],[301,293],[446,261],[261,340],[340,446],[330,266],[266,425],[425,330],[426,423],[423,391],[391,426],[429,355],[355,437],[437,429],[391,327],[327,326],[326,391],[440,457],[457,438],[438,440],[341,382],[382,362],[362,341],[459,457],[457,461],[461,459],[434,430],[430,394],[394,434],[414,463],[463,362],[362,414],[396,369],[369,262],[262,396],[354,461],[461,457],[457,354],[316,403],[403,402],[402,316],[315,404],[404,403],[403,315],[314,405],[405,404],[404,314],[313,406],[406,405],[405,313],[421,418],[418,406],[406,421],[366,401],[401,361],[361,366],[306,408],[408,407],[407,306],[291,409],[409,408],[408,291],[287,410],[410,409],[409,287],[432,436],[436,410],[410,432],[434,416],[416,411],[411,434],[264,368],[368,383],[383,264],[309,438],[438,457],[457,309],[352,376],[376,401],[401,352],[274,275],[275,4],[4,274],[421,428],[428,262],[262,421],[294,327],[327,358],[358,294],[433,416],[416,367],[367,433],[289,455],[455,439],[439,289],[462,370],[370,326],[326,462],[2,326],[326,370],[370,2],[305,460],[460,455],[455,305],[254,449],[449,448],[448,254],[255,261],[261,446],[446,255],[253,450],[450,449],[449,253],[252,451],[451,450],[450,252],[256,452],[452,451],[451,256],[341,453],[453,452],[452,341],[413,464],[464,463],[463,413],[441,413],[413,414],[414,441],[258,442],[442,441],[441,258],[257,443],[443,442],[442,257],[259,444],[444,443],[443,259],[260,445],[445,444],[444,260],[467,342],[342,445],[445,467],[459,458],[458,250],[250,459],[289,392],[392,290],[290,289],[290,328],[328,460],[460,290],[376,433],[433,435],[435,376],[250,290],[290,392],[392,250],[411,416],[416,433],[433,411],[341,463],[463,464],[464,341],[453,464],[464,465],[465,453],[357,465],[465,412],[412,357],[343,412],[412,399],[399,343],[360,363],[363,440],[440,360],[437,399],[399,456],[456,437],[420,456],[456,363],[363,420],[401,435],[435,288],[288,401],[372,383],[383,353],[353,372],[339,255],[255,249],[249,339],[448,261],[261,255],[255,448],[133,243],[243,190],[190,133],[133,155],[155,112],[112,133],[33,246],[246,247],[247,33],[33,130],[130,25],[25,33],[398,384],[384,286],[286,398],[362,398],[398,414],[414,362],[362,463],[463,341],[341,362],[263,359],[359,467],[467,263],[263,249],[249,255],[255,263],[466,467],[467,260],[260,466],[75,60],[60,166],[166,75],[238,239],[239,79],[79,238],[162,127],[127,139],[139,162],[72,11],[11,37],[37,72],[121,232],[232,120],[120,121],[73,72],[72,39],[39,73],[114,128],[128,47],[47,114],[233,232],[232,128],[128,233],[103,104],[104,67],[67,103],[152,175],[175,148],[148,152],[119,118],[118,101],[101,119],[74,73],[73,40],[40,74],[107,9],[9,108],[108,107],[49,48],[48,131],[131,49],[32,194],[194,211],[211,32],[184,74],[74,185],[185,184],[191,80],[80,183],[183,191],[185,40],[40,186],[186,185],[119,230],[230,118],[118,119],[210,202],[202,214],[214,210],[84,83],[83,17],[17,84],[77,76],[76,146],[146,77],[161,160],[160,30],[30,161],[190,56],[56,173],[173,190],[182,106],[106,194],[194,182],[138,135],[135,192],[192,138],[129,203],[203,98],[98,129],[54,21],[21,68],[68,54],[5,51],[51,4],[4,5],[145,144],[144,23],[23,145],[90,77],[77,91],[91,90],[207,205],[205,187],[187,207],[83,201],[201,18],[18,83],[181,91],[91,182],[182,181],[180,90],[90,181],[181,180],[16,85],[85,17],[17,16],[205,206],[206,36],[36,205],[176,148],[148,140],[140,176],[165,92],[92,39],[39,165],[245,193],[193,244],[244,245],[27,159],[159,28],[28,27],[30,247],[247,161],[161,30],[174,236],[236,196],[196,174],[103,54],[54,104],[104,103],[55,193],[193,8],[8,55],[111,117],[117,31],[31,111],[221,189],[189,55],[55,221],[240,98],[98,99],[99,240],[142,126],[126,100],[100,142],[219,166],[166,218],[218,219],[112,155],[155,26],[26,112],[198,209],[209,131],[131,198],[169,135],[135,150],[150,169],[114,47],[47,217],[217,114],[224,223],[223,53],[53,224],[220,45],[45,134],[134,220],[32,211],[211,140],[140,32],[109,67],[67,108],[108,109],[146,43],[43,91],[91,146],[231,230],[230,120],[120,231],[113,226],[226,247],[247,113],[105,63],[63,52],[52,105],[241,238],[238,242],[242,241],[124,46],[46,156],[156,124],[95,78],[78,96],[96,95],[70,46],[46,63],[63,70],[116,143],[143,227],[227,116],[116,123],[123,111],[111,116],[1,44],[44,19],[19,1],[3,236],[236,51],[51,3],[207,216],[216,205],[205,207],[26,154],[154,22],[22,26],[165,39],[39,167],[167,165],[199,200],[200,208],[208,199],[101,36],[36,100],[100,101],[43,57],[57,202],[202,43],[242,20],[20,99],[99,242],[56,28],[28,157],[157,56],[124,35],[35,113],[113,124],[29,160],[160,27],[27,29],[211,204],[204,210],[210,211],[124,113],[113,46],[46,124],[106,43],[43,204],[204,106],[96,62],[62,77],[77,96],[227,137],[137,116],[116,227],[73,41],[41,72],[72,73],[36,203],[203,142],[142,36],[235,64],[64,240],[240,235],[48,49],[49,64],[64,48],[42,41],[41,74],[74,42],[214,212],[212,207],[207,214],[183,42],[42,184],[184,183],[210,169],[169,211],[211,210],[140,170],[170,176],[176,140],[104,105],[105,69],[69,104],[193,122],[122,168],[168,193],[50,123],[123,187],[187,50],[89,96],[96,90],[90,89],[66,65],[65,107],[107,66],[179,89],[89,180],[180,179],[119,101],[101,120],[120,119],[68,63],[63,104],[104,68],[234,93],[93,227],[227,234],[16,15],[15,85],[85,16],[209,129],[129,49],[49,209],[15,14],[14,86],[86,15],[107,55],[55,9],[9,107],[120,100],[100,121],[121,120],[153,145],[145,22],[22,153],[178,88],[88,179],[179,178],[197,6],[6,196],[196,197],[89,88],[88,96],[96,89],[135,138],[138,136],[136,135],[138,215],[215,172],[172,138],[218,115],[115,219],[219,218],[41,42],[42,81],[81,41],[5,195],[195,51],[51,5],[57,43],[43,61],[61,57],[208,171],[171,199],[199,208],[41,81],[81,38],[38,41],[224,53],[53,225],[225,224],[24,144],[144,110],[110,24],[105,52],[52,66],[66,105],[118,229],[229,117],[117,118],[227,34],[34,234],[234,227],[66,107],[107,69],[69,66],[10,109],[109,151],[151,10],[219,48],[48,235],[235,219],[183,62],[62,191],[191,183],[142,129],[129,126],[126,142],[116,111],[111,143],[143,116],[118,117],[117,50],[50,118],[223,222],[222,52],[52,223],[94,19],[19,141],[141,94],[222,221],[221,65],[65,222],[196,3],[3,197],[197,196],[45,220],[220,44],[44,45],[156,70],[70,139],[139,156],[188,122],[122,245],[245,188],[139,71],[71,162],[162,139],[149,170],[170,150],[150,149],[122,188],[188,196],[196,122],[206,216],[216,92],[92,206],[164,2],[2,167],[167,164],[242,141],[141,241],[241,242],[0,164],[164,37],[37,0],[11,72],[72,12],[12,11],[12,38],[38,13],[13,12],[70,63],[63,71],[71,70],[31,226],[226,111],[111,31],[36,101],[101,205],[205,36],[203,206],[206,165],[165,203],[126,209],[209,217],[217,126],[98,165],[165,97],[97,98],[237,220],[220,218],[218,237],[237,239],[239,241],[241,237],[210,214],[214,169],[169,210],[140,171],[171,32],[32,140],[241,125],[125,237],[237,241],[179,86],[86,178],[178,179],[180,85],[85,179],[179,180],[181,84],[84,180],[180,181],[182,83],[83,181],[181,182],[194,201],[201,182],[182,194],[177,137],[137,132],[132,177],[184,76],[76,183],[183,184],[185,61],[61,184],[184,185],[186,57],[57,185],[185,186],[216,212],[212,186],[186,216],[192,214],[214,187],[187,192],[139,34],[34,156],[156,139],[218,79],[79,237],[237,218],[147,123],[123,177],[177,147],[45,44],[44,4],[4,45],[208,201],[201,32],[32,208],[98,64],[64,129],[129,98],[192,213],[213,138],[138,192],[235,59],[59,219],[219,235],[141,242],[242,97],[97,141],[97,2],[2,141],[141,97],[240,75],[75,235],[235,240],[229,24],[24,228],[228,229],[31,25],[25,226],[226,31],[230,23],[23,229],[229,230],[231,22],[22,230],[230,231],[232,26],[26,231],[231,232],[233,112],[112,232],[232,233],[244,189],[189,243],[243,244],[189,221],[221,190],[190,189],[222,28],[28,221],[221,222],[223,27],[27,222],[222,223],[224,29],[29,223],[223,224],[225,30],[30,224],[224,225],[113,247],[247,225],[225,113],[99,60],[60,240],[240,99],[213,147],[147,215],[215,213],[60,20],[20,166],[166,60],[192,187],[187,213],[213,192],[243,112],[112,244],[244,243],[244,233],[233,245],[245,244],[245,128],[128,188],[188,245],[188,114],[114,174],[174,188],[134,131],[131,220],[220,134],[174,217],[217,236],[236,174],[236,198],[198,134],[134,236],[215,177],[177,58],[58,215],[156,143],[143,124],[124,156],[25,110],[110,7],[7,25],[31,228],[228,25],[25,31],[264,356],[356,368],[368,264],[0,11],[11,267],[267,0],[451,452],[452,349],[349,451],[267,302],[302,269],[269,267],[350,357],[357,277],[277,350],[350,452],[452,357],[357,350],[299,333],[333,297],[297,299],[396,175],[175,377],[377,396],[280,347],[347,330],[330,280],[269,303],[303,270],[270,269],[151,9],[9,337],[337,151],[344,278],[278,360],[360,344],[424,418],[418,431],[431,424],[270,304],[304,409],[409,270],[272,310],[310,407],[407,272],[322,270],[270,410],[410,322],[449,450],[450,347],[347,449],[432,422],[422,434],[434,432],[18,313],[313,17],[17,18],[291,306],[306,375],[375,291],[259,387],[387,260],[260,259],[424,335],[335,418],[418,424],[434,364],[364,416],[416,434],[391,423],[423,327],[327,391],[301,251],[251,298],[298,301],[275,281],[281,4],[4,275],[254,373],[373,253],[253,254],[375,307],[307,321],[321,375],[280,425],[425,411],[411,280],[200,421],[421,18],[18,200],[335,321],[321,406],[406,335],[321,320],[320,405],[405,321],[314,315],[315,17],[17,314],[423,426],[426,266],[266,423],[396,377],[377,369],[369,396],[270,322],[322,269],[269,270],[413,417],[417,464],[464,413],[385,386],[386,258],[258,385],[248,456],[456,419],[419,248],[298,284],[284,333],[333,298],[168,417],[417,8],[8,168],[448,346],[346,261],[261,448],[417,413],[413,285],[285,417],[326,327],[327,328],[328,326],[277,355],[355,329],[329,277],[309,392],[392,438],[438,309],[381,382],[382,256],[256,381],[279,429],[429,360],[360,279],[365,364],[364,379],[379,365],[355,277],[277,437],[437,355],[282,443],[443,283],[283,282],[281,275],[275,363],[363,281],[395,431],[431,369],[369,395],[299,297],[297,337],[337,299],[335,273],[273,321],[321,335],[348,450],[450,349],[349,348],[359,446],[446,467],[467,359],[283,293],[293,282],[282,283],[250,458],[458,462],[462,250],[300,276],[276,383],[383,300],[292,308],[308,325],[325,292],[283,276],[276,293],[293,283],[264,372],[372,447],[447,264],[346,352],[352,340],[340,346],[354,274],[274,19],[19,354],[363,456],[456,281],[281,363],[426,436],[436,425],[425,426],[380,381],[381,252],[252,380],[267,269],[269,393],[393,267],[421,200],[200,428],[428,421],[371,266],[266,329],[329,371],[432,287],[287,422],[422,432],[290,250],[250,328],[328,290],[385,258],[258,384],[384,385],[446,265],[265,342],[342,446],[386,387],[387,257],[257,386],[422,424],[424,430],[430,422],[445,342],[342,276],[276,445],[422,273],[273,424],[424,422],[306,292],[292,307],[307,306],[352,366],[366,345],[345,352],[268,271],[271,302],[302,268],[358,423],[423,371],[371,358],[327,294],[294,460],[460,327],[331,279],[279,294],[294,331],[303,271],[271,304],[304,303],[436,432],[432,427],[427,436],[304,272],[272,408],[408,304],[395,394],[394,431],[431,395],[378,395],[395,400],[400,378],[296,334],[334,299],[299,296],[6,351],[351,168],[168,6],[376,352],[352,411],[411,376],[307,325],[325,320],[320,307],[285,295],[295,336],[336,285],[320,319],[319,404],[404,320],[329,330],[330,349],[349,329],[334,293],[293,333],[333,334],[366,323],[323,447],[447,366],[316,15],[15,315],[315,316],[331,358],[358,279],[279,331],[317,14],[14,316],[316,317],[8,285],[285,9],[9,8],[277,329],[329,350],[350,277],[253,374],[374,252],[252,253],[319,318],[318,403],[403,319],[351,6],[6,419],[419,351],[324,318],[318,325],[325,324],[397,367],[367,365],[365,397],[288,435],[435,397],[397,288],[278,344],[344,439],[439,278],[310,272],[272,311],[311,310],[248,195],[195,281],[281,248],[375,273],[273,291],[291,375],[175,396],[396,199],[199,175],[312,311],[311,268],[268,312],[276,283],[283,445],[445,276],[390,373],[373,339],[339,390],[295,282],[282,296],[296,295],[448,449],[449,346],[346,448],[356,264],[264,454],[454,356],[337,336],[336,299],[299,337],[337,338],[338,151],[151,337],[294,278],[278,455],[455,294],[308,292],[292,415],[415,308],[429,358],[358,355],[355,429],[265,340],[340,372],[372,265],[352,346],[346,280],[280,352],[295,442],[442,282],[282,295],[354,19],[19,370],[370,354],[285,441],[441,295],[295,285],[195,248],[248,197],[197,195],[457,440],[440,274],[274,457],[301,300],[300,368],[368,301],[417,351],[351,465],[465,417],[251,301],[301,389],[389,251],[394,395],[395,379],[379,394],[399,412],[412,419],[419,399],[410,436],[436,322],[322,410],[326,2],[2,393],[393,326],[354,370],[370,461],[461,354],[393,164],[164,267],[267,393],[268,302],[302,12],[12,268],[312,268],[268,13],[13,312],[298,293],[293,301],[301,298],[265,446],[446,340],[340,265],[280,330],[330,425],[425,280],[322,426],[426,391],[391,322],[420,429],[429,437],[437,420],[393,391],[391,326],[326,393],[344,440],[440,438],[438,344],[458,459],[459,461],[461,458],[364,434],[434,394],[394,364],[428,396],[396,262],[262,428],[274,354],[354,457],[457,274],[317,316],[316,402],[402,317],[316,315],[315,403],[403,316],[315,314],[314,404],[404,315],[314,313],[313,405],[405,314],[313,421],[421,406],[406,313],[323,366],[366,361],[361,323],[292,306],[306,407],[407,292],[306,291],[291,408],[408,306],[291,287],[287,409],[409,291],[287,432],[432,410],[410,287],[427,434],[434,411],[411,427],[372,264],[264,383],[383,372],[459,309],[309,457],[457,459],[366,352],[352,401],[401,366],[1,274],[274,4],[4,1],[418,421],[421,262],[262,418],[331,294],[294,358],[358,331],[435,433],[433,367],[367,435],[392,289],[289,439],[439,392],[328,462],[462,326],[326,328],[94,2],[2,370],[370,94],[289,305],[305,455],[455,289],[339,254],[254,448],[448,339],[359,255],[255,446],[446,359],[254,253],[253,449],[449,254],[253,252],[252,450],[450,253],[252,256],[256,451],[451,252],[256,341],[341,452],[452,256],[414,413],[413,463],[463,414],[286,441],[441,414],[414,286],[286,258],[258,441],[441,286],[258,257],[257,442],[442,258],[257,259],[259,443],[443,257],[259,260],[260,444],[444,259],[260,467],[467,445],[445,260],[309,459],[459,250],[250,309],[305,289],[289,290],[290,305],[305,290],[290,460],[460,305],[401,376],[376,435],[435,401],[309,250],[250,392],[392,309],[376,411],[411,433],[433,376],[453,341],[341,464],[464,453],[357,453],[453,465],[465,357],[343,357],[357,412],[412,343],[437,343],[343,399],[399,437],[344,360],[360,440],[440,344],[420,437],[437,456],[456,420],[360,420],[420,363],[363,360],[361,401],[401,288],[288,361],[265,372],[372,353],[353,265],[390,339],[339,249],[249,390],[339,448],[448,255],[255,339]]),F("matrixDataToMatrix",function(v){for(var _=v.getCols(),T=v.getRows(),D=v.getPackedDataList(),X=[],se=0;se<T;se++)X.push(Array(_));for(se=0;se<T;se++)for(var q=0;q<_;q++){var re=v.getLayout()===1?se*_+q:q*T+se;X[se][q]=D[re]}return X}),F("VERSION","0.4.1633559619")}).call(gr);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bi={},bd={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function OT(n,e){Bi[n]=e}function qs(n){if(!(n in Bi)){const t=zT(n);if(t!==null)Bi[n]=t;else return console.log("Could not get context for WebGL version",n),null}const e=Bi[n];return e==null||e.isContextLost()?(delete Bi[n],qs(n)):(e.disable(e.DEPTH_TEST),e.disable(e.STENCIL_TEST),e.disable(e.BLEND),e.disable(e.DITHER),e.disable(e.POLYGON_OFFSET_FILL),e.disable(e.SAMPLE_COVERAGE),e.enable(e.SCISSOR_TEST),e.enable(e.CULL_FACE),e.cullFace(e.BACK),Bi[n])}function BT(n){if(typeof OffscreenCanvas!="undefined"&&n===2)return new OffscreenCanvas(300,150);if(typeof document!="undefined")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function zT(n){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const e=BT(n);return e.addEventListener("webglcontextlost",t=>{t.preventDefault(),delete Bi[n]},!1),n===1?e.getContext("webgl",bd)||e.getContext("experimental-webgl",bd):e.getContext("webgl2",bd)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var sl;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(sl||(sl={}));var rs;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(rs||(rs={}));var yn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(yn||(yn={}));function rl(n,e){return[e,n]}function UT(n,e){return n*e}function Cc(n){const e=Se(n),t=Math.ceil(e/4);return Wu(t)}function Io(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function VT(n,e){const[t,s]=Io(n,e);return t*s*4}function wd(n,e){const t=n;let s,r,i,o,a,l,c,u,h,d;return ee().getNumber("WEBGL_VERSION")===2?(s=t.R32F,r=t.R16F,i=t.RGBA16F,o=t.RGBA32F,a=t.RED,c=4,u=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,r=n.RGBA,i=n.RGBA,o=t.RGBA,a=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:i,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function De(n,e){const t=e();return ee().getBool("DEBUG")&&GT(n),t}function GT(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+jT(n,e))}const WT=596e-10,HT=65504;function XT(n){return!!(ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||WT<Math.abs(n)&&Math.abs(n)<HT)}function jT(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function Mc(n,e){return Tr(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function qT(n,e){const t=Tr(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(De(n,()=>n.shaderSource(t,e)),De(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function KT(n,e){const t=Tr(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(De(n,()=>n.shaderSource(t,e)),De(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw ZT(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const YT=/ERROR: [0-9]+:([0-9]+):/g;function ZT(n,e){const t=YT.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],r=n.split(`
`),i=r.length.toString().length+2,o=r.map((h,d)=>po((d+1).toString(),i)+h);let a=0;for(let h=0;h<o.length;h++)a=Math.max(o[h].length,a);const l=o.slice(0,s-1),c=o.slice(s-1,s),u=o.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${po(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function JT(n){return Tr(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function QT(n,e){if(De(n,()=>n.linkProgram(e)),n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function _d(n,e){if(De(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function eE(n,e){const t=Tr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return De(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),De(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function tE(n,e){const t=Tr(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return De(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),De(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function nE(n){return Tr(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function sE(n,e){const t=ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,r=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+r+".")}}function rE(n){return Tr(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function w3(n,e,t,s,r,i,o){const a=n.getAttribLocation(e,t);return a===-1?!1:(De(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),De(n,()=>n.vertexAttribPointer(a,r,n.FLOAT,!1,i,o)),De(n,()=>n.enableVertexAttribArray(a)),!0)}function iE(n,e,t){uE(n,t),De(n,()=>n.activeTexture(n.TEXTURE0+t)),De(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function oE(n,e,t){return Tr(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function aE(n,e,t){return n.getUniformLocation(e,t)}function lE(n,e,t,s){De(n,()=>iE(n,e,s)),De(n,()=>n.uniform1i(t,s))}function Sd(n,e,t){De(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),De(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function _3(n,e){De(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),De(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function Ac(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+cE(n,e))}function cE(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Tr(n,e,t){const s=De(n,()=>e());if(s==null)throw new Error(t);return s}function uE(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const r=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${r}.`)}}function No(n,e=2){return Se(n.slice(0,n.length-e))}function Lo(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function Td(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[No(n),...Lo(n)]),e}function hE(n,e=!1){let t=ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");e&&(t=t*2,n=n.map((r,i)=>i>=n.length-2?If(n[i]):n[i]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Or(n).newShape);let s=Se(n);if(n.length<=1&&s<=t)return[1,s];if(n.length===2&&n[0]<=t&&n[1]<=t)return n;if(n.length===3&&n[0]*n[1]<=t&&n[2]<=t)return[n[0]*n[1],n[2]];if(n.length===3&&n[0]<=t&&n[1]*n[2]<=t)return[n[0],n[1]*n[2]];if(n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t)return[n[0]*n[1]*n[2],n[3]];if(n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t)return[n[0],n[1]*n[2]*n[3]];if(e){const r=No(n);let i=2,o=2;return n.length&&([i,o]=Lo(n)),s=r*(i/2)*(o/2),Wu(s).map(a=>a*2)}return Wu(s)}function Rc(n){return n%2==0}function Ic(n,e){if(n=n.slice(-2),e=e.slice(-2),Qt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],s=e.slice(-1)[0];if(t===s||Rc(t)&&Rc(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&Rc(n[0])&&Rc(e[0])}let Ed,Cd;function dE(n){if(Ed==null){const e=qs(n);Ed=e.getParameter(e.MAX_TEXTURE_SIZE)}return Ed}function pE(n){if(Cd==null){const e=qs(n);Cd=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Cd)}function fE(n){if(n===0)return 0;let e;const t=qs(n);return ws(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:ws(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function ws(n,e){return n.getExtension(e)!=null}function S3(n){try{if(qs(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function mE(n){if(n===0)return!1;const e=qs(n);if(n===1){if(!ws(e,"OES_texture_float"))return!1}else if(!ws(e,"EXT_color_buffer_float"))return!1;return Md(e)}function gE(n){if(n===0)return!1;const e=qs(n);if(n===1){if(!ws(e,"OES_texture_float")||!ws(e,"WEBGL_color_buffer_float"))return!1}else{if(ws(e,"EXT_color_buffer_float"))return Md(e);const s="EXT_color_buffer_half_float";if(ws(e,s)){const r=e.getExtension(s);return xE(e,r)}return!1}return Md(e)}function Md(n){const e=wd(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const s=1,r=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,s,r,0,e.textureFormatFloat,e.textureTypeFloat,null);const i=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,i),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(i),o}function xE(n,e){const t=wd(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);const r=1,i=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,r,i,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const o=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,o),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(o),a}function yE(n){return n!==2?!1:qs(n).fenceSync!=null}function il(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&O(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ve=ee();Ve.registerFlag("HAS_WEBGL",()=>Ve.getNumber("WEBGL_VERSION")>0);Ve.registerFlag("WEBGL_VERSION",()=>S3(2)?2:S3(1)?1:0);Ve.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Ve.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Ve.get("WEBGL_VERSION")===2);Ve.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Ve.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Ve.registerFlag("WEBGL_PACK",()=>Ve.getBool("HAS_WEBGL"));Ve.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_CLIP",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_PACK_REDUCE",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_LAZILY_UNPACK",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_CONV_IM2COL",()=>Ve.getBool("WEBGL_PACK"));Ve.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>dE(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>pE(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Ve.getNumber("WEBGL_VERSION");return n===0?0:fE(n)});Ve.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Ve.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!B1());Ve.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>mE(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Ve.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Ve.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Ve.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>gE(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_FENCE_API_ENABLED",()=>yE(Ve.getNumber("WEBGL_VERSION")));Ve.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Ve.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Ve.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Ve.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>B1()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Ve.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Ve.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Ve.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Ve.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rn(){let n,e,t,s,r,i,o,a,l,c;return ee().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",r="texture",i="outputColor",o="out vec4 outputColor;",a=`
      bool isnan_custom(float val) {
        return (val > 0.0 || val < 0.0) ? false : val != 0.0;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `,l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",r="texture2D",i="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:r,output:i,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zi(n,e,t="index"){const s=wn(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / ${r}`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * ${r}`:`index -= ${n[i]} * ${r}`;return`${o}; ${a};`}).join("")}function Nc(n,e,t="index"){const s=wn(e);return s.map((r,i)=>{const o=`int ${n[i]} = ${t} / outShapeStrides[${i}]`,a=i===s.length-1?`int ${n[i+1]} = ${t} - ${n[i]} * outShapeStrides[${i}]`:`index -= ${n[i]} * outShapeStrides[${i}]`;return`${o}; ${a};`}).join("")}function vE(n,e){const t=n.length,s=n.map(i=>`${e}[${i}]`),r=new Array(t-1);r[t-2]=s[t-1];for(let i=t-3;i>=0;--i)r[i]=`(${r[i+1]} * ${s[i+1]})`;return r}function bE(n,e,t="index"){const s=n.map((i,o)=>o),r=vE(s,e);return r.map((i,o)=>{const a=`int ${n[o]} = ${t} / ${r[o]}`,l=o===r.length-1?`int ${n[o+1]} = ${t} - ${n[o]} * ${r[o]}`:`index -= ${n[o]} * ${r[o]}`;return`${a}; ${l};`}).join("")}function Ad(n){const e=wn(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function Rd(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const T3=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:E3}=tS;function wE(n,e,t){const s=[];if(n.forEach(p=>{const f=Se(p.shapeInfo.logicalShape);if(p.shapeInfo.isUniform?s.push(`uniform float ${p.name}${f>1?`[${f}]`:""};`):(s.push(`uniform sampler2D ${p.name};`),s.push(`uniform int offset${p.name};`)),t.enableShapeUniforms){const{uniformShape:m}=Id(t.packedInputs,p.shapeInfo.logicalShape,p.shapeInfo.texShape);switch(m.length){case 1:s.push(`uniform int ${p.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${p.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${p.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${p.name}Shape;`);break}s.push(`uniform ivec2 ${p.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(p=>{s.push(`uniform ${p.type} ${p.name}${p.arrayIndex?`[${p.arrayIndex}]`:""};`)});const r=s.join(`
`),i=n.map(p=>_E(p,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),o=e.texShape,a=Rn(),l=EE(a);let c,u,h=AE(a);return e.isPacked?(c=SE(e.logicalShape,o,t.enableShapeUniforms),u=ME(a)):(c=TE(e.logicalShape,o,t.enableShapeUniforms),u=CE(a)),t.packedInputs&&(h+=LE),[h,l,u,r,c,i,t.userCode].join(`
`)}function Po(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return WE(n,e);case 1:return XE(n,e);case 2:return qE(n,e);case 3:return YE(n,e);case 4:return JE(n,e);case 5:return QE(n);case 6:return eC(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function C3(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return GE(n);case 1:return HE(n,e);case 2:return jE(n,e);case 3:return KE(n,e);default:return ZE(n,e)}}function _E(n,e,t=!1,s){let r="";t?r+=C3(n,s):r+=Po(n,s);const i=n.shapeInfo.logicalShape,o=e.logicalShape;return i.length<=o.length&&(t?r+=tC(n,e):r+=nC(n,e)),r}function SE(n,e,t){switch(n.length){case 0:return M3();case 1:return PE(n,e,t);case 2:return UE(n,e,t);case 3:return kE(n,e,t);default:return FE(n,e,t)}}function TE(n,e,t){switch(n.length){case 0:return M3();case 1:return DE(n,e,t);case 2:return VE(n,e,t);case 3:return $E(n,e,t);case 4:return OE(n,e,t);case 5:return BE(n,e);case 6:return zE(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function EE(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function CE(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function ME(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function AE(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${RE}
    ${IE}
    ${NE}
  `}const RE=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,IE=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,NE=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,LE=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function M3(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function PE(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function DE(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function kE(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),i=r*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec3(b, r, c);
    }
  `}function $E(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Nc(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=zi(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function FE(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),i=r*Math.ceil(n[n.length-2]/2);let o=i,a="",l="b, r, c";for(let c=2;c<n.length-1;c++)o*=n[n.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${a}

      int b = index / ${i};
      index -= b * ${i};

      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec${n.length}(${l});
    }
  `}function OE(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Nc(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=zi(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function BE(n,e){const t=zi(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function zE(n,e){const t=zi(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function UE(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Qt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const r=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${r});
      int c = imod(index, ${r}) * 2;

      return ivec2(r, c);
    }
  `}function VE(n,e,t){return Qt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Ui(n){return`offset${n}`}function GE(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=Rn();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function WE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[r,i]=n.shapeInfo.texShape;if(r===1&&i===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Ui(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${o});
      return sampleTexture(${t}, uv);
    }
  `;const[a,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${t}, uv);
    }
  `}function HE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=n.shapeInfo.texShape,i=Rn();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${i.texture2D}(${t}, uv);
    }
  `;const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${i.texture2D}(${t}, uv);
    }
  `}function XE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Do(n)}
      }
    `;const r=n.shapeInfo.texShape,i=r[0],o=r[1];if(o===1&&i===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Ui(t);return o===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${i}.0);
        return sampleTexture(${t}, uv);
      }
    `:i===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${a});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${i}, ${o}, index + ${a});
      return sampleTexture(${t}, uv);
    }
  `}function jE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=i[0],a=i[1],l=Rn();if(i!=null&&Qt(t,i))return e?`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${r}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${r}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function qE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape;if(i!=null&&Qt(t,i)){if(e)return`
      float ${r}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=i[0],p=i[1];return`
    float ${r}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:o,keptDims:a}=Or(t),l=o;if(l.length<t.length){const d=ko(n,l),p=["row","col"];return`
      ${Po(d,e)}
      float ${r}(int row, int col) {
        return ${r}(${$o(p,a)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Do(n)}
      }
    `;const c=i[0],u=i[1],h=Ui(s);return u===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${r}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${r}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${r}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`}function KE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=n.shapeInfo.texShape,o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=ko(n,d),m=["b","row","col"];return`
        ${C3(f,e)}
        vec4 ${r}(int b, int row, int col) {
          return ${r}(${$o(m,p)});
        }
      `}const a=Rn();if(e)return`
    vec4 ${r}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${r}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${a.texture2D}(${s}, uv);
    }
  `}function YE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[1]*t[2],o=t[2],{newShape:a,keptDims:l}=Or(t),c=a;if(c.length<t.length){const m=ko(n,c),y=["row","col","depth"];return`
        ${Po(m,e)}
        float ${r}(int row, int col, int depth) {
          return ${r}(${$o(y,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${i}, ${o}, 1)));
        ${Do(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],d=u[1],p=n.shapeInfo.flatOffset;if(d===i&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${r}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===o&&p==null)return e?`
      float ${r}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${r}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=Ui(s);return e?`
    float ${r}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * ${i} + col * ${o} + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${r}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${i} + col * ${o} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function ZE(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=Rn();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${r.texture2D}(${t}, uv);
    }
  `;const i=n.shapeInfo.logicalShape,o=i.length,a=n.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],h=Math.ceil(i[o-1]/2);let d=h*Math.ceil(i[o-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let m=2;m<o-1;m++)p=`int b${m}, `+p,d*=i[o-m-1],f=`b${m} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${r.texture2D}(${t}, uv);
    }
  `}function JE(n,e){const t=n.shapeInfo.logicalShape,s=n.name,r="get"+s.charAt(0).toUpperCase()+s.slice(1),i=t[3],o=t[2]*i,a=t[1]*o,{newShape:l,keptDims:c}=Or(t);if(l.length<t.length){const x=ko(n,l),b=["row","col","depth","depth2"];return`
      ${Po(x,e)}
      float ${r}(int row, int col, int depth, int depth2) {
        return ${r}(${$o(b,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${i}, 1)));
        ${Do(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,m=`int stride1 = ${s}Shape[2] * stride2;`,y=`int stride0 = ${s}Shape[1] * stride1;`;if(p===a&&u==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        ${f}
        ${m}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===i&&u==null)return e?`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${r}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const g=Ui(s);return e?`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${m}
      ${y}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${g});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${r}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${i} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${g});
      return sampleTexture(${s}, uv);
    }
  `}function QE(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),r=e[4],i=e[3]*r,o=e[2]*i,a=e[1]*o,{newShape:l,keptDims:c}=Or(e);if(l.length<e.length){const m=ko(n,l),y=["row","col","depth","depth2","depth3"];return`
      ${Po(m)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${$o(y,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${i}, ${r})) +
          depth3;
        ${Do(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===a&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${i}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===r&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=Ui(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${i} +
          depth2 * ${r} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function eC(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:r,keptDims:i}=Or(e);if(r.length<e.length){const y=ko(n,r),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${Po(y)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${$o(g,i)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Do(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===o&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const m=Ui(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${m};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Do(n){const e=n.name,t=Se(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function tC(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=n.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=E3(n.shapeInfo.logicalShape,e.logicalShape),l=Dt(o),c=o-i;let u;const h=["x","y","z","w","u","v"];i===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(x=>`coords.${h[x+c]} = 0;`).join(`
`);let d="";o<2&&i>0?d="coords":d=n.shapeInfo.logicalShape.map((x,b)=>`coords.${h[b+c]}`).join(", ");let p="return outputValue;";const m=Se(n.shapeInfo.logicalShape)===1,g=Se(e.logicalShape)===1;if(i===1&&!m&&!g)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(m&&!g)o===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(a.length){const x=i-2,b=i-1;a.indexOf(x)>-1&&a.indexOf(b)>-1?p="return vec4(outputValue.x);":a.indexOf(x)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(b)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${r}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function nC(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),r="get"+s+"AtOutCoords",i=e.texShape,o=n.shapeInfo.texShape,a=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&a===l&&n.shapeInfo.flatOffset==null&&Qt(o,i))return`
      float ${r}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Dt(l),u=E3(n.shapeInfo.logicalShape,e.logicalShape),h=l-a;let d;const p=["x","y","z","w","u","v"];a===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(m=>`coords.${p[m+h]} = 0;`).join(`
`);let f="";return l<2&&a>0?f="coords":f=n.shapeInfo.logicalShape.map((m,y)=>`coords.${p[y+h]}`).join(", "),`
    float ${r}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function Dt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function Id(n,e,t){const{newShape:s,keptDims:r}=Or(e),i=e.length,o=n&&i===3&&e[0]===1,a=o?e.slice(1):s,l=!n&&i>1&&!Qt(e,t)&&s.length<i||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:r}}function ko(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function $o(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sC(n,e,t,s){const r=t.map((w,C)=>{const M={logicalShape:w.shape,texShape:w.isUniform?null:w.texData.texShape,isUniform:w.isUniform,isPacked:w.isUniform?!1:w.texData.isPacked,flatOffset:null};return w.texData!=null&&w.texData.slice!=null&&w.texData.slice.flatOffset>0&&(M.flatOffset=w.texData.slice.flatOffset),{name:e.variableNames[C],shapeInfo:M}}),i=r.map(w=>w.shapeInfo),o={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},a=wE(r,o,e),l=KT(n.gl,a),c=n.createProgram(l);let u=null;const h=n.getUniformLocation(c,"NAN",!1);ee().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(c,"INFINITY",!1));const d=!1,p={},f={},m={};for(let w=0;w<e.variableNames.length;w++){const C=e.variableNames[w];p[C]=n.getUniformLocation(c,C,d),p[`offset${C}`]=n.getUniformLocation(c,`offset${C}`,d),e.enableShapeUniforms&&(f[`${C}Shape`]=n.getUniformLocation(c,`${C}Shape`,d),m[`${C}TexShape`]=n.getUniformLocation(c,`${C}TexShape`,d))}let y,g,x;e.enableShapeUniforms&&(y=n.getUniformLocation(c,"outShape",d),x=n.getUniformLocation(c,"outShapeStrides",d),g=n.getUniformLocation(c,"outTexShape",d));const b=[];return e.customUniforms&&e.customUniforms.forEach((w,C)=>{b[C]=n.getUniformLocation(c,w.name,d)}),{program:e,fragmentShader:l,source:a,webGLProgram:c,uniformLocations:p,customUniformLocations:b,inShapeInfos:i,outShapeInfo:o,infLoc:u,nanLoc:h,inShapesLocations:f,inTexShapesLocations:m,outShapeLocation:y,outShapeStridesLocation:x,outTexShapeLocation:g}}function A3(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const r=t.logicalShape,i=e[s],o=i.shape;if(!Qt(r,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${r} and ${o} must match`);if(t.isUniform&&i.isUniform)return;const a=t.texShape,l=i.isUniform?null:i.texData.texShape;if(!Qt(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function rC(n,e,t,s,r){e.program.enableShapeUniforms||(A3(e.inShapeInfos,t),A3([e.outShapeInfo],[s]));const i=s.texData.texture,o=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(i,o[0],o[1]):n.setOutputMatrixTexture(i,o[0],o[1]),n.setProgram(e.webGLProgram),ee().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((l,c)=>{const u=e.program.variableNames[c],h=e.uniformLocations[u],d=e.uniformLocations[`offset${u}`],p=e.inShapesLocations[`${u}Shape`],f=e.inTexShapesLocations[`${u}TexShape`];if(p){const{uniformShape:m}=Id(e.program.packedInputs,l.shape,l.texData.texShape);switch(m.length){case 1:n.gl.uniform1iv(p,new Int32Array(m));break;case 2:n.gl.uniform2iv(p,new Int32Array(m));break;case 3:n.gl.uniform3iv(p,new Int32Array(m));break;case 4:n.gl.uniform4iv(p,new Int32Array(m));break}}if(f&&n.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(Se(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let m=l.uniformValues;m instanceof Float32Array||(m=new Float32Array(m)),n.gl.uniform1fv(h,m)}return}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture,h,c)}});const a=e.outShapeLocation;if(a)switch(s.shape.length){case 1:n.gl.uniform1iv(a,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(a,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(a,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(a,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=wn(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&r&&e.program.customUniforms.forEach((l,c)=>{const u=e.customUniformLocations[c],h=r[c];if(l.type==="float")n.gl.uniform1fv(u,h);else if(l.type==="vec2")n.gl.uniform2fv(u,h);else if(l.type==="vec3")n.gl.uniform3fv(u,h);else if(l.type==="vec4")n.gl.uniform4fv(u,h);else if(l.type==="int")n.gl.uniform1iv(u,h);else if(l.type==="ivec2")n.gl.uniform2iv(u,h);else if(l.type==="ivec3")n.gl.uniform3iv(u,h);else if(l.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}),n.executeProgram()}function iC(n,e,t){let s="";e.concat(t).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=Id(n.packedInputs,o.shape,l);let d="",p="",f="";if(u.length===1&&n.packedInputs){const C=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${C[0]>1}_${C[1]>1}`}else if(u.length===2&&!n.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const C=wn(u);f=`${C[0]===l[1]}_${C[C.length-1]===l[1]}`}const m=o.shape.length,y=u.length===2&&Qt(o.shape,l),g=Se(o.shape)===1,x=ac(o.shape,t.shape),b=!n.packedInputs&&m===t.shape.length&&Qt(l,t.texData.texShape),w=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${m}_${b}_${c?h:""}_${u.length}_${g}_${x}_${y}_${d}_${p}_${f}_${w}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;s+=`${o.shape}_${l}_${a}`}});const r=n.userCode;let i=n.constructor.name;return i+="_"+s+"_"+r+`${ee().getNumber("WEBGL_VERSION")}`,i}function Un(n){return ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oC{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=sl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Rn();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Nc(["r","c","d"],e):zi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=sl.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=Rn();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Nc(["r","c","d"],e):zi(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lC{constructor(e){this.variableNames=["A"],this.outTexUsage=rs.DOWNLOAD;const t=Rn();this.outputShape=e,this.userCode=`
      ${T3}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=rs.DOWNLOAD;const t=Rn();this.outputShape=e,this.userCode=`
      ${T3}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uC{constructor(e,t=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Rn();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?Rd():Ad(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${s.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${s.output} = vec4(${r}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hC{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=Rn();this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let r="",i="result";t&&(i="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;r+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?Rd():Ad(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${r}

          ${s.output} = ${i};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dC(n){const e=Rn(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return qT(n,t)}function pC(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return eE(n,e)}function fC(n){const e=new Uint16Array([0,1,2,2,1,3]);return tE(n,e)}function ol(n,e,t,s,r,i){sE(e,t);const o=nE(n),a=n.TEXTURE_2D;return De(n,()=>n.bindTexture(a,o)),De(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),De(n,()=>n.texParameteri(a,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),De(n,()=>n.texParameteri(a,n.TEXTURE_MIN_FILTER,n.NEAREST)),De(n,()=>n.texParameteri(a,n.TEXTURE_MAG_FILTER,n.NEAREST)),ee().getNumber("WEBGL_VERSION")===1?De(n,()=>n.texImage2D(a,0,s,e,t,0,r,i,null)):De(n,()=>n.texStorage2D(a,1,s,e,t)),De(n,()=>n.bindTexture(n.TEXTURE_2D,null)),o}function R3(n){return n.internalFormatFloat}function mC(n,e,t,s){const[r,i]=rl(e,t);return ol(n,r,i,R3(s),s.textureFormatFloat,n.FLOAT)}function I3(n){return n.internalFormatHalfFloat}function gC(n,e,t,s){const[r,i]=rl(e,t);return ol(n,r,i,I3(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function N3(n){return n.downloadTextureFormat}function xC(n,e,t,s){const[r,i]=rl(e,t);return ol(n,r,i,N3(s),n.RGBA,n.UNSIGNED_BYTE)}function L3(n){return n.internalFormatPackedFloat}function yC(n,e,t,s){const[r,i]=Io(e,t);return ol(n,r,i,L3(s),n.RGBA,n.FLOAT)}function P3(n){return n.internalFormatPackedHalfFloat}function vC(n,e,t,s){const[r,i]=Io(e,t);return ol(n,r,i,P3(s),n.RGBA,s.textureTypeHalfFloat)}function bC(n,e,t){const s=0,r=3*4,i=3*4+2*4;return De(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),w3(n,e,"clipSpacePos",t,3,i,s)&&w3(n,e,"uv",t,2,i,r)}function wC(n,e,t,s,r,i){De(n,()=>n.bindTexture(n.TEXTURE_2D,e));let o,a,l;r instanceof Uint8Array?(o=new Uint8Array(t*s*4),a=n.UNSIGNED_BYTE,l=n.RGBA):(o=new Float32Array(t*s*4),a=n.FLOAT,l=i.internalFormatPackedFloat),o.set(r),ee().getNumber("WEBGL_VERSION")===2?De(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,a,o)):De(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,a,o)),De(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function _C(n,e,t){De(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ee().getNumber("WEBGL_VERSION")===2?(De(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)),n.flush()):De(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ee().getNumber("WEBGL_VERSION")===2?(De(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)),n.flush()):De(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),De(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function SC(n,e,t,s){const r=n.createBuffer();De(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,r));const a=4*4*e*t;return De(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,a,n.STREAM_READ)),De(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),De(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),r}function TC(n,e,t){const s=n,r=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,r),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),r}function EC(n,e,t,s){const[r,i]=rl(e,t),o=4,a=new Uint8Array(UT(e*t,o));return De(n,()=>n.readPixels(0,0,r,i,s.downloadTextureFormat,n.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function CC(n,e,t,s,r,i,o,a){const l=n,c=new Float32Array(VT(i,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function MC(n,e,t){const s=new Float32Array(e*t*4);return De(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AC{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const t=ee().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,OT(t,e)):this.gl=qs(t);let s="WEBGL_color_buffer_float";const r="EXT_color_buffer_half_float";if(ee().getNumber("WEBGL_VERSION")===1){const i="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=Mc(this.gl,i),ws(this.gl,o))this.textureHalfFloatExtension=Mc(this.gl,o);else if(ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),ws(this.gl,r))this.colorBufferHalfFloatExtension=Mc(this.gl,r);else if(ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",ws(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(ws(this.gl,r))this.colorBufferHalfFloatExtension=this.gl.getExtension(r);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=pC(this.gl),this.indexBuffer=fC(this.gl),this.framebuffer=rE(this.gl),this.textureConfig=wd(this.gl,this.textureHalfFloatExtension)}get debug(){return ee().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;De(e,()=>e.finish()),De(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),De(e,()=>e.deleteFramebuffer(this.framebuffer)),De(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),De(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),De(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),mC(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),gC(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),xC(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),_C(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,r){this.throwIfDisposed(),wC(this.gl,e,t,s,r,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),vC(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),yC(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(_3(this.gl,this.framebuffer),this.outputTexture=null),De(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>EC(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,r,i,o){return CC(this.gl,e,t,s,r,i,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return TC(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const r=SC(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),r}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ee().getBool("WEBGL_FENCE_API_ENABLED")){const r=e,i=r.fenceSync(r.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const o=r.clientWaitSync(i,0,0);return o===r.ALREADY_SIGNALED||o===r.CONDITION_SATISFIED},t=i}else ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>MC(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=dC(t));const s=JT(t);return De(t,()=>t.attachShader(s,this.vertexShader)),De(t,()=>t.attachShader(s,e)),QT(t,s),this.debug&&_d(t,s),this.vertexAttrsAreBound||(this.setProgram(s),this.vertexAttrsAreBound=bC(t,this.program,this.vertexBuffer)),s}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&De(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&_d(this.gl,this.program),De(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?oE(this.gl,e,t):aE(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),De(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),lE(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[r,i]=Io(t,s);this.setOutputMatrixTextureDriver(e,r,i)}setOutputMatrixWriteRegion(e,t,s,r){this.setOutputMatrixWriteRegionDriver(s,e,r,t)}setOutputPackedMatrixWriteRegion(e,t,s,r){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&_d(this.gl,this.program),Ac(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),De(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),De(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=Mc(this.gl,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.createQuery();return s.beginQuery(r.TIME_ELAPSED_EXT,i),i}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await Nf(()=>this.disposed||this.isQueryAvailable(e,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,r=this.getQueryTimerExtensionWebGL2(),i=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),r=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),r&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=RC(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),!(this.itemsToPoll.length>1)&&Nf(()=>(this.pollItems(),this.itemsToPoll.length===0))}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Sd(this.gl,e,this.framebuffer),this.debug&&Ac(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Sd(this.gl,this.outputTexture,this.framebuffer),this.debug&&Ac(this.gl)):_3(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const r=this.gl;Sd(r,e,this.framebuffer),this.debug&&Ac(r),this.outputTexture=e,De(r,()=>r.viewport(0,0,t,s)),De(r,()=>r.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,r){this.throwIfDisposed(),De(this.gl,()=>this.gl.scissor(e,t,s,r))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function RC(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IC(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _s(n){return(e,t,s,r,i)=>{const o=Ct(e,t),a=o.length,l=wn(o),c=Se(o),u=Br(i,c),h=e.length,d=t.length,p=wn(e),f=wn(t),m=ac(e,o),y=ac(t,o);if(m.length+y.length===0)for(let g=0;g<u.length;++g)u[g]=n(s[g%s.length],r[g%r.length]);else for(let g=0;g<u.length;++g){const x=$f(g,a,l),b=x.slice(-h);m.forEach(E=>b[E]=0);const w=qu(b,h,p),C=x.slice(-d);y.forEach(E=>C[E]=0);const M=qu(C,d,f);u[g]=n(s[w],r[M])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NC=_s((n,e)=>n+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LC(n,e,t,s,r){const i=Se(s),o=zr(r,t);for(let a=0;a<n.length;a++){const l=n[a];if(l<0)throw new Error("Input x must be non-negative!");l>=r||(i>0?o[l]+=e[a]:o[l]+=1)}return o}function PC(n,e,t,s=!1){const r=n.shape[0],i=n.shape[1],o=xn([r,t],e.dtype);for(let a=0;a<r;a++)for(let l=0;l<i;l++){const c=n.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kr(n){return(e,t,s)=>{const r=Br(t,e.length);for(let i=0;i<e.length;++i)r[i]=n(e[i],s);return r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DC=Kr(n=>Math.ceil(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kC(n,e,t,s){const r=cs(t,Se(e));if(s&&t!=="string"){let i=0;n.forEach(o=>{const a=Se(o.shape);r.set(o.vals,i),i+=a})}else{let i=0;n.forEach(o=>{const a=t==="string"?el(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+i;for(let h=0;h<o.shape[1];++h)r[u+h]=a[l++]}i+=o.shape[1]})}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $C=_s((n,e)=>n===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FC=Kr(n=>Math.exp(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OC=Kr(n=>Math.expm1(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BC=Kr(n=>Math.floor(n));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zC(n,e,t,s,r,i,o,a,l){const c=xn([s,i],t);for(let u=0;u<s;u++){const h=[];let d=0;for(let p=0;p<r;p++){const f=n[u*r+p];d+=f*o[p],h.push(f)}if(d<0||d>=l/i)throw new Error(`Invalid indices: ${h} does not index into ${a}`);for(let p=0;p<i;p++)c.values[u*i+p]=e.get(...e.indexToLoc(d*i+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UC(n,e,t){const s=xn(t,n.dtype);for(let r=0;r<s.size;++r){const o=s.indexToLoc(r).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=n.locToIndex(o);s.values[r]=n.values[u]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VC=_s((n,e)=>n>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GC=_s((n,e)=>n>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WC=_s((n,e)=>n<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HC=_s((n,e)=>n<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XC(n,e,t){const s=(e-n)/(t-1),r=zr(t,"float32");r[0]=n;for(let i=1;i<r.length;i++)r[i]=r[i-1]+s;return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jC=Kr(n=>Math.log(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qC(n,e,t,s){const r=Br(s,Se(t));for(let i=0;i<r.length;++i){const o=i*e;let a=n[o];for(let l=0;l<e;++l){const c=n[o+l];(Number.isNaN(c)||c>a)&&(a=c)}r[i]=a}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KC=_s((n,e)=>Math.max(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YC=_s((n,e)=>Math.min(n,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3=_s((n,e)=>n*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZC(n,e,t){const s=go(-1,t);return D3([],e,s,n,t)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JC=_s((n,e)=>n!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QC(n,e,t,s,r){const i=e.length,o=Se(e),a=wn(e),l=wn(r),c=Br(t,Se(r));for(let u=0;u<o;++u){const h=$f(u,i,a),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];const p=qu(d,i,l);c[p]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eM(n,e,t,s){const[r,i]=Xs(n,s),o=Hs(e,"int32"),a=zr(Se(r),o),l=Se(i);for(let c=0;c<a.length;++c){const u=c*l;let h=1;for(let d=0;d<l;++d)h*=t[u+d];a[c]=h}return{outVals:a,outShape:r,outDtype:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(n,e,t,s){const r=n===e,i=n<e&&t<0,o=e<n&&t>1;if(r||i||o)return zr(0,s);const a=Math.abs(Math.ceil((e-n)/t)),l=zr(a,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nM=Kr(n=>1/Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sM=Kr(n=>1/(1+Math.exp(-n)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rM(n,e,t,s,r){const i=Ah(s,e,t),o=Se(t),a=wn(s);if(i){const h=Rh(e,a);return r==="string"?n.slice(h,h+o):n.subarray(h,h+o)}const l=r==="string"?el(n):n,c=xn(s,r,l),u=xn(t,r);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),p=d.map((f,m)=>f+e[m]);u.set(c.get(...p),...d)}return r==="string"?Yg(u.values):u.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iM(n,e,t,s,r,i,o){const a=e[0],l=i[0],c=new Array(l),u=new Array(a),h=e[1];if(l===0){if(a!==0)throw new Error($g(a));const y=cs(t,0),g=cs(r,0);return[y,[0,h],g,c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let y=0;y<a;++y){const g=n[y*h];if(g<0)throw new Error(Fg(y,g));if(g>=l)throw new Error(Og(y,g,l));++f[g],d=d&&g>=p,p=g}let m=!0;for(let y=0;y<l;++y){const g=f[y]===0;c[y]=g,m=m&&!g,f[y]=Math.max(f[y],1),y>0&&(f[y]+=f[y-1])}if(m&&d){const y=n,g=s;for(let x=0;x<a;++x)u[x]=x;return[y,[a,h],g,c,u]}else{const y=f[l-1],g=cs(t,y*h),x=cs(r,y),b=new Array(l).fill(0);for(let w=0;w<a;++w){const C=n[w*h],M=b[C],E=(C===0?0:f[C-1])+M;b[C]++;for(let A=0;A<h;++A)g[E*h+A]=n[w*h+A];x[E]=s[w],u[w]=E}for(let w=0;w<l;++w)if(b[w]===0){const M=w===0?0:f[w-1];g[M*h+0]=w;for(let E=1;E<h;++E)g[M*h+E]=0;x[M]=o}return[g,[y,h],x,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oM(n,e,t,s,r){const i=Se(s),o=e[0],a=r.length,l=[];let c=1,u=-1;for(let y=0;y<a;++y){const g=r[y];if(g===-1){if(u!==-1)throw new Error(Bg(u,y));u=y,l.push(1)}else{if(g<0)throw new Error(zg(y,g));c*=g,l.push(g)}}if(u!==-1){if(c<=0)throw new Error(Ug());const y=Math.trunc(i/c);if(c*y!==i)throw new Error(Vg(s,l));l[u]=y}if(Se(l)!==i)throw new Error(Gg(s,l));const d=s.length,p=[];if(d>0){p[d-1]=1;for(let y=d-2;y>=0;--y)p[y]=p[y+1]*s[y+1]}const f=[];if(a>0){f[a-1]=1;for(let y=a-2;y>=0;--y)f[y]=f[y+1]*l[y+1]}const m=cs(t,o*a);for(let y=0;y<o;++y){let g=0;for(let x=0;x<d;++x)g+=n[y*d+x]*p[x];for(let x=0;x<a;++x)m[y*a+x]=Math.trunc(g/f[x]),g%=f[x]}return[m,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aM(n,e,t,s,r,i=!1,o=0){const a=s.length,l=[e[0],n.length/e[0]],c=l[1],h=a>0?r[a-1]+1:0;if(h<0)throw new Error(Qh());const d=e.slice();d[0]=h;const p=d.reduce((b,w)=>b*w,1),f=cs(t,p);if(a===0)return h>0&&f.fill(o),[f,d];if(h<=0)throw new Error(Qh());let m=0,y=1,g=0,x=r[m];for(;;){let b=0;if(y<a){if(b=r[y],x===b){++y;continue}if(x>=b)throw new Error(Wg())}if(x<0||x>=h)throw new Error(Hg(x,h));x>g&&f.fill(o,g*c,x*c);for(let w=m;w<y;++w){const C=s[w];if(C<0||C>=l[0])throw new Error(Xg(w,s[w],l[0]));for(let M=0;M<c;M++)f[x*c+M]+=n[C*c+M]}if(i)for(let w=0;w<c;w++)f[x*c+w]/=y-m;if(m=y,++y,g=x+1,x=b,y>a)break}return g<h&&f.fill(o,g*c,h*c),[f,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lM=Kr(n=>Math.sqrt(n));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cM=_s((n,e)=>{const t=n-e;return t*t});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(n,e,t,s){const r=xn(n,e.dtype);for(let i=0;i<r.size;i++){const o=r.indexToLoc(i),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*t[l]+s[l];r.set(e.get(...a),...o)}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hM{constructor(e,t,s,r,i,o){this.separator=Ti(e),this.nGramWidths=t,this.leftPad=Ti(s),this.rightPad=Ti(r),this.padWidth=i,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,r,i,o){for(let a=0;a<i;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(i-(a+1))),h=o-(c+u),d=t+(c>0?0:a-l);let p=0;p+=c*this.leftPad.length;for(let x=0;x<h;++x)p+=e[d+x].length;p+=u*this.rightPad.length,p+=(c+u+h-1)*this.separator.length,s[r+a]=new Uint8Array(p);const m=s[r+a];let y=0;const g=x=>x.forEach(b=>m[y++]=b);for(let x=0;x<c;++x)g(this.leftPad),g(this.separator);for(let x=0;x<h-1;++x)g(e[d+x]),g(this.separator);if(h>0){g(e[d+h-1]);for(let x=0;x<u;++x)g(this.separator),g(this.rightPad)}else{for(let x=0;x<u-1;++x)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const s=e.length,r=t.length;if(r>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<r;++c){let u=t[c]>=l;if(u=u&&t[c]<=s,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const i=r-1,o=cs("int32",r);if(s===0||r===0){const l=new Array(s);for(let c=0;c<=i;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=i;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[i]);for(let l=0;l<i;++l){const c=t[l];let u=o[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,c,a,u,p,h),u+=p}),this.preserveShort&&u===o[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth,p=1;this.createNGrams(e,c,a,u,p,d)}}return[a,o]}}function dM(n,e,t,s,r,i,o,a){return new hM(t,s,r,i,o,a).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(n,e,t,s){if(!n.length)return;if(e.length===0){for(let i=0;i<n.length;++i)s.push(n.subarray(i,i+1));return}if(e.length===1){const i=e[0];let o=n.indexOf(i);for(;o!==-1;){const a=n.subarray(0,o);(!t||a.length!==0)&&s.push(a),n=n.subarray(o+1),o=n.indexOf(i)}(!t||n.length!==0)&&s.push(n);return}let r=0;for(let i=0;i<n.length+1;i++)if(i===n.length||e.indexOf(n[i])!==-1){const o=n.subarray(r,i);(!t||o.length!==0)&&s.push(o),r=i+1}}function fM(n,e,t){const s=n.length,r=[];let i=0,o=0;const a=new Array(s);for(let d=0;d<s;++d){const p=r.length;pM(n[d],e,t,r);const f=r.length-p;a[d]=f,i+=f,o=Math.max(o,f)}const l=cs("int32",i*2),c=new Array(i),u=[s,o];let h=0;for(let d=0;d<s;++d)for(let p=0;p<a[d];++p)l[h*2]=d,l[h*2+1]=p,c[h]=r[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mM(n,e){const t=cs("int32",n.length);for(let s=0;s<n.length;++s)t[s]=Q9(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gM=_s((n,e)=>n-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xM(n,e){const t=new Array(n.rank);for(let r=0;r<t.length;r++)t[r]=n.shape[r]*e[r];const s=xn(t,n.dtype);for(let r=0;r<s.values.length;++r){const i=s.indexToLoc(r),o=new Array(n.rank);for(let l=0;l<o.length;l++)o[l]=i[l]%n.shape[l];const a=n.locToIndex(o);s.values[r]=n.values[a]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const al=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function k3(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const a=s-t+1,l=e-t+1,c=Math.log(a),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),d=Math.max(t,Math.floor(e-l*u/a+h)),p=Math.min(s,Math.floor(e+(a-l)*u/a+h));k3(n,e,d,p)}const r=n[e];let i=t,o=s;for(ka(n,t,e),al(n[s],r)>0&&ka(n,t,s);i<o;){for(ka(n,i,o),i++,o--;al(n[i],r)<0;)i=i+1;for(;al(n[o],r)>0;)o=o-1}al(n[t],r)===0?ka(n,t,o):(o=o+1,ka(n,o,s)),o<=e&&(t=o+1),e<=o&&(s=o-1)}}function yM(n,e,t,s,r){const i=e[e.length-1],[o,a]=[n.length/i,i],l=Br(t,o*s),c=Br("int32",o*s);for(let h=0;h<o;h++){const d=h*a,p=n.subarray(d,d+a);let f=new Array(p.length);p.forEach((x,b)=>f[b]={value:x,index:b}),s<f.length&&(k3(f,s),f=f.slice(0,s)),r&&f.sort(al);const m=h*s,y=l.subarray(m,m+s),g=c.subarray(m,m+s);for(let x=0;x<s;x++)y[x]=f[x].value,g[x]=f[x].index}const u=e.slice();return u[u.length-1]=s,[xn(u,t,l),xn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vM(n,e,t,s){const r=gn(e,t)[0],i=[1,t[0],1];for(let f=0;f<r;f++)i[0]*=t[f];i[1]=t[r];for(let f=r+1;f<t.length;f++)i[2]*=t[f];const o={},a=new Int32Array(t[r]),l=new Va(i,s,n),c=[],u=i[0]===1&&i[2]===1;for(let f=0;f<t[r];f++){let m;if(u)m=n[f].toString();else{const y=[];for(let g=0;g<i[0];g++)for(let x=0;x<i[2];x++)y.push(l.get(g,f,x));m=y.join(",")}if(o[m]!==void 0)a[f]=o[m];else{const y=Object.keys(o).length;o[m]=y,a[f]=y,c.push(f)}}const h=i.slice();h[1]=Object.keys(o).length;const d=new Va(h,s);c.forEach((f,m)=>{for(let y=0;y<i[0];y++)for(let g=0;g<i[2];g++)d.set(l.get(y,f,g),y,m,g)});const p=t.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var bM=Object.freeze({__proto__:null,[Symbol.toStringTag]:"Module",simpleAbsImpl:IC,addImpl:NC,bincountImpl:LC,bincountReduceImpl:PC,ceilImpl:DC,concatImpl:kC,equalImpl:$C,expImpl:FC,expm1Impl:OC,floorImpl:BC,gatherNdImpl:zC,gatherV2Impl:UC,greaterImpl:VC,greaterEqualImpl:GC,lessImpl:WC,lessEqualImpl:HC,linSpaceImpl:XC,logImpl:jC,maxImpl:qC,maximumImpl:KC,minimumImpl:YC,multiplyImpl:D3,negImpl:ZC,notEqualImpl:JC,prodImpl:eM,rangeImpl:tM,rsqrtImpl:nM,sigmoidImpl:sM,sliceImpl:rM,sparseFillEmptyRowsImpl:iM,sparseReshapeImpl:oM,sparseSegmentReductionImpl:aM,sqrtImpl:lM,squaredDifferenceImpl:cM,stridedSliceImpl:uM,stringNGramsImpl:dM,stringSplitImpl:fM,stringToHashBucketFastImpl:mM,subImpl:gM,tileImpl:xM,topKImpl:yM,transposeImpl:QC,uniqueImpl:vM});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:wM,bincountImpl:$3,bincountReduceImpl:_M,ceilImpl:SM,concatImpl:TM,equalImpl:EM,expImpl:CM,expm1Impl:MM,floorImpl:AM,gatherNdImpl:RM,gatherV2Impl:IM,greaterImpl:NM,greaterEqualImpl:LM,lessImpl:PM,lessEqualImpl:DM,linSpaceImpl:kM,logImpl:$M,maxImpl:FM,maximumImpl:OM,minimumImpl:BM,multiplyImpl:zM,negImpl:UM,notEqualImpl:VM,prodImpl:GM,rangeImpl:WM,rsqrtImpl:HM,sigmoidImpl:XM,simpleAbsImpl:F3,sliceImpl:jM,sparseFillEmptyRowsImpl:qM,sparseReshapeImpl:KM,sparseSegmentReductionImpl:O3,sqrtImpl:YM,stridedSliceImpl:ZM,stringNGramsImpl:JM,stringSplitImpl:QM,stringToHashBucketFastImpl:eA,subImpl:tA,tileImpl:nA,topKImpl:sA,transposeImpl:Nd,uniqueImpl:rA}=bM;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B3(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function In(n,e){return e===1?[n]:B3(n,e)}function iA(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oA{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Un(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=In("rc",this.rank),s=Dt(this.rank),r=this.getOutOfBoundsCondition(t),i=this.getSetup(t),o=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${r}) {
            setOutput(vec4(0));
          } else {
            ${i}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let r=0;r<=1;r++){let i=`${s===0?"r":"rp1"}, ${r===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)i=`${e[e.length-1-o]},`+i;t.push(i)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],r=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${r};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc),
              rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1),
              0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class z3{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);let s="";for(let r=0;r<4;r++){let i="thisRC = rc;";r%2==1&&(i+="thisRC.z += 1;"),r>1&&(i+="thisRC.y += 1;"),s+=`
        ${i}
        ${r>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${r}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${r>0?"}":""}
      `}this.userCode=`
      ${aA(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?Rd():Ad(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function aA(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?bE(["r","c","d"],"inputShape"):zi(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lA{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,s){const r=V3(t,s),i=G3(e,r,s);i in this.freeTextures||(this.freeTextures[i]=[]),i in this.usedTextures||(this.usedTextures[i]=[]);const o=U3(e,r,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[i].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[i].shift();return this.usedTextures[i].push(l),l}let a;return r===yn.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):r===yn.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):r===yn.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):r===yn.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):r===yn.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[i].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,t,s,r){if(this.freeTextures==null)return;const i=V3(s,r),o=G3(t,i,r);o in this.freeTextures||(this.freeTextures[o]=[]);const a=U3(t,i,this.gpgpu.gl,this.gpgpu.textureConfig,r),l=ee().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function cA(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function U3(n,e,t,s,r){const i=uA(e,s);let o;if(r){const[l,c]=Io(n[0],n[1]);o=l*c}else{const[l,c]=rl(n[0],n[1]);o=l*c}const a=cA(t,i);return o*a}function uA(n,e){switch(n){case yn.PACKED_2X2_FLOAT32:return L3(e);case yn.PACKED_2X2_FLOAT16:return P3(e);case yn.UNPACKED_FLOAT32:return R3(e);case yn.UNPACKED_FLOAT16:return I3(e);case yn.PACKED_4X1_UNSIGNED_BYTE:return N3(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function hA(n){return ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?yn.PACKED_2X2_FLOAT32:yn.UNPACKED_FLOAT32:n?yn.PACKED_2X2_FLOAT16:yn.UNPACKED_FLOAT16}function V3(n,e){if(n===rs.UPLOAD)return yn.PACKED_2X2_FLOAT32;if(n===rs.RENDER||n==null)return hA(e);if(n===rs.DOWNLOAD||n===rs.PIXELS)return yn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function G3(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yr{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const ks="if (isnan(x)) return x;",dA="return x;",W3="return abs(x);",pA="return (x >= 0.0) ? x : (exp(x) - 1.0);",fA=ks+`
  return (x < 0.0) ? 0.0 : x;
`,mA=ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Lc="return x;",gA="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xA="return x;",yA=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,vA=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,bA=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,wA="return 1.0 / (1.0 + exp(-1.0 * x));";class Fo{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _A{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);const t=e.length,s=In("rc",t),r=Dt(t),i=iA(t,s),o=s.slice(-2),a=t<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${r} rc = getOutputCoords();
        vec4 packedInput = getA(${i});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SA=og,TA=1e-7,EA=1e-4,Pc={};function CA(n){return n in Pc||(Pc[n]={}),Pc[n]}const MA=ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),AA=600;function RA(){return ee().global.screen==null?1024:ee().global.screen.height*ee().global.screen.width*window.devicePixelRatio*AA/1024/1024}class Dc extends Rf{constructor(e){super();if(this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");if(e==null){const t=qs(ee().getNumber("WEBGL_VERSION"));this.binaryCache=CA(ee().getNumber("WEBGL_VERSION")),this.gpgpu=new AC(t),this.canvas=t.canvas,this.gpgpuCreatedLocally=!0}else this.gpgpu=e,this.binaryCache={},this.gpgpuCreatedLocally=!1,this.canvas=e.gl.canvas;this.textureManager=new lA(this.gpgpu),this.numMBBeforeWarning=RA(),this.texData=new f9(this,Ha())}nextDataId(){return Dc.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,t,s){if((ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ee().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const r={id:this.nextDataId()};return this.texData.set(r,{shape:t,dtype:s,values:e,usage:rs.UPLOAD,refCount:1}),r}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,r,i){if(ee().getBool("DEBUG")&&this.checkNumericalProblems(t),r==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:r,values:t,usage:rs.UPLOAD,refCount:i})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:r,complexTensorInfos:i,slice:o,shape:a,isPacked:l}=t;if(o!=null){let d;l?d=new Fo(a,Lc):d=new Yr(a,Lc);const p=this.runWebGLProgram(d,[{dataId:e,shape:a,dtype:r}],r),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(r==="string")return s;const c=this.activeTimers!=null;let u;c&&(u=Ns());let h;if(r==="complex64"){const d=this.readSync(i.real.dataId),p=this.readSync(i.imag.dataId);h=Zh(d,p)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Ns()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(m=>f.push(m))}const t=this.texData.get(e),{values:s,shape:r,slice:i,dtype:o,complexTensorInfos:a,isPacked:l}=t;if(i!=null){let f;l?f=new Fo(r,Lc):f=new Yr(r,Lc);const m=this.runWebGLProgram(f,[{dataId:e,shape:r,dtype:o}],o),y=this.read(m.dataId);return this.disposeIntermediateTensorInfo(m),y}if(s!=null)return this.convertAndCacheOnCPU(e);if(ee().getBool("DEBUG")&&!ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ee().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&ee().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture,...Cc(r))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(o==="complex64"){const f=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),m=f[0],y=f[1];h=Zh(m,y)}else if(c==null)h=this.getValuesFromTexture(e);else{const f=Se(r);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const f=this.gpgpu.gl;De(f,()=>f.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ha().removeDataId(e,this),this.pendingDeletes--),d}bufferSync(e){const t=this.readSync(e.dataId);let s=t;if(e.dtype==="string")try{s=t.map(r=>Oa(r))}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return xn(e.shape,e.dtype,s)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!XT(s))throw ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:r}=this.texData.get(e),i=Se(t);if(ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture,...Cc(t)).subarray(0,i);return this.disposeIntermediateTensorInfo(d),f}const o=ee().getBool("WEBGL_PACK")&&r===!0,a=o?Td(t):t,l=o?new cC(a):new lC(a),c=this.runWebGLProgram(l,[{shape:a,dtype:s,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture,u.texShape[0],u.texShape[1]).subarray(0,i);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}async time(e){const t=this.activeTimers,s=[];let r=!1;this.programTimersStack==null?(this.programTimersStack=s,r=!0):this.activeTimers.push(s),this.activeTimers=s,e();const i=ho(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=ho(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,r&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(i);a.kernelMs=m9(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Ns(),endMs:null}}endTimer(e){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Ns(),e)}async getQueryTime(e){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:r,usage:i,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(r,s),this.textureManager.releaseTexture(t,r,i,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=MA){return ee().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&Se(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Rs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return SA(e.shape,t)}packedUnaryOp(e,t,s){const r=new Fo(e.shape,t),i=this.compileAndRun(r,[e],s);return Ha().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const r=F3(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,r)}if(ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,W3,e.dtype);const t=new Yr(e.shape,W3),s=this.compileAndRun(t,[e]);return Ha().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}makeTensorInfo(e,t,s){let r;if(t==="string"&&s!=null&&s.length>0&&Ql(s[0])){const i=s.map(o=>Ti(o));r=this.write(i,e,t)}else r=this.write(s,e,t);return this.texData.get(r).usage=null,{dataId:r,shape:e,dtype:t}}makeOutput(e,t,s){const{dataId:r}=this.makeTensorInfo(e,t,s);return Ha().makeTensorFromDataId(r,e,t,this)}unpackTensor(e){const t=new _A(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new oA(e.shape),s=!0;return this.runWebGLProgram(t,[e],e.dtype,null,s)}packedReshape(e,t){const s=[No(e.shape),...Lo(e.shape)],r={dtype:e.dtype,shape:s,dataId:e.dataId},i=[No(t),...Lo(t)],o=new z3(i,s),a=!0,l=[s],c=this.runWebGLProgram(o,[r],e.dtype,l,a);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e){const t=this.texData.get(e),{isPacked:s,shape:r,dtype:i}=t,o=Td(r);let a;const l=Cc(o);s?a=new aC(o):a=new oC(o);const c=!0,u=[l],h=this.runWebGLProgram(a,[{shape:o,dtype:i,dataId:e}],i,u,c);return{dtype:i,shape:r,dataId:h.dataId}}runWebGLProgram(e,t,s,r,i=!1){const o=this.makeTensorInfo(e.outputShape,s),a=this.texData.get(o.dataId);if(e.packedOutput&&(a.isPacked=!0),e.outPackingScheme===sl.DENSE){const y=Cc(e.outputShape);a.texShape=y.map(g=>g*2)}if(e.outTexUsage!=null&&(a.usage=e.outTexUsage),Se(o.shape)===0)return a.values=Br(o.dtype,0),o;const l=[],c=t.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let g=this.texData.get(y.dataId);if(g.texture==null){if(!e.packedInputs&&Se(y.shape)<=ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:g.values};e.packedInputs&&(g.isPacked=!0,g.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!g.isPacked!=!!e.packedInputs)y=g.isPacked?this.unpackTensor(y):this.packTensor(y),l.push(y),g=this.texData.get(y.dataId);else if(g.isPacked&&!Ic(g.shape,y.shape)){const x=y,b=y.shape;y.shape=g.shape,y=this.packedReshape(y,b),l.push(y),g=this.texData.get(y.dataId),x.shape=b}return{shape:y.shape,texData:g,isUniform:!1}});this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:a,isUniform:!1},h=iC(e,c,u),d=this.getAndSaveBinary(h,()=>sC(this.gpgpu,e,c,u)),p=this.activeTimers!=null;let f;p&&(f=this.startTimer()),rC(this.gpgpu,d,c,u,r),l.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=ee().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const y=Ns();y-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!ee().getBool("WEBGL_LAZILY_UNPACK")&&a.isPacked&&i===!1){const y=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),y}return o}compileAndRun(e,t,s,r,i=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,r,i)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement!="undefined"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=xt(()=>{if(!ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ee().getBool("DEBUG");ee().set("DEBUG",!1);const t=this.abs(Mt(1e-8)).dataSync()[0];if(ee().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?TA:EA}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:r,values:i,texture:o,usage:a,isPacked:l}=t;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Ns());let h=t.texShape;if(h==null&&(h=hE(s,l),t.texShape=h),i!=null){const d=Td(s);let p,f=h[1],m=h[0];const y=i instanceof Uint8Array||i instanceof Uint8ClampedArray;(l||!y)&&([f,m]=Io(h[0],h[1])),l?p=new hC(d,y):p=new uC(d,y);const g=y?[m,f]:h,x=this.makeTensorInfo(g,r),b=this.texData.get(x.dataId);y?b.usage=rs.PIXELS:b.usage=rs.UPLOAD,b.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),f,m,i);const w=[[m,f]],C=!0,M=this.runWebGLProgram(p,[x],r,w,C),E=this.texData.get(M.dataId);t.texture=E.texture,t.texShape=E.texShape,t.isPacked=E.isPacked,t.usage=E.usage,this.disposeIntermediateTensorInfo(x),this.texData.delete(M.dataId),t.values=null,c&&(this.uploadWaitMs+=Ns()-u)}else{const d=this.acquireTexture(h,a,r,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:r}=s;return this.releaseGPUData(e),t!=null&&(s.values=IA(t,r)),s.values}acquireTexture(e,t,s,r){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const i=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${i} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,r)}computeBytes(e,t){return e[0]*e[1]*Hu(t)}}Dc.nextDataId=0;function IA(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */z1()&&gv("webgl",()=>new Dc,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Oo{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=Ct(t,s),this.enableShapeUniforms=Un(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kc=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;class ll{constructor(e,t,s,r=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Ct(t,s);const i=this.outputShape.length;this.enableShapeUniforms=Un(i);let o="";if(r)if(i===0||Se(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${Dt(i)} coords = getOutputCoords();
        `,i===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=In("coords",i);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= outShape[${i} - 2];
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= outShape[${i} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[i-2]} + 1) >= ${this.outputShape[i-2]};
            bool nextColOutOfBounds =
              (${l[i-1]} + 1) >= ${this.outputShape[i-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kn(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const NA={kernelName:Qu,backendName:"webgl",kernelFunc:Kn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zr(n){const{inputs:e,backend:t}=n,{real:s,imag:r}=e,i=t.makeTensorInfo(s.shape,"complex64"),o=t.texData.get(i.dataId),a=Kn({inputs:{x:s},backend:t}),l=Kn({inputs:{x:r},backend:t});return o.complexTensorInfos={real:a,imag:l},i}const LA={kernelName:a0,backendName:"webgl",kernelFunc:Zr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X3="return (a < 0.) ? b * a : a;",j3=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function PA(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{alpha:i}=s,o=t.makeTensorInfo([],"float32",go(i,"float32")),a=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ll(j3,r.shape,o.shape):new Oo(X3,r.shape,o.shape),l=t.runWebGLProgram(a,[r,o],"float32");return t.disposeIntermediateTensorInfo(o),l}const DA={kernelName:H0,backendName:"webgl",kernelFunc:PA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q3="return (a < 0.) ? b * a : a;",K3=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function kA(n){const{inputs:e,backend:t}=n,{x:s,alpha:r}=e,i=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ll(K3,s.shape,r.shape):new Oo(q3,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],"float32")}const $A={kernelName:Sm,backendName:"webgl",kernelFunc:kA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y3="if (isnan(x)) return x;",FA=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`,OA=`
  result.r = isNaN.r > 0. ? NAN : result.r;
  result.g = isNaN.g > 0. ? NAN : result.g;
  result.b = isNaN.b > 0. ? NAN : result.b;
  result.a = isNaN.a > 0. ? NAN : result.a;
`;function vt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:r,backend:i})=>{const{x:o}=r,a=i,l=s||o.dtype;if(a.shouldExecuteOnCPU([o])&&t!=null){const h=a.texData.get(o.dataId),d=t(h.values,l);return a.makeTensorInfo(o.shape,l,d)}const c=ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Fo(o.shape,e):u=new Yr(o.shape,n),a.runWebGLProgram(u,[o],l)}}function vn({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:r,dtype:i}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(s&&l.dtype==="complex64"){const f=u.texData.get(l.dataId),m=u.texData.get(c.dataId),[y,g]=[[f.complexTensorInfos.real,m.complexTensorInfos.real],[f.complexTensorInfos.imag,m.complexTensorInfos.imag]].map(b=>{const[w,C]=b,M={dataId:w.dataId,dtype:w.dtype,shape:l.shape},E={dataId:C.dataId,dtype:C.dtype,shape:c.shape},A=new Oo(n,l.shape,c.shape);return u.runWebGLProgram(A,[M,E],Hs(w.dtype,C.dtype))}),x=Zr({inputs:{real:y,imag:g},backend:u});return u.disposeIntermediateTensorInfo(y),u.disposeIntermediateTensorInfo(g),x}const h=i||Hs(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&r!=null){const f=u.texData.get(l.dataId).values,m=u.texData.get(c.dataId).values,y=l.dtype==="string"?el(f):f,g=l.dtype==="string"?el(m):m,[x,b]=r(l.shape,c.shape,y,g,h),w=u.makeTensorInfo(b,h),C=u.texData.get(w.dataId);return C.values=x,w}const d=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new ll(e,l.shape,c.shape,t):p=new Oo(n,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function $c(n,e=!1){if(n==="linear")return e?xA:dA;if(n==="relu")return e?vA:fA;if(n==="elu")return e?yA:pA;if(n==="relu6")return e?bA:mA;if(n==="prelu")return e?K3:q3;if(n==="leakyrelu")return e?j3:X3;if(n==="sigmoid")return e?wA:gA;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Z3{constructor(e,t,s,r=!1,i=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=Un(this.outputShape.length);const u=r?e[1]:e[2],h=Math.ceil(u/2),d=r?"i * 2, rc.y":"rc.y, i * 2",p=i?"rc.z, i * 2":"i * 2, rc.z",f=r?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],m=i?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let y="",g="";a&&(l?y=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?y=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:y=`vec4 activation(vec4 x) {
          ${a}
        }`,g="result = activation(result);");const x=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",w="rc.x";e[0]<t[0]?b=`int(min(float(rc.x), ${e[0]-1}.))`:t[0]<e[0]&&(w=`int(min(float(rc.x), ${t[0]-1}.))`),this.userCode=`
      ${y}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${h}; i++) {
          int batchA = ${b};
          int batchB = ${w};
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${m[0]});
          result += (${f[1]} * ${m[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${g}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J3={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Q3{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Ct(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e4="return a * b;";function Ld(n){const{inputs:e,backend:t}=n,{a:s,b:r}=e,i=Hs(s.dtype,r.dtype);if(s.dtype==="complex64"){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),c=new Q3(J3.REAL,s.shape,r.shape),u=new Q3(J3.IMAG,s.shape,r.shape),h=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:s.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:r.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:r.shape}],d=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(u,h,"float32"),f=Zr({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,r])){const a=t.texData.get(s.dataId),l=t.texData.get(r.dataId),[c,u]=zM(s.shape,r.shape,a.values,l.values,i),h=t.makeTensorInfo(u,i),d=t.texData.get(h.dataId);return d.values=c,h}let o;return ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new ll(e4,s.shape,r.shape):o=new Oo(e4,s.shape,r.shape),t.runWebGLProgram(o,[s,r],i)}const BA={kernelName:dm,backendName:"webgl",kernelFunc:Ld};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zA(n,e,t){const s=[No(n.shape),...Lo(n.shape)],r={dtype:n.dtype,shape:s,dataId:n.dataId},i=[No(e),...Lo(e)],o=new z3(i,s),a=!0,l=[s],c=t.runWebGLProgram(o,[r],n.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Me(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{shape:i}=s,o=t,a=Se(r.shape),l=g9(i,a),c=Se(l);O(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${r.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(r.dataId);return u.isPacked&&!Ic(r.shape,l)&&!(u.texture!==null&&Ic(u.shape,l))?zA(r,l,o):(o.incRef(r.dataId),{dataId:r.dataId,shape:l,dtype:r.dtype})}const UA={kernelName:Rm,backendName:"webgl",kernelFunc:Me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class t4{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];const a=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${$a(h)?h.toPrecision(2):h}, ones);`}let u="";i%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VA{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:r,inSize:i,outSize:o}=e;this.outputShape=[r,o];let a="0.0",l="";t==="prod"?a="1.0":t==="min"?(a="1.0 / 1e-20",l="min"):t==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(a="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(a="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GA(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=vc(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function Vi(n,e,t,s){const r=GA(n.shape);let i=n;for(let o=0;o<r.length;o++){const{inSize:a,windowSize:l,outSize:c}=r[o];let u,h;t==="mean"?u=o===0?new t4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},a):new t4({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c}):u=new VA({windowSize:l,inSize:a,batchSize:n.shape[0],outSize:c},t),h=i,i=s.runWebGLProgram(u,[i],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return i}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WA{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[t[o]];this.outputShape=s,this.rank=s.length;const r=Dt(this.rank),i=HA(t);this.userCode=`
    void main() {
      ${r} resRC = getOutputCoords();
      setOutput(getA(${i}));
    }
    `}}function HA(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let r=0;r<n.length;r++)s[n[r]]=t[r];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let u=0;u<s.length;u++)s[u]=e[t[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const r=Dt(this.rank),i=B3("rc",this.rank),o=new Array(this.rank);for(let u=0;u<t.length;u++)o[t[u]]=i[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${i[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${r} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${i[this.rank-1]};
      if(++${i[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fc(n,e,t){const s=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new XA(n.shape,e):new WA(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jA(n,e,t,s){const r=e,i=n.shape.length,o=gn(r,n.shape);let a=o;const l=gs(a,i),c=l!=null;let u=n;c&&(u=Fc(n,l,s),a=xs(a.length,i)),Ps("sum",a,i);const[h,d]=Xs(u.shape,a);let p=h;t&&(p=ms(h,o));const f=Se(d),y=Se(n.shape)/f,g=Me({inputs:{x:u},attrs:{shape:[y,f]},backend:s}),x=xh(n.dtype),b=Vi(g,x,"sum",s),w=Me({inputs:{x:b},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(g),s.disposeIntermediateTensorInfo(b),c&&s.disposeIntermediateTensorInfo(u),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oc(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s;return jA(r,i,o,t)}const qA={kernelName:Xm,backendName:"webgl",kernelFunc:Oc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nn(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{perm:i}=s,o=t,a=r.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=r.shape[i[u]];let c;if(o.shouldExecuteOnCPU([r])){const h=o.texData.get(r.dataId).values,d=Nd(h,r.shape,r.dtype,i,l);c=o.makeTensorInfo(l,r.dtype);const p=o.texData.get(c.dataId);p.values=d}else c=Fc(r,i,o);return c}const KA={kernelName:h1,backendName:"webgl",kernelFunc:Nn};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n4=1e3;function Bc({a:n,b:e,transposeA:t,transposeB:s,backend:r,bias:i=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],d=s?e.shape[u-1]:e.shape[u-2],p=t?n.shape[c-1]:n.shape[c-2],f=s?e.shape[u-2]:e.shape[u-1],m=n.shape.slice(0,-2),y=e.shape.slice(0,-2),g=Se(m),x=Se(y),w=Ct(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);O(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const C=t?[g,h,p]:[g,p,h],M=s?[x,f,d]:[x,d,f],E=Me({inputs:{x:n},backend:r,attrs:{shape:C}}),A=Me({inputs:{x:e},backend:r,attrs:{shape:M}}),$=[E,A],B=Math.max(g,x),R=t?E.shape[1]:E.shape[2],K=i!=null,F=o!=null,z=l==="leakyrelu",V=l!=null?$c(l,!0):null,H=K||F||z||V!=null;let j;if((p===1||f===1)&&R>n4&&H===!1){let fe=E,Q=A;t&&(fe=Nn({inputs:{x:E},backend:r,attrs:{perm:[0,2,1]}}),$.push(fe)),s&&(Q=Nn({inputs:{x:A},backend:r,attrs:{perm:[0,2,1]}}),$.push(Q));const te=f!==1,Te=f===1;let we=fe;te&&(we=Me({inputs:{x:fe},backend:r,attrs:{shape:[B,R,1]}}),$.push(we));const Pe=f===1?2:1;let it=Q;Te&&(it=Me({inputs:{x:Q},backend:r,attrs:{shape:[B,1,R]}}),$.push(it));const le=Ld({inputs:{a:we,b:it},backend:r});j=Oc({inputs:{x:le},backend:r,attrs:{axis:Pe,keepDims:!0}}),$.push(le)}else{const fe=Hs(n.dtype,e.dtype),Q=new Z3(C,M,[B,p,f],t,s,K,V,F,z),te=[E,A];if(i!=null&&te.push(i),F&&te.push(o),z){const Te=r.makeTensorInfo([],"float32",go(a,"float32"));te.push(Te),$.push(Te)}j=r.runWebGLProgram(Q,te,fe)}const ae=Me({inputs:{x:j},backend:r,attrs:{shape:w}});$.push(j);for(const fe of $)r.disposeIntermediateTensorInfo(fe);return ae}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YA(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;return Bc({a:r,b:i,transposeA:l,transposeB:c,backend:t,bias:o,preluActivationWeights:a,leakyreluAlpha:h,activation:u})}const ZA={kernelName:nh,backendName:"webgl",kernelFunc:YA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s4="return abs(x);";function JA(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const i=t.texData.get(s.dataId),o=F3(i.values);return t.makeTensorInfo(s.shape,s.dtype,o)}let r;return ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Fo(s.shape,s4):r=new Yr(s.shape,s4),t.runWebGLProgram(r,[s],s.dtype)}const QA={kernelName:zf,backendName:"webgl",kernelFunc:JA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eR=ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,tR=vt({opSnippet:eR}),nR={kernelName:Uf,backendName:"webgl",kernelFunc:tR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sR=ks+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,rR=vt({opSnippet:sR}),iR={kernelName:Vf,backendName:"webgl",kernelFunc:rR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r4="return a + b;",oR=vn({opSnippet:r4,packedOpSnippet:r4,supportsComplex:!0,cpuKernelImpl:wM}),aR={kernelName:Zu,backendName:"webgl",kernelFunc:oR};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lR{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`float v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cR{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((i,o)=>`T${o}`);const s=[];this.variableNames.forEach(i=>{s.push(`vec4 v${i} = get${i}AtOutCoords();`)});const r=this.variableNames.map(i=>`v${i}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${r};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zc(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Kn({inputs:{x:s[0]},backend:t});if(s.length>ee().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(s.length/2),c=zc({inputs:s.slice(0,l),backend:t}),u=zc({inputs:s.slice(l),backend:t});return zc({inputs:[c,u],backend:t})}const r=s.map(l=>l.dtype).reduce((l,c)=>Hs(l,c)),i=s.map(l=>l.shape),a=ee().getBool("WEBGL_PACK")?new cR(s[0].shape,i):new lR(s[0].shape,i);return t.runWebGLProgram(a,s,r)}const uR={kernelName:Gf,backendName:"webgl",kernelFunc:zc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=gn(i,r.shape);let c=l;const u=gs(c,a);let h=r;u!=null&&(h=Nn({inputs:{x:r},backend:t,attrs:{perm:u}}),c=xs(c.length,a)),Ps("all",c,a);const[d,p]=Xs(h.shape,c),f=Se(p),m=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=Vi(m,m.dtype,"all",t);let g;if(o){const x=ms(d,l);g=Me({inputs:{x:y},backend:t,attrs:{shape:x}})}else g=Me({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),g}const dR={kernelName:Wf,backendName:"webgl",kernelFunc:hR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=gn(i,r.shape);let c=l;const u=gs(c,a);let h=r;u!=null&&(h=Nn({inputs:{x:r},backend:t,attrs:{perm:u}}),c=xs(c.length,a)),Ps("any",c,a);const[d,p]=Xs(h.shape,c),f=Se(p),m=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=Vi(m,m.dtype,"any",t);let g;if(o){const x=ms(d,l);g=Me({inputs:{x:y},backend:t,attrs:{shape:x}})}else g=Me({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),g}const fR={kernelName:Hf,backendName:"webgl",kernelFunc:pR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mR{constructor(e,t,s){this.variableNames=["A"];const{windowSize:r,batchSize:i,outSize:o}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[i,o];const a=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${r}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gR{constructor(e,t,s,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,O(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=e[e.length-1],o=Math.ceil(i/t);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),r||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=Dt(l),u=In("coords",l);let h,d;if(o===1){d=l+1;const A=Dt(d);h=`
        ${A} sourceLocR = ${A}(${u.join()}, 0);
        ++${u[l-1]};
        ${A} sourceLocG = ${A}(${u.join()}, 0);
        ++${u[l-2]};
        ${A} sourceLocA = ${A}(${u.join()}, 0);
        --${u[l-1]};
        ${A} sourceLocB = ${A}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],m=p.map(A=>"int "+A),y=In("sourceLocR",d-1).concat("inIdx.r"),g=In("sourceLocG",d-1).concat("inIdx.g"),x=In("sourceLocB",d-1).concat("inIdx.b"),b=In("sourceLocA",d-1).concat("inIdx.a"),w=s==="max"?"greaterThan":"lessThan",C=r?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()})));`,M=`vec4(
            getAChannel(${y.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,E=r?"":`
      float getBestIndicesAChannel(${m.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${m.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${E}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${M};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${C}
          vec4 candidate = ${M};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i4(n,e,t,s=null){let r=e.shape[0],i=e.shape[1];s!=null&&(r=s.shape[0],i=s.shape[1]);const o=vc(i),a={windowSize:o,inSize:i,batchSize:r,outSize:Math.ceil(i/o)},l=new mR(a,t,s==null),c=[e];s!=null&&c.push(s);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=i4(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function o4(n,e,t,s=null){const r=s!=null?s.shape:e.shape,i=r[r.length-1],o=vc(i),a=new gR(r,o,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=o4(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function a4(n,e,t,s){const r=[t];if(Ps("arg"+s.charAt(0).toUpperCase()+s.slice(1),r,e.shape.length),!ee().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const i=[],o=n.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=n.unpackTensor(e),i.push(l));const[c,u]=Xs(l.shape,r),h=Se(u),d=Me({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});i.push(d);const p=i4(n,d,s);i.push(p);const f=Me({inputs:{x:p},backend:n,attrs:{shape:c}});return i.forEach(m=>n.disposeIntermediateTensorInfo(m)),f}return o4(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=gn(i,r.shape);const a=gs(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Nn({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=xs(o.length,l.shape.length)),Ps("argMax",[o[0]],l.shape.length);const u=a4(t,l,o[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const yR={kernelName:Xf,backendName:"webgl",kernelFunc:xR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i}=s;let o=gn(i,r.shape);const a=gs(o,r.shape.length);let l=r;const c=[];a!=null&&(l=Nn({inputs:{x:r},backend:t,attrs:{perm:a}}),c.push(l),o=xs(o.length,l.shape.length)),Ps("argMin",[o[0]],l.shape.length);const u=a4(t,l,o[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const bR={kernelName:jf,backendName:"webgl",kernelFunc:vR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wR=ks+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,_R=vt({opSnippet:wR}),SR={kernelName:qf,backendName:"webgl",kernelFunc:_R};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TR=ks+"return log(x + sqrt(x * x + 1.0));",ER=vt({opSnippet:TR}),CR={kernelName:Kf,backendName:"webgl",kernelFunc:ER};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MR=ks+`
  return atan(x);
`,AR=vt({opSnippet:MR}),RR={kernelName:Yf,backendName:"webgl",kernelFunc:AR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IR=FA+`
  return atan(a, b);
`,NR=`
  vec4 result = atan(a, b);
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+OA+`
  return result;
`,LR=vn({opSnippet:IR,packedOpSnippet:NR}),PR={kernelName:Jf,backendName:"webgl",kernelFunc:LR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DR=ks+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,kR=vt({opSnippet:DR}),$R={kernelName:Zf,backendName:"webgl",kernelFunc:kR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cl{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const m=t==="avg",y=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(m||(x="-1.0 / 1e-20"),s){const A=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${A} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${r?i?y:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let w=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(w="avgValue / count");const C=Math.floor(o/4)*4,M=o%4,E=`
      if (${m}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${C}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${E}
          }

          int xC = xCCorner + ${C};
          if (${M===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${M===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${E}
          } else if (${M===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${E}
          }
        }
        setOutput(${w});
      }
    `}}class Pd{constructor(e,t,s,r=!1,i=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,m=e.effectiveFilterWidth,y=e.padInfo.front,g=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg";let w="0.0";if(b||(w="-1.0 / 1e-20"),s){const B=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${y}, ${g}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${m};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${B} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${r?i?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${m} +
                      wR * ${m} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const C="max";let M=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(M="avgValue / count");const E=Math.floor(o/4)*4,A=o%4,$=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${C}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${y}, ${g}, ${x});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${E}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${$}
            }

            int xC = xCCorner + ${E};
            if (${A===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${A===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${$}
            } else if (${A===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${$}
            }
          }
          setOutput(${M});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;il(r,"avgPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;O(ss(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=bo(r.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Qt(u.inShape,u.outShape))return Kn({inputs:{x:r},backend:t});const h=new cl(u,"avg",!1);return t.runWebGLProgram(h,[r],"float32")}const OR={kernelName:Qf,backendName:"webgl",kernelFunc:FR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=s,u=[1,1,1],h=Xa(r.shape,i,o,u,a,l,c),d=new Pd(h,"avg",!1);return t.runWebGLProgram(d,[r],"float32")}const zR={kernelName:e0,backendName:"webgl",kernelFunc:BR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class VR{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,m=d-1-e.padInfo.top,y=p-1-e.padInfo.left,g=1/(t*s*r);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${m}, ${y});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${i}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=Xa(o.shape,a,l,h,c,u),p=new VR(d);return t.runWebGLProgram(p,[r],o.dtype)}const WR={kernelName:I9,backendName:"webgl",kernelFunc:GR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HR(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i;il([r,i],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=s,u=bo(o.shape,a,l,1,c),h=new UR(u);return t.runWebGLProgram(h,[r],o.dtype)}const XR={kernelName:R9,backendName:"webgl",kernelFunc:HR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jR(n){const{inputs:e,backend:t,attrs:s}=n,{a:r,b:i}=e,{transposeA:o,transposeB:a}=s;return Bc({a:r,b:i,transposeA:o,transposeB:a,backend:t})}const qR={kernelName:t0,backendName:"webgl",kernelFunc:jR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KR{constructor(e,t,s,r,i,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Ct(e,t),Ct(e,s);let a="0.0";r!=null&&(Ct(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";i!=null&&(Ct(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YR{constructor(e,t,s,r,i,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Ct(e,t),Ct(e,s);let a="vec4(0.0)";r!=null&&(Ct(e,r),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";i!=null&&(Ct(e,i),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZR=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:r,variance:i,offset:o,scale:a}=n;O(r.shape.length===i.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),O(o==null||r.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),O(a==null||r.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,r,i];let u=null;o!=null&&(u=o.shape,c.push(o));let h=null;a!=null&&(h=a.shape,c.push(a));const d=ee().getBool("WEBGL_PACK_NORMALIZATION")?new YR(s.shape,r.shape,i.shape,u,h,l):new KR(s.shape,r.shape,i.shape,u,h,l);return e.runWebGLProgram(d,c,c[0].dtype)},JR={kernelName:F0,backendName:"webgl",kernelFunc:ZR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QR{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Dt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=eI(this.rank);let r;const i=e.map((o,a)=>`sourceLoc.${Dd[a]} = start[${a}] + coords.${Dd[a]};`);r=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${i.join(`
`)}
      `,this.userCode=`
      void main() {
        ${r}
        setOutput(getSource(${s}));
      }
    `}}const Dd=["x","y","z","w","u","v"];function eI(n){if(n===1)return"sourceLoc";if(n<=6)return Dd.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tI{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Dt(this.rank),s=In("coords",this.rank),r=In("sourceLoc",this.rank),i=this.rank===1?"sourceLoc":`vec2(${r.slice(-2).join()})`,o=`getChannel(getSource(${r.join()}), ${i})`,a=`
      result.x = ${o};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${r[this.rank-1]};
        result.y = ${o};
        --${r[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${r[this.rank-2]};
        result.z = ${o};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${r[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${r[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nI(n,e,t,s){const r=s.texData.get(n.dataId),i=s.makeTensorInfo(t,n.dtype),o=s.texData.get(i.dataId);Object.assign(o,r),o.refCount=1,o.shape=t,o.dtype=n.dtype;let a=Rh(e,wn(n.shape));r.slice&&(a+=r.slice.flatOffset),o.slice={flatOffset:a,origDataId:r.slice&&r.slice.origDataId||n.dataId};const l=s.dataRefCount.get(o.slice.origDataId)||1;return s.dataRefCount.set(o.slice.origDataId,l+1),i}function Bo(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,size:o}=s,[a,l]=_2(r,i,o);if(d2(r,a,l),Se(l)===0)return t.makeTensorInfo(l,r.dtype,[]);if(t.shouldExecuteOnCPU([r])||r.dtype==="string"){const h=t.texData.get(r.dataId),d=jM(h.values,a,l,r.shape,r.dtype);return t.makeTensorInfo(l,r.dtype,d)}const{isPacked:c}=t.texData.get(r.dataId),u=Ah(r.shape,a,l);if(c||!u){const h=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new tI(l):new QR(l),d=[a];return t.runWebGLProgram(h,[r],r.dtype,d)}return t.uploadToGPU(r.dataId),nI(r,a,l,t)}const sI={kernelName:Bm,backendName:"webgl",kernelFunc:Bo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rI=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,crops:o}=s;O(r.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((x,b)=>x*b),l=qh(r.shape,i,a),c=Kh(l.length,i.length),u=Yh(r.shape,i,a),h=yg(o,i.length),d=vg(u,o,i.length),p=[],f=Me({inputs:{x:r},backend:t,attrs:{shape:l}}),m=Nn({inputs:{x:f},backend:t,attrs:{perm:c}}),y=Me({inputs:{x:m},backend:t,attrs:{shape:u}}),g=Bo({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(y),p.forEach(x=>t.disposeIntermediateTensorInfo(x)),g},iI={kernelName:n0,backendName:"webgl",kernelFunc:rI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o}=s,a=t.readSync(r.dataId),l=t.readSync(i.dataId),c=$3(a,l,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,c)}const aI={kernelName:s0,backendName:"webgl",kernelFunc:oI};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lI(n){const{inputs:e,backend:t}=n,{s0:s,s1:r}=e,i=t.readSync(s.dataId),o=t.readSync(r.dataId),a=Ct(Array.from(i),Array.from(o));return t.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const cI={kernelName:r0,backendName:"webgl",kernelFunc:lI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uI="return float(a != b);",l4=vn({opSnippet:uI,cpuKernelImpl:VM,dtype:"bool"}),hI={kernelName:fm,backendName:"webgl",kernelFunc:l4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ul(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Kn({inputs:{x:r.complexTensorInfos.real},backend:t})}const dI={kernelName:Cm,backendName:"webgl",kernelFunc:ul};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pI="return float(int(x));";function fI(n,e){const t=new Yr(n.shape,pI),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kd(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dtype:i}=s;if(i==="complex64"){if(r.dtype==="complex64")return Kn({inputs:{x:r},backend:t});const o=Di(r.shape),a=kd({inputs:{x:r},backend:t,attrs:{dtype:"float32"}}),l=Zr({inputs:{real:a,imag:o},backend:t});return o.dispose(),t.disposeIntermediateTensorInfo(a),l}if(r.dtype==="complex64"){const o=ul({inputs:{input:r},backend:t}),a=kd({inputs:{x:o},backend:t,attrs:{dtype:i}});return t.disposeIntermediateTensorInfo(o),a}if(!v9(r.dtype,i)){const o=Kn({inputs:{x:r},backend:t});return{dataId:o.dataId,shape:o.shape,dtype:i}}if(i==="int32")return fI(r,t);if(i==="bool"){const o=t.makeTensorInfo([],"bool",Br("bool",1)),l=l4({inputs:{a:r,b:o},backend:t});return t.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${r.dtype} to ${i}`)}const mI={kernelName:Ju,backendName:"webgl",kernelFunc:kd};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c4="return ceil(x);",gI=vt({opSnippet:c4,packedOpSnippet:c4,cpuKernelImpl:SM}),xI={kernelName:i0,backendName:"webgl",kernelFunc:gI};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yI{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vI{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{clipValueMin:i,clipValueMax:o}=s;let a;ee().getBool("WEBGL_PACK_CLIP")?a=new vI(r.shape):a=new yI(r.shape);const l=[[i],[o]];return t.runWebGLProgram(a,[r],r.dtype,l)}const wI={kernelName:o0,backendName:"webgl",kernelFunc:bI};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _I{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u4(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function SI(n){const{inputs:e,backend:t}=n,{x:s}=e,r=t.texData.get(s.dataId),i=new _I(s.shape),o=[u4(s,r.complexTensorInfos.real),u4(s,r.complexTensorInfos.imag)];return t.runWebGLProgram(i,o,o[0].dtype)}const TI={kernelName:l0,backendName:"webgl",kernelFunc:SI};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EI{constructor(e){this.outputShape=[],this.outputShape=Fi(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let o=1;o<t.length;o++)t[o]=t[o-1]+e[o][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<t.length;o++){const a=t[o-1];s.push(`else if (yC < ${t[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const r=t.length,i=t[t.length-1];s.push(`else setOutput(getT${r}(yR, yC-${i}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CI{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Fi(e,t);const s=this.outputShape,r=s.length,i=Dt(r),o=In("coords",r),a=["x","y","z","w","u","v"].slice(0,r);this.variableNames=e.map((m,y)=>`T${y}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let m=1;m<l.length;m++)l[m]=l[m-1]+e[m][t];const c=a[t],u=a.slice(-2),h=a.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let m=1;m<l.length;m++){const y=l[m-1];d+=`
        if (${c} < ${l[m]}  && ${c} >= ${l[m-1]}) {
          return getChannel(
            getT${m}(${Uc(a,c,y)}),
            vec2(${Uc(u,c,y)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${Uc(a,c,f)}),
          vec2(${Uc(u,c,f)}));`,this.userCode=`
      float getValue(${a.map(m=>"int "+m)}) {
        ${d}
      }

      void main() {
        ${i} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[r-1]} = ${o[r-1]} + 1;
        if (${o[r-1]} < ${s[r-1]}) {
          result.g = getValue(${o});
        }

        ${o[r-2]} = ${o[r-2]} + 1;
        if (${o[r-2]} < ${s[r-2]}) {
          result.a = getValue(${o});
        }

        ${o[r-1]} = ${o[r-1]} - 1;
        if (${o[r-2]} < ${s[r-2]} &&
            ${o[r-1]} < ${s[r-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Uc(n,e,t){const s=n.indexOf(e);return n.map((i,o)=>o===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vc(n){const{inputs:e,backend:t}=n,{input:s}=e,r=t.texData.get(s.dataId);return Kn({inputs:{x:r.complexTensorInfos.imag},backend:t})}const MI={kernelName:G0,backendName:"webgl",kernelFunc:Vc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zo(n,e,t){const s=n[0].dtype;if(s==="complex64"){const u=n.map(m=>ul({inputs:{input:m},backend:t})),h=n.map(m=>Vc({inputs:{input:m},backend:t})),d=zo(u,e,t),p=zo(h,e,t),f=Zr({inputs:{real:d,imag:p},backend:t});return u.forEach(m=>t.disposeIntermediateTensorInfo(m)),h.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}let r=t.shouldExecuteOnCPU(n);if(s==="string"&&(r=!0),r){const u=n.map(g=>{const x=Se(g.shape.slice(e));return Me({inputs:{x:g},backend:t,attrs:{shape:[-1,x]}})}),h=u.map(g=>({vals:t.readSync(g.dataId),shape:g.shape})),d=Fi(u.map(g=>g.shape),1),p=u[0].shape[0]===1,f=TM(h,d,s,p),m=Fi(n.map(g=>g.shape),e),y=t.makeTensorInfo(m,s,f);return u.forEach(g=>t.disposeIntermediateTensorInfo(g)),y}if(n.length>ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const u=Math.floor(n.length/2),h=zo(n.slice(0,u),e,t),d=zo(n.slice(u),e,t),p=zo([h,d],e,t);return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),p}if(ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&n[0].shape.length>1){const u=new CI(n.map(h=>h.shape),e);return t.runWebGLProgram(u,n,s)}const{tensors2D:i,outShape:o}=AI(n,e,t),a=new EI(i.map(u=>u.shape)),l=t.runWebGLProgram(a,i,s);i.forEach(u=>t.disposeIntermediateTensorInfo(u));const c=Me({inputs:{x:l},attrs:{shape:o},backend:t});return t.disposeIntermediateTensorInfo(l),c}function AI(n,e,t){const s=Fi(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Me({inputs:{x:i},attrs:{shape:[-1,Se(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h4(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s,i=gn(r,e[0].shape)[0],o=Fi(e.map(c=>c.shape),i);if(Se(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const a=e.filter(c=>Se(c.shape)>0);if(a.length===1)return Kn({inputs:{x:a[0]},backend:t});const l=a.map(c=>c.shape);return gg(l,i),zo(a,i,t)}const RI={kernelName:c0,backendName:"webgl",kernelFunc:h4};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d4{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4,y=e.dataFormat==="channelsLast",g=y?1:2,x=y?2:3,b=y?3:1;let w="",C="";s&&(r?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:w=`
          float activation(float x) {
            ${s}
          }
        `,C="result = activation(result);");const M=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${y}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${m===1}) {

              if (${y}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${m===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${y}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${m===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${y}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${M}
        ${C}
        setOutput(result);
      }
    `}}class II{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,r=e.padInfo.left,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,m=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${i}, ${o}, ${a});
      const ivec3 pads = ivec3(${t}, ${s}, ${r});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${m===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${m===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${m===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NI{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Un(this.outputShape.length);const{dataFormat:s}=t,r=Rn(),i=s==="channelsLast",o=i?0:1,a=i?1:2,l=this.enableShapeUniforms?"if(blockIndex < outShape[1] && pos < outShape[0]) {":`if(blockIndex < ${e[1]} && pos < ${e[0]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.y + ${h};
          pos = rc.x + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${i}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec2 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${r.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p4({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const l=n.shape,c=s.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,m=!1;let y;const g=[];if(!((h===1||d===1)&&u>n4)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!=0&&Qt(c.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),C={dataId:n.dataId,shape:[1,w,t.inChannels],dtype:n.dtype},M=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,O(Ic(c.shape,C.shape),()=>`packed reshape ${c.shape} to ${C.shape} isn't free`);const E=Me({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});g.push(E);const A=Bc({a:C,b:E,backend:s,transposeA:f,transposeB:m,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o}),$=s.texData.get(A.dataId);O($.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=M,$.shape=t.outShape,y=Kn({inputs:{x:A},backend:s}),y.shape=t.outShape,g.push(A)}else{const w=p?l[0]*l[1]*l[2]:l[0]*l[2]*l[3],C=Me({inputs:{x:n},backend:s,attrs:{shape:[1,w,t.inChannels]}}),M=Me({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),E=Bc({a:C,b:M,transposeA:f,transposeB:m,backend:s,bias:r,activation:a,preluActivationWeights:i,leakyreluAlpha:o});y=Me({inputs:{x:E},backend:s,attrs:{shape:t.outShape}}),g.push(C),g.push(M),g.push(E)}for(const w of g)s.disposeIntermediateTensorInfo(w);return y}function f4({x:n,filter:e,convInfo:t,backend:s,bias:r=null,preluActivationWeights:i=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",m=l*c*u,y=d*h,g=[m,y],x=!0,b=!1,w=[],C=Me({inputs:{x:n},backend:s,attrs:{shape:n.shape.slice(1)}}),M=Me({inputs:{x:e},backend:s,attrs:{shape:[1,m,Se(e.shape)/m]}});w.push(C),w.push(M);const E=new NI(g,t),A=[C.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],$=s.runWebGLProgram(E,[C],"float32",A),B=Me({inputs:{x:$},backend:s,attrs:{shape:[1,g[0],g[1]]}});w.push($),w.push(B);const R=r!=null,K=i!=null,F=a==="leakyrelu",z=a?$c(a,!0):null,V=new Z3(B.shape,M.shape,[1,y,t.outChannels],x,b,R,z,K,F),H=[B,M];if(r&&H.push(r),K&&H.push(i),F){const Q=s.makeTensorInfo([],"float32",go(o,"float32"));H.push(Q),w.push(Q)}const j=s.runWebGLProgram(V,H,"float32"),ae=f?[1,d,h,t.outChannels]:[1,t.outChannels,d,h],fe=Me({inputs:{x:j},backend:s,attrs:{shape:ae}});w.push(j);for(const Q of w)s.disposeIntermediateTensorInfo(Q);return fe}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=s,h=_o(l),d=ns(r.shape,i.shape,o,c,a,u,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=p4({x:r,filter:i,convInfo:d,backend:t});else if(ee().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)p=f4({x:r,filter:i,convInfo:d,backend:t});else{const m=new d4(d);p=t.runWebGLProgram(m,[r,i],"float32")}const f=Me({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const PI={kernelName:u0,backendName:"webgl",kernelFunc:LI};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DI{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class kI{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=e.dataFormat==="channelsLast",a=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=o?1:2,u=o?2:3,h=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $I{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${i};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${r} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class FI{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,r=e.filterWidth,i=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,u=r-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${i}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${r}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${r} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,h=_o(l),d=ns(r.shape,u,o,1,a,c,!1,h),p=new DI(d);return t.runWebGLProgram(p,[r,i],"float32")}const BI={kernelName:h0,backendName:"webgl",kernelFunc:OI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=s,h=_o(c),d=ns(o,i.shape,a,1,l,u,!1,h),p=new kI(d);return t.runWebGLProgram(p,[r,i],"float32")}const UI={kernelName:d0,backendName:"webgl",kernelFunc:zI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,c=ja(r.shape,i.shape,o,l,a),u=new II(c);return t.runWebGLProgram(u,[r,i],"float32")}const GI={kernelName:p0,backendName:"webgl",kernelFunc:VI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WI(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,pad:a,filterShape:l}=s,c=ja(r.shape,l,o,1,a),u=new $I(c);return t.runWebGLProgram(u,[r,i],"float32")}const HI={kernelName:N9,backendName:"webgl",kernelFunc:WI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{pad:o,strides:a,inputShape:l}=s,c=ja(l,i.shape,a,1,o),u=new FI(c);return t.runWebGLProgram(u,[r,i],"float32")}const jI={kernelName:L9,backendName:"webgl",kernelFunc:XI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qI=Y3+`
  return cos(x);
`,KI=vt({opSnippet:qI}),YI={kernelName:f0,backendName:"webgl",kernelFunc:KI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZI=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,JI=vt({opSnippet:ZI}),QI={kernelName:m0,backendName:"webgl",kernelFunc:JI};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eN{constructor(e,t,s,r,i){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=t,[h,d]=s;this.outputShape=[u,h,d,c];const p=r==="bilinear"?1:0,[f,m]=[`${a-1}.0`,`${l-1}.0`],[y,g,x]=h>1?[`${(a-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[b,w,C]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${m} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${m}`];this.userCode=`
      const float height_ratio = float(${y});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${w};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${i}));
          return;
        }
        float in_x = ${C};
        if( in_x < 0.0 || in_x > ${m} ) {
          setOutput(float(${i}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tN=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:r,boxes:i,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=s,u=new eN(r.shape,i.shape,a,l,c);return t.runWebGLProgram(u,[r,i,o],"float32")},nN={kernelName:x0,backendName:"webgl",kernelFunc:tN};class m4{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}],this.outputShape=e;const r=e.length,i=t?"0.0":`getX(${g4(r,"coords")})`,o=e[e.length-1];let a="",l="";t?(a=s?`end != ${o-1}`:"end != 0",l=s?"end + 1":"end - 1"):(a=s?`end + pow2 < ${o}`:"end >= pow2",l=s?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Dt(r)} coords = getOutputCoords();
        int end = ${x4(r,"coords")};
        float val = ${i};
        int pow2 = int(pow(2.0, index));
        if (${a}) {
          int idx = ${l};
          ${x4(r,"coords")} = idx;
          val += getX(${g4(r,"coords")});
        }
        setOutput(val);
      }
    `}}function g4(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}function x4(n,e){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw Error(`Cumulative sum for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,exclusive:o,reverse:a}=s,l=r.shape.length,c=gs([i],l);let u=r;c!=null&&(u=Nn({inputs:{x:r},backend:t,attrs:{perm:c}}));const h=xs(1,l)[0];if(h!==l-1)throw new Error(`WebGL cumsum shader expects an inner-most axis=${r.shape.length-1} but got axis=${i}`);const d=u.shape[h];let p=Kn({inputs:{x:u},backend:t});for(let f=0;f<=Math.ceil(Math.log2(d))-1;f++){const m=new m4(u.shape,!1,a),y=[[f]],g=p;p=t.runWebGLProgram(m,[p],p.dtype,y),t.disposeIntermediateTensorInfo(g)}if(o){const f=new m4(u.shape,o,a),m=p;p=t.runWebGLProgram(f,[p],p.dtype),t.disposeIntermediateTensorInfo(m)}if(c!=null){const f=Bh(c),m=Nn({inputs:{x:p},backend:t,attrs:{perm:f}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(u),m}return p}const rN={kernelName:g0,backendName:"webgl",kernelFunc:sN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,weights:i}=e,{size:o,binaryOutput:a}=s;if(r.shape.length===1){const l=t.readSync(r.dataId),c=t.readSync(i.dataId),u=$3(l,c,i.dtype,i.shape,o);return t.makeTensorInfo([o],i.dtype,u)}else if(r.shape.length===2){const l=t.bufferSync(r),c=t.bufferSync(i),u=_M(l,c,o,a);return t.makeTensorInfo(u.shape,i.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${r.shape.length}.`)}const oN={kernelName:y0,backendName:"webgl",kernelFunc:iN};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aN{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockSize:i,dataFormat:o}=s,a=r.shape[0],l=o==="NHWC"?r.shape[1]:r.shape[2],c=o==="NHWC"?r.shape[2]:r.shape[3],u=o==="NHWC"?r.shape[3]:r.shape[1],h=l*i,d=c*i,p=u/(i*i),f=o==="NHWC"?[a,h,d,p]:[a,p,h,d],m=new aN(f,i,o);return t.runWebGLProgram(m,[r],r.dtype)}const cN={kernelName:v0,backendName:"webgl",kernelFunc:lN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class y4{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Un(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";s&&(r?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v4{constructor(e,t=!1,s=null,r=!1,i=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Un(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<h;g++)p+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<h;g++)p+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){const x=g*2;if(p+=`
          xC = xCCorner + ${x*c};
          `,l===1){if(x<h&&(a%2==1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,c===1&&x>0?p+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<h)){const b=a%2==0?If(c):c;c%2==0&&a%2==1||c%2!=0&&a%2!=1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,c>1&&(p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                      xTexelC${x} = getX(batch, xR, xCOffset, d1);
                      xTexelC${x}Ready = 1;
                    }
                    `),p+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                  `):b===1?p+=`
                    xC${x+1} = xTexelC${x};
                    `:p+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<h&&(a%2==1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<h&&(p+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<h&&(p+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<h&&(p+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",m="";s&&(r?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:i?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,m="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),r&&this.variableNames.push("preluActivationWeights"),i&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${y}
        ${m}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=s;let u=l;u==null&&(u=[1,1]),O(ss(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const h=ns(r.shape,i.shape,o,u,a,c,!0);let d;ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels==1?d=new v4(h):d=new y4(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[r,i],"float32",p)}const hN={kernelName:b0,backendName:"webgl",kernelFunc:uN};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dN{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,r=e.padInfo.top,i=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${r};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${i};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class pN{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,r=e.strideHeight,i=e.strideWidth,o=t-1-e.padInfo.top,a=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${r}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${i}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fN(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,dy:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=s,h=ns(r.shape,u,o,a,l,c,!0),d=new dN(h);return t.runWebGLProgram(d,[r,i],"float32")}const mN={kernelName:w0,backendName:"webgl",kernelFunc:fN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gN(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,filter:i}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=s,h=ns(u,i.shape,o,a,l,c,!0),d=new pN(h);return t.runWebGLProgram(d,[r,i],"float32")}const xN={kernelName:_0,backendName:"webgl",kernelFunc:gN};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yN{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vN(n){const{inputs:e,backend:t}=n,{x:s}=e,r=[...s.shape,...s.shape],i=Se(s.shape),o=Me({inputs:{x:s},backend:t,attrs:{shape:[i]}}),a=new yN(i),l=t.runWebGLProgram(a,[o],o.dtype),c=Me({inputs:{x:l},backend:t,attrs:{shape:r}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const bN={kernelName:P9,backendName:"webgl",kernelFunc:vN};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wN{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:r,strideHeight:i,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:d}=r;this.userCode=`
      const ivec2 strides = ivec2(${i}, ${o});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _N(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i}=e,{strides:o,pad:a,dilations:l}=s,c=C2(r.shape,i.shape,o,a,"NHWC",l);let u;const h=new wN(c);u=t.runWebGLProgram(h,[r,i],"float32");const d=Me({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),d}const SN={kernelName:S0,backendName:"webgl",kernelFunc:_N};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n){const{inputs:e,backend:t,attrs:s}=n,{equation:r}=s,i=e,{allDims:o,summedDims:a,idDims:l}=Ig(r,i.length);Lg(o.length,l,i);const{path:c,steps:u}=Pg(a,l),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const y of u[m]){const{permutationIndices:g,expandDims:x}=Ng(p,l[y]);let b;Dg(g)?b=i[y]:(b=Nn({inputs:{x:i[y]},backend:t,attrs:{perm:g}}),f.push(b));const w=b.shape.slice();for(let C=0;C<x.length;++C)w.splice(x[C],0,1);Qt(b.shape,w)||(b=Me({inputs:{x:b},backend:t,attrs:{shape:w}}),f.push(b)),d===null?d=b:(d=Ld({inputs:{a:b,b:d},backend:t}),f.push(d))}m<h-1&&(c[m]>=0&&(d=Oc({inputs:{x:d},backend:t,attrs:{axis:c[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&t.disposeIntermediateTensorInfo(m);return d}const EN={kernelName:E0,backendName:"webgl",kernelFunc:TN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CN="return (x >= 0.0) ? x : (exp(x) - 1.0);",MN=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,AN=vt({opSnippet:CN,packedOpSnippet:MN}),RN={kernelName:C0,backendName:"webgl",kernelFunc:AN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IN="return (b >= 1.0) ? a : a * (b + 1.0);",NN=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,LN=n=>{const{inputs:e,backend:t}=n,{dy:s,y:r}=e,i=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new ll(NN,s.shape,r.shape):new Oo(IN,s.shape,r.shape);return t.runWebGLProgram(i,[s,r],s.dtype)},PN={kernelName:D9,backendName:"webgl",kernelFunc:LN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DN=`
  return vec4(equal(a, b));
`,kN="return float(a == b);",$N=vn({opSnippet:kN,packedOpSnippet:DN,dtype:"bool",cpuKernelImpl:EM}),FN={kernelName:A0,backendName:"webgl",kernelFunc:$N};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ON=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${_g};
  float a1 = ${Sg};
  float a2 = ${Tg};
  float a3 = ${Eg};
  float a4 = ${Cg};
  float a5 = ${Mg};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,BN=vt({opSnippet:ON}),zN={kernelName:M0,backendName:"webgl",kernelFunc:BN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b4="return exp(x);",w4=vt({opSnippet:b4,packedOpSnippet:b4,cpuKernelImpl:CM,dtype:"float32"}),UN={kernelName:R0,backendName:"webgl",kernelFunc:w4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $d(n){const{inputs:e,attrs:t,backend:s}=n,{dim:r}=t,{input:i}=e,o=i.shape.length,a=i.shape.slice();let l=r;return r<0&&(O(-(o+1)<=r,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+r+1),a.splice(l,0,1),Me({inputs:{x:i},backend:s,attrs:{shape:a}})}const VN={kernelName:I0,backendName:"webgl",kernelFunc:$d};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _4="return exp(x) - 1.0;",GN=vt({opSnippet:_4,packedOpSnippet:_4,cpuKernelImpl:MM}),WN={kernelName:N0,backendName:"webgl",kernelFunc:GN};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class S4{constructor(e,t,s){this.variableNames=["real","imag"];const r=t[1];this.outputShape=t;const i=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=s?`${r}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${i};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${r});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${r}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T4(n,e,t){const s=t.texData.get(n.dataId),r=Se(n.shape),i=n.shape[n.shape.length-1],o=r/i,a=Me({inputs:{x:n},backend:t,attrs:{shape:[o,i]}}),l=a.shape,c=new S4("real",l,e),u=new S4("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(u,h,"float32"),f=Zr({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const m=Me({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(f),m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HN(n){const{inputs:e,backend:t}=n,{input:s}=e;return T4(s,!1,t)}const XN={kernelName:L0,backendName:"webgl",kernelFunc:HN};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jN{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hl(n){const{backend:e,attrs:t}=n,{shape:s,value:r}=t;let{dtype:i}=t;if(i=i||ec(r),i==="string"){const o=cs(i,Se(s));return o.fill(r),e.makeTensorInfo(s,i,o)}else{const o=new jN(s,r),a=[[r]];return e.runWebGLProgram(o,[],i,a)}}const qN={kernelName:P0,backendName:"webgl",kernelFunc:hl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KN{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YN={kernelName:D0,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,r=new KN(t.shape);return s.runWebGLProgram(r,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E4="return floor(x);",ZN=vt({opSnippet:E4,packedOpSnippet:E4,cpuKernelImpl:AM}),JN={kernelName:k0,backendName:"webgl",kernelFunc:ZN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QN=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,eL=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,tL=vn({opSnippet:QN,packedOpSnippet:eL,dtype:"int32"}),nL={kernelName:$0,backendName:"webgl",kernelFunc:tL};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sL{constructor(e){this.variableNames=["A"];const t=Rn(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rL{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=Rn(),[s,r]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${r}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iL={kernelName:th,backendName:"webgl",kernelFunc:oL};let Uo;function oL(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:r}=e;const{numChannels:i}=s,o=typeof HTMLVideoElement!="undefined"&&r instanceof HTMLVideoElement,a=typeof HTMLImageElement!="undefined"&&r instanceof HTMLImageElement,[l,c]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[c,l],h=[c,l,i];(a||o)&&(Uo==null&&(Uo=document.createElement("canvas").getContext("2d")),Uo.canvas.width=l,Uo.canvas.height=c,Uo.drawImage(r,0,0,l,c),r=Uo.canvas);const d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=rs.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),r);const p=ee().getBool("WEBGL_PACK")?new rL(h):new sL(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,m=_o(u),y=ns(r.shape,i.shape,l,h,c,d,!1,m);let g;const x=[];if(y.filterHeight===1&&y.filterWidth===1&&y.dilationHeight===1&&y.dilationWidth===1&&y.strideHeight===1&&y.strideWidth===1&&(y.padInfo.type==="SAME"||y.padInfo.type==="VALID"))g=p4({x:r,filter:i,convInfo:y,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else if(ee().getBool("WEBGL_CONV_IM2COL")&&r.shape[0]===1)g=f4({x:r,filter:i,convInfo:y,backend:t,bias:o,activation:p,preluActivationWeights:a,leakyreluAlpha:f});else{const w=o!=null,C=a!=null,M=p==="leakyrelu",E=p?$c(p,!1):null,A=new d4(y,w,E,C,M),$=[r,i];if(o&&$.push(o),a&&$.push(a),M){const B=t.makeTensorInfo([],"float32",go(f,"float32"));$.push(B),x.push(B)}g=t.runWebGLProgram(A,$,"float32")}const b=Me({inputs:{x:g},backend:t,attrs:{shape:y.outShape}});return x.push(g),x.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}const lL={kernelName:sh,backendName:"webgl",kernelFunc:aL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cL(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,filter:i,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let m=u;m==null&&(m=[1,1]),O(ss(l,m),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${m}'`);const y=ns(r.shape,i.shape,l,m,c,h,!0),g=ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&y.strideWidth<=2&&y.outChannels/y.inChannels==1,x=d?$c(d,g):null,b=[r,i],w=o!=null,C=a!=null,M=d==="leakyrelu";if(w&&b.push(o),C&&b.push(a),M){const B=t.makeTensorInfo([],"float32",go(p,"float32"));b.push(B),f.push(B)}let E;g?E=new v4(y,w,x,C,M):E=new y4(y,w,x,C,M);const A=[[y.padInfo.top,y.padInfo.left],[y.strideHeight,y.strideWidth],[y.dilationHeight,y.dilationWidth],[y.inHeight,y.inWidth]],$=t.runWebGLProgram(E,b,"float32",A);return f.forEach(B=>t.disposeIntermediateTensorInfo(B)),$}const uL={kernelName:rh,backendName:"webgl",kernelFunc:cL};class hL{constructor(e,t,s){this.sliceDim=e,this.strides=t,this.variableNames=["x","indices"],this.outputShape=s;const r=Dt(t.length),i=Dt(s.length),o=this.sliceDim>1?"strides[j]":"strides";this.userCode=`
        ${r} strides = ${r}(${this.strides});
         void main() {
          ${i} coords = getOutputCoords();
          int flattenIndex = 0;
          for (int j = 0; j < ${this.sliceDim}; j++) {
            int index = round(getIndices(coords[0], j));
            flattenIndex += index * ${o};
          }
          setOutput(getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dL(n){const{inputs:e,backend:t}=n,{params:s,indices:r}=e,i=r.shape,o=i[i.length-1],a=Se(s.shape),[l,c,u,h]=c2(s,r),d=Me({inputs:{x:r},backend:t,attrs:{shape:[c,o]}}),p=Me({inputs:{x:s},backend:t,attrs:{shape:[Se(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,r])||s.dtype==="string"){const g=t.readSync(r.dataId),x=t.bufferSync(s),b=RM(g,x,s.dtype,c,o,u,h,s.shape,a);return t.makeTensorInfo(l,s.dtype,b.values)}const f=new hL(o,h,[c,u]),m=t.runWebGLProgram(f,[p,d],p.dtype),y=Me({inputs:{x:m},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(m),y}const pL={kernelName:B0,backendName:"webgl",kernelFunc:dL};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fL{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Dt(this.rank),r=mL(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function mL(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let r=0;r<n.length;r++)r===2?s.push("int(getIndices(resRC.x, resRC.z))"):s.push(`${t[r]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,indices:i}=e,{axis:o,batchDims:a}=s,l=gn(o,r.shape)[0],c=t.readSync(i.dataId),u=r.shape[l];for(let w=0;w<c.length;++w){const C=c[w];O(C<=u-1&&C>=0,()=>`GatherV2: the index value ${C} is not in [0, ${u-1}]`)}const h=Kg(r,i,l,a),d=Se(i.shape),p=[],f=Me({inputs:{x:r},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),m=Me({inputs:{x:i},backend:t,attrs:{shape:[h.batchSize,d/h.batchSize]}});p.push(f),p.push(m);const y=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize];if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const w=t.bufferSync(m),C=t.bufferSync(f),M=IM(C,w,y);return p.forEach(E=>t.disposeIntermediateTensorInfo(E)),t.makeTensorInfo(h.outputShape,M.dtype,M.values)}const g=new fL(f.shape,y),x=t.runWebGLProgram(g,[f,m],f.dtype);p.push(x);const b=Me({inputs:{x},backend:t,attrs:{shape:h.outputShape}});return p.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}const gL={kernelName:O0,backendName:"webgl",kernelFunc:C4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xL="return float(a > b);",yL=`
  return vec4(greaterThan(a, b));
`,vL=vn({opSnippet:xL,packedOpSnippet:yL,cpuKernelImpl:NM,dtype:"bool"}),bL={kernelName:z0,backendName:"webgl",kernelFunc:vL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wL="return float(a >= b);",_L=`
  return vec4(greaterThanEqual(a, b));
`,SL=vn({opSnippet:wL,packedOpSnippet:_L,dtype:"bool",cpuKernelImpl:LM}),TL={kernelName:U0,backendName:"webgl",kernelFunc:SL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EL(n){const{inputs:e,backend:t}=n,{input:s}=e;return T4(s,!0,t)}const CL={kernelName:V0,backendName:"webgl",kernelFunc:EL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ML="return float(!isnan(x) && !isinf(x));",AL=vt({opSnippet:ML,dtype:"bool"}),RL={kernelName:k9,backendName:"webgl",kernelFunc:AL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IL="return float(isinf(x));",NL=vt({opSnippet:IL,dtype:"bool"}),LL={kernelName:$9,backendName:"webgl",kernelFunc:NL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PL="return float(isnan(x));",DL=vt({opSnippet:PL,dtype:"bool"}),kL={kernelName:W0,backendName:"webgl",kernelFunc:DL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $L="return float(a < b);",FL=`
  return vec4(lessThan(a, b));
`,OL=vn({opSnippet:$L,packedOpSnippet:FL,cpuKernelImpl:PM,dtype:"bool"}),BL={kernelName:X0,backendName:"webgl",kernelFunc:OL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zL="return float(a <= b);",UL=`
  return vec4(lessThanEqual(a, b));
`,VL=vn({opSnippet:zL,packedOpSnippet:UL,cpuKernelImpl:DM,dtype:"bool"}),GL={kernelName:j0,backendName:"webgl",kernelFunc:VL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WL(n){const{backend:e,attrs:t}=n,{start:s,stop:r,num:i}=t,o=kM(s,r,i);return e.makeTensorInfo([o.length],"float32",o)}const HL={kernelName:q0,backendName:"webgl",kernelFunc:WL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XL=`if (x < 0.0) return NAN;
  return log(x);`,jL=`
  vec4 result = log(x);
  vec4 isNaN = vec4(lessThan(x, vec4(0.0)));
  result.r = isNaN.r == 1.0 ? NAN : result.r;
  result.g = isNaN.g == 1.0 ? NAN : result.g;
  result.b = isNaN.b == 1.0 ? NAN : result.b;
  result.a = isNaN.a == 1.0 ? NAN : result.a;

  return result;
`,qL=vt({opSnippet:XL,packedOpSnippet:jL,cpuKernelImpl:$M}),KL={kernelName:K0,backendName:"webgl",kernelFunc:qL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YL="return log(1.0 + x);",ZL=vt({opSnippet:YL}),JL={kernelName:Y0,backendName:"webgl",kernelFunc:ZL};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QL="return float(a >= 1.0 && b >= 1.0);",eP=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,tP=vn({opSnippet:QL,packedOpSnippet:eP,dtype:"bool"}),nP={kernelName:Z0,backendName:"webgl",kernelFunc:tP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sP="return float(!(x >= 1.0));",rP=vt({opSnippet:sP}),iP={kernelName:J0,backendName:"webgl",kernelFunc:rP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oP="return float(a >= 1.0 || b >= 1.0);",aP=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,lP=vn({opSnippet:oP,packedOpSnippet:aP,dtype:"bool"}),cP={kernelName:Q0,backendName:"webgl",kernelFunc:lP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uP{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[];const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hP{constructor(e,t,s,r,i){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=t,a=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${r}) * sum`;i===.5?l=`inversesqrt(${c})`:i===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${i}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dP=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{depthRadius:i,bias:o,alpha:a,beta:l}=s,c=ee().getBool("WEBGL_PACK_NORMALIZATION")?new hP(r.shape,i,o,a,l):new uP(r.shape,i,o,a,l);return t.runWebGLProgram(c,[r],r.dtype)},pP={kernelName:em,backendName:"webgl",kernelFunc:dP};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fP{constructor(e,t,s,r,i){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=r,this.beta=i,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${r}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${r})
                * float(${i})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${i});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mP=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r,y:i,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=s,h=new fP(r.shape,a,l,c,u);return t.runWebGLProgram(h,[r,i,o],r.dtype)},gP={kernelName:F9,backendName:"webgl",kernelFunc:mP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xP(n,e,t,s){const r=Se(e),o=Se(n.shape)/r,a=Me({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=Vi(a,n.dtype,"max",s),c=Me({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reductionIndices:i,keepDims:o}=s,a=r.shape.length,l=gn(i,r.shape);let c=l;const u=gs(c,a),h=u!=null,d=t.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const b=t.texData.get(p.dataId).values,w=new Array(a);for(let E=0;E<w.length;E++)w[E]=r.shape[u[E]];const C=Nd(b,r.shape,r.dtype,u,w);p=t.makeTensorInfo(w,r.dtype);const M=t.texData.get(p.dataId);M.values=C}else p=Fc(r,u,t);c=xs(c.length,a)}Ps("max",c,a);const[f,m]=Xs(p.shape,c);let y=f;o&&(y=ms(f,l));let g;if(d){const b=t.texData.get(p.dataId).values,w=FM(b,Se(m),y,r.dtype);g=t.makeTensorInfo(y,r.dtype);const C=t.texData.get(g.dataId);C.values=w}else g=xP(p,m,y,t);return h&&t.disposeIntermediateTensorInfo(p),g}const yP={kernelName:tm,backendName:"webgl",kernelFunc:M4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vP=H3+`
  return max(a, b);
`,bP=`
  vec4 result = vec4(max(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+kc+`
  return result;
`,wP=vn({opSnippet:vP,packedOpSnippet:bP,cpuKernelImpl:OM}),_P={kernelName:nm,backendName:"webgl",kernelFunc:wP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e;il(r,"maxPool");const{filterSize:i,strides:o,pad:a,dimRoundingMode:l}=s,c=1;O(ss(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=bo(r.shape,i,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Qt(u.inShape,u.outShape))return Kn({inputs:{x:r},backend:t});const h=new cl(u,"max",!1);return t.runWebGLProgram(h,[r],r.dtype)}const TP={kernelName:sm,backendName:"webgl",kernelFunc:SP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{filterSize:i,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=Xa(r.shape,i,o,u,a,c,l),d=new Pd(h,"max",!1);return t.runWebGLProgram(d,[r],r.dtype)}const CP={kernelName:rm,backendName:"webgl",kernelFunc:EP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class MP{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,r=e.dilationHeight,i=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=i-1-e.padInfo.top,l=o-1-e.padInfo.left,c=i*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${i};
          wR += ${r}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class AP{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,r=e.strideWidth,i=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=c-1-e.padInfo.top,p=u-1-e.padInfo.left,f=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${i}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${r}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RP(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i}=e,o=i,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=Xa(o.shape,a,l,h,c,u),p=new Pd(d,"max",!0),f=t.runWebGLProgram(p,[o],o.dtype),m=new AP(d),y=t.runWebGLProgram(m,[r,f],o.dtype);return t.disposeIntermediateTensorInfo(f),y}const IP={kernelName:B9,backendName:"webgl",kernelFunc:RP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NP(n){const{inputs:e,backend:t,attrs:s}=n,{dy:r,input:i,output:o}=e,a=i;il([i,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=bo(a.shape,l,c,1,u,h),p=!0,f=new cl(d,"max",p),m=t.runWebGLProgram(f,[a],a.dtype),y=new MP(d),g=t.runWebGLProgram(y,[r,m],a.dtype);return t.disposeIntermediateTensorInfo(m),g}const LP={kernelName:O9,backendName:"webgl",kernelFunc:NP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PP(n,e,t,s){let r=new cl(t,"max",!1);const i=s.runWebGLProgram(r,[n],"float32");r=new cl(t,"max",!0,!0,e);const o=s.runWebGLProgram(r,[n],"float32");return[i,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DP={kernelName:im,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:r,strides:i,pad:o,includeBatchInIndex:a}=e,l=t;O(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];O(ss(i,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${i} and dilations '${c}'`);const u=bo(s.shape,r,i,c,o),[h,d]=PP(s,a,u,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kP(n,e,t,s){const r=Se(e),o=Se(n.shape)/r,a=Me({inputs:{x:n},attrs:{shape:[o,r]},backend:s}),l=Vi(a,"float32","mean",s),c=Me({inputs:{x:l},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $P={kernelName:om,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:r,axis:i}=e,o=t,a=s.shape.length,l=gn(i,s.shape);let c=l;const u=gs(c,a),h=u!=null,d=o.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const w=o.texData.get(f.dataId).values,C=new Array(a);for(let A=0;A<C.length;A++)C[A]=s.shape[u[A]];const M=Nd(w,s.shape,s.dtype,u,C);f=o.makeTensorInfo(C,s.dtype);const E=o.texData.get(f.dataId);E.values=M}else f=Fc(s,u,o);p.push(f),c=xs(c.length,a)}Ps("sum",c,a);const[m,y]=Xs(f.shape,c);let g=m;r&&(g=ms(m,l));const x=kP(f,y,g,o);for(const b of p)o.disposeIntermediateTensorInfo(b);return x}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FP(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=gn(i,r.shape);let c=l;const u=gs(c,a);let h=r;u!=null&&(h=Nn({inputs:{x:r},backend:t,attrs:{perm:u}}),c=xs(c.length,r.shape.length)),Ps("min",c,a);const[d,p]=Xs(h.shape,c),f=Se(p),m=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),y=Vi(m,m.dtype,"min",t);let g;if(o){const x=ms(d,l);g=Me({inputs:{x:y},backend:t,attrs:{shape:x}})}else g=Me({inputs:{x:y},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(y),u!=null&&t.disposeIntermediateTensorInfo(h),g}const OP={kernelName:am,backendName:"webgl",kernelFunc:FP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BP=H3+`
  return min(a, b);
`,zP=`
  vec4 result = vec4(min(a, b));
  vec4 isNaN = min(vec4(isnan(a)) + vec4(isnan(b)), vec4(1.0));
  `+kc+`
  return result;
`,UP=vn({opSnippet:BP,packedOpSnippet:zP,cpuKernelImpl:BM}),VP={kernelName:lm,backendName:"webgl",kernelFunc:UP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GP{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const r=e.length,i=Dt(r),o=t.map(u=>u[0]).join(","),a=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r),c=s==="reflect"?0:1;if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        for (int i = 0; i < ${r}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${i} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WP{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,m)=>f[0]+e[m]+f[1]);const r=e.length,i=Dt(r),o=t.map(f=>f[0]).join(","),a=t.map((f,m)=>f[0]+e[m]).join(","),l=In("rc",r),c=In("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(r===1){const f=`
        ${i} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const f=`
        ${i} source = rc;
        ${i} lt = ${i}(lessThan(source, start));
        ${i} gte = ${i}(greaterThanEqual(source, end));
        ${i} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${i} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[r-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[r-2]} += 1;
        if(${l[r-2]} < ${this.outputShape[r-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[r-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HP=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:r,mode:i}=t,o=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new WP(s.shape,r,i):new GP(s.shape,r,i);return e.runWebGLProgram(o,[s],s.dtype)},XP={kernelName:cm,backendName:"webgl",kernelFunc:HP};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jP=`if (b == 0.0) return NAN;
  return mod(a, b);`,qP=`
  vec4 result = mod(a, b);
  vec4 isNaN = vec4(equal(b, vec4(0.0)));
  `+kc+`
  return result;
`,KP=vn({opSnippet:jP,packedOpSnippet:qP}),YP={kernelName:um,backendName:"webgl",kernelFunc:KP};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZP{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JP=`
if (a == b) {
  return 1.0;
};
return a / b;`,QP=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,A4=vn({opSnippet:JP,packedOpSnippet:QP,checkOutOfBounds:!0}),eD={kernelName:T0,backendName:"webgl",kernelFunc:A4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R4="return a - b;",I4=vn({opSnippet:R4,packedOpSnippet:R4,supportsComplex:!0,cpuKernelImpl:tA}),tD={kernelName:o1,backendName:"webgl",kernelFunc:I4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N4(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{dim:i}=s,o=gn([i],r.shape),a=M4({inputs:{x:r},backend:t,attrs:{reductionIndices:o,keepDims:!1}}),l=ms(a.shape,o),c=Me({inputs:{x:a},backend:t,attrs:{shape:l}}),u=I4({inputs:{a:r,b:c},backend:t}),h=w4({inputs:{x:u},backend:t}),d=Oc({inputs:{x:h},backend:t,attrs:{axis:o,keepDims:!1}}),p=Me({inputs:{x:d},backend:t,attrs:{shape:l}}),f=A4({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const nD={kernelName:Km,backendName:"webgl",kernelFunc:N4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sD(n){const{inputs:e,backend:t,attrs:s}=n,{logits:r}=e,{numSamples:i,seed:o,normalized:a}=s,l=a?r:N4({inputs:{logits:r},backend:t,attrs:{dim:r.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new ZP(c,u,i),d=[[o]],p=t.runWebGLProgram(h,[l],"int32",d);return a||t.disposeIntermediateTensorInfo(l),p}const rD={kernelName:hm,backendName:"webgl",kernelFunc:sD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L4="return -x;";function iD(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const i=t.texData.get(s.dataId),[o,a]=UM(i.values,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,o)}let r;return ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?r=new Fo(s.shape,L4):r=new Yr(s.shape,L4),t.runWebGLProgram(r,[s],s.dtype)}const oD={kernelName:pm,backendName:"webgl",kernelFunc:iD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aD=hg;function lD(n){Rs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=s,c=t.readSync(r.dataId),u=t.readSync(i.dataId),{selectedIndices:h}=aD(c,u,o,a,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const cD={kernelName:mm,backendName:"webgl",kernelFunc:lD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uD=dg;function hD(n){Rs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=s,u=t.readSync(r.dataId),h=t.readSync(i.dataId),{selectedIndices:d,validOutputs:p}=uD(u,h,o,a,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const dD={kernelName:gm,backendName:"webgl",kernelFunc:hD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pD=pg;function fD(n){Rs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:r,scores:i}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(r.dataId),h=t.readSync(i.dataId),d=o,p=a,f=l,m=c,{selectedIndices:y,selectedScores:g}=pD(u,h,d,p,f,m);return[t.makeTensorInfo([y.length],"int32",new Int32Array(y)),t.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const mD={kernelName:xm,backendName:"webgl",kernelFunc:fD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gD{constructor(e,t,s,r){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${r}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xD=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:r}=e,{depth:i,onValue:o,offValue:a}=s,l=Se(r.shape),c=new gD(l,i,o,a),u=Me({inputs:{x:r},backend:t,attrs:{shape:[l]}}),h=t.runWebGLProgram(c,[u],r.dtype);t.disposeIntermediateTensorInfo(u);const d=[...r.shape,i],p=Me({inputs:{x:h},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(h),p},yD={kernelName:vm,backendName:"webgl",kernelFunc:xD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gc(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const r=ul({inputs:{input:s},backend:t}),i=Gc({inputs:{x:r},backend:t}),o=Vc({inputs:{input:s},backend:t}),a=Gc({inputs:{x:o},backend:t}),l=Zr({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return hl({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const vD={kernelName:f1,backendName:"webgl",kernelFunc:Gc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P4(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const r=ul({inputs:{input:s},backend:t}),i=P4({inputs:{x:r},backend:t}),o=Vc({inputs:{input:s},backend:t}),a=Gc({inputs:{x:o},backend:t}),l=Zr({inputs:{real:i,imag:a},backend:t});return t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(a),l}else return hl({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const bD={kernelName:ym,backendName:"webgl",kernelFunc:P4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wD(n){const{inputs:e,backend:t,attrs:s}=n,{axis:r}=s;if(e.length===1)return $d({inputs:{input:e[0]},backend:t,attrs:{dim:r}});const i=e[0].shape,o=e[0].dtype;e.forEach(u=>{As(i,u.shape,"All tensors passed to stack must have matching shapes"),O(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const h=$d({inputs:{input:u},backend:t,attrs:{dim:r}});return a.push(h),h}),c=h4({inputs:l,backend:t,attrs:{axis:r}});return a.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const _D={kernelName:bm,backendName:"webgl",kernelFunc:wD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SD{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const r=e.length,i=Dt(r),o=t.map(c=>c[0]).join(","),a=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,r);if(r===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${i} start = ${i}(${o});
      ${i} end = ${i}(${a});

      void main() {
        ${i} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${i} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TD{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((m,y)=>m[0]+e[y]+m[1]);const r=e.length,i=Dt(r),o=t.map(m=>m[0]).join(","),a=t.map((m,y)=>m[0]+e[y]).join(","),l=In("rc",r),c=In("source",r),u=`${l[r-1]} < ${this.outputShape[r-1]}`,h=r===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${i} rc = outputLoc;`,`${l[r-1]} += 1;
       if(${u}) {
      `,r===1?"":`}
       rc = outputLoc;
       ${l[r-2]} += 1;
       if(${l[r-2]} < ${this.outputShape[r-2]}) {`,r===1?"":`  ${l[r-1]} += 1;
         if(${u}) {`],p=r===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let m=0,y=r===1?2:4;m<y;m++)f+=`
        ${d[m]}
        if (${p}) {
          result[${m}] = float(value);
        } else {
          ${i} source = rc - start;
          result[${m}] = getChannel(getX(${c.join()}), ${h});
        }
      `;f+=r===1?"} ":"}}",this.userCode=`
      const ${i} start = ${i}(${o});
      const ${i} end = ${i}(${a});

      void main() {
        ${i} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D4=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{paddings:i,constantValue:o}=s;if(Se(r.shape)===0){const c=i.map((u,h)=>u[0]+r.shape[h]+u[1]);return hl({backend:t,attrs:{shape:c,value:o,dtype:r.dtype}})}const a=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TD(r.shape,i,o):new SD(r.shape,i,o),l=[[o]];return t.runWebGLProgram(a,[r],r.dtype,l)},ED={kernelName:wm,backendName:"webgl",kernelFunc:D4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CD=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,MD=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  vec4 isNaN = vec4(lessThan(a, vec4(0.0))) * vec4(lessThan(floor(b), b));
  `+kc+`
  return result;
`,AD=vn({opSnippet:CD,packedOpSnippet:MD}),RD={kernelName:_m,backendName:"webgl",kernelFunc:AD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ID(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{axis:i,keepDims:o}=s,a=r.shape.length,l=[],c=gn(i,r.shape);let u=c;const h=gs(u,a);let d=r;h!=null&&(d=Nn({inputs:{x:r},backend:t,attrs:{perm:h}}),u=xs(u.length,a),l.push(d)),Ps("prod",u,a);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:m,outShape:y,outDtype:g}=GM(d.shape,d.dtype,f,u);p=t.makeTensorInfo(y,g,m)}else{const[f,m]=Xs(d.shape,u),y=Se(m),g=Me({inputs:{x:d},backend:t,attrs:{shape:[-1,y]}}),x=xh(r.dtype),b=Vi(g,x,"prod",t);p=Me({inputs:{x:b},backend:t,attrs:{shape:f}}),l.push(g),l.push(b)}if(o){l.push(p);const f=ms(p.shape,c);p=Me({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const ND={kernelName:Tm,backendName:"webgl",kernelFunc:ID};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k4=n=>{const{backend:e,attrs:t}=n,{start:s,stop:r,step:i,dtype:o}=t,a=WM(s,r,i,o);return e.makeTensorInfo([a.length],o,a)},LD={kernelName:Em,backendName:"webgl",kernelFunc:k4};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PD="return 1.0 / x;",DD=vt({opSnippet:PD}),kD={kernelName:Mm,backendName:"webgl",kernelFunc:DD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $D=ks+`
  return (x < 0.0) ? 0.0 : x;
`,FD=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,OD=vt({opSnippet:$D,packedOpSnippet:FD}),BD={kernelName:Am,backendName:"webgl",kernelFunc:OD};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zD=ks+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,UD=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,VD=vt({opSnippet:zD,packedOpSnippet:UD}),GD={kernelName:Lm,backendName:"webgl",kernelFunc:VD};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class WD{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;i?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HD{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s];let d;i?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XD(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,u=ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new HD(r.shape,l,c,i,o):new WD(r.shape,l,c,i,o);return t.runWebGLProgram(u,[r],"float32")}const jD={kernelName:Nm,backendName:"webgl",kernelFunc:XD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qD{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${r-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${i-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KD(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new qD(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const YD={kernelName:U9,backendName:"webgl",kernelFunc:KD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZD{constructor(e,t,s,r,i){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;i?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JD{constructor(e,t,s,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,t,s,c];const u=[r&&t>1?a-1:a,r&&s>1?l-1:l],h=[r&&t>1?t-1:t,r&&s>1?s-1:s],d=r?"0.5":"0.0";let p;i?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QD(n){const{inputs:e,backend:t,attrs:s}=n,{images:r}=e,{alignCorners:i,halfPixelCenters:o,size:a}=s,[l,c]=a,u=ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new JD(r.shape,l,c,i,o):new ZD(r.shape,l,c,i,o);return t.runWebGLProgram(u,[r],r.dtype)}const ek={kernelName:Im,backendName:"webgl",kernelFunc:QD};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tk{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,r,i]=t,[,o,a]=e,l=[s&&o>1?r-1:r,s&&a>1?i-1:i],c=[s&&o>1?o-1:o,s&&a>1?a-1:a],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,m=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${m});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nk(n){const{inputs:e,backend:t,attrs:s}=n,{images:r,dy:i}=e,{alignCorners:o}=s,a=new tk(i.shape,r.shape,o);return t.runWebGLProgram(a,[i],i.dtype)}const sk={kernelName:z9,backendName:"webgl",kernelFunc:nk};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rk{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const r=a=>t.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,i=e.map((a,l)=>r(l)).join(","),o=Dt(s);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${i}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ik{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const r=In("rc",s),i=`${r[s-1]} + 1 < ${this.outputShape[s-1]}`,o=`${r[s-2]} + 1 < ${this.outputShape[s-2]}`,a=Dt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${i}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(r.slice())};
          if(${i}){
            result.g = ${c(r.slice())};
          }
          if(${o}) {
            result.b = ${u(r.slice())};
            if(${i}) {
              result.a = ${h(r.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function u(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const m=e.map((x,b)=>p(b,f)),y=m.join(","),g=m.slice(-2).join(",");return`getChannel(getX(${y}), vec2(${g}))`}function p(f,m){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${m[f]} - 1`:`${m[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ok(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{dims:i}=s,o=r.shape.length,a=gn(i,r.shape);if(o===0)return Kn({inputs:{x:r},backend:t});const l=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ik(r.shape,a):new rk(r.shape,a);return t.runWebGLProgram(l,[r],r.dtype)}const ak={kernelName:Pm,backendName:"webgl",kernelFunc:ok};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lk{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],r=e[2];this.outputShape=e;let i="";typeof t=="number"?i=`float outputValue = ${t.toFixed(2)};`:i=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${i}
          if(coordX >= 0 && coordX < ${r} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ck={kernelName:g1,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:r,fillValue:i,center:o}=e,a=t,l=new lk(s.shape,i),[c,u]=xg(o,s.shape[1],s.shape[2]),h=[[c,u,Math.sin(r),Math.cos(r)]];return a.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uk=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,hk=vt({opSnippet:uk}),dk={kernelName:Dm,backendName:"webgl",kernelFunc:hk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pk="return inversesqrt(x);",fk=vt({opSnippet:pk,cpuKernelImpl:HM}),mk={kernelName:km,backendName:"webgl",kernelFunc:fk};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $4{constructor(e,t,s,r,i,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=Dt(i.length),c=Dt(o.length);let u="";s===1?u="i":s===2&&(u="i, j");const h=`getIndices(${u})`;let d="";r===1?d="i":r===2&&(d="i, coords[1]");const p=`getUpdates(${d})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${i});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gk(n){const{inputs:e,backend:t,attrs:s}=n,{indices:r,updates:i}=e,{shape:o}=s,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=Ch(i,r,o),d=[h/c,c];if(h===0)return t.makeTensorInfo(o,r.dtype);const p=Me({inputs:{x:r},backend:t,attrs:{shape:[l,a]}}),f=Me({inputs:{x:i},backend:t,attrs:{shape:[l,c]}}),m=t.makeTensorInfo([],"float32",new Float32Array([0])),y=new $4(l,a,p.shape.length,f.shape.length,u,d),g=t.runWebGLProgram(y,[f,p,m],f.dtype),x=Me({inputs:{x:g},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),x}const xk={kernelName:$m,backendName:"webgl",kernelFunc:gk};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yk{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let r,i;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)i="resRC",r="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);r=l.join(),i=c.join()}const o=Dt(s);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${r});
        if (cVal >= 1.0) {
          setOutput(getA(${i}));
        } else {
          setOutput(getB(${i}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vk(n){const{inputs:e,backend:t}=n,{condition:s,t:r,e:i}=e,o=new yk(s.shape.length,r.shape,r.shape.length);return t.runWebGLProgram(o,[s,r,i],Hs(r.dtype,i.dtype))}const bk={kernelName:Fm,backendName:"webgl",kernelFunc:vk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wk=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${bg};
  float scale = ${wg};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,_k=vt({opSnippet:wk}),Sk={kernelName:Om,backendName:"webgl",kernelFunc:_k};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F4="return 1.0 / (1.0 + exp(-1.0 * x));",Tk=vt({opSnippet:F4,packedOpSnippet:F4,cpuKernelImpl:XM}),Ek={kernelName:Gm,backendName:"webgl",kernelFunc:Tk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ck=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,Mk=vt({opSnippet:Ck}),Ak={kernelName:Vm,backendName:"webgl",kernelFunc:Mk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rk=Y3+`
  return sin(x);
`,Ik=vt({opSnippet:Rk}),Nk={kernelName:zm,backendName:"webgl",kernelFunc:Ik};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lk=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,Pk=vt({opSnippet:Lk}),Dk={kernelName:Um,backendName:"webgl",kernelFunc:Pk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kk=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,$k=vt({opSnippet:kk}),Fk={kernelName:Wm,backendName:"webgl",kernelFunc:$k};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ok=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{blockShape:i,paddings:o}=s;O(r.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=i.reduce((g,x)=>g*x),l=[[0,0]];l.push(...o);for(let g=1+i.length;g<r.shape.length;++g)l.push([0,0]);const c=[],u=D4({inputs:{x:r},backend:t,attrs:{paddings:l,constantValue:0}}),h=qh(u.shape,i,a,!1),d=Kh(h.length,i.length,!1),p=Yh(u.shape,i,a,!1),f=Me({inputs:{x:u},backend:t,attrs:{shape:h}}),m=Nn({inputs:{x:f},backend:t,attrs:{perm:d}}),y=Me({inputs:{x:m},backend:t,attrs:{shape:p}});return c.push(u),c.push(f),c.push(m),c.forEach(g=>t.disposeIntermediateTensorInfo(g)),y},Bk={kernelName:jm,backendName:"webgl",kernelFunc:Ok};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zk(n){const{inputs:e,backend:t}=n,{indices:s,values:r,denseShape:i,defaultValue:o}=e;if(i.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${i.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(r.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${r.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=t.readSync(s.dataId),l=t.readSync(r.dataId),c=t.readSync(i.dataId),u=t.readSync(o.dataId)[0],[h,d,p,f,m]=qM(a,s.shape,s.dtype,l,r.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],r.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(y=>Number(y)))),t.makeTensorInfo([m.length],s.dtype,new Int32Array(m))]}const Uk={kernelName:Ym,backendName:"webgl",kernelFunc:zk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vk(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:r,newShape:i}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(r.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${i.shape}`);const o=Array.from(t.readSync(r.dataId)),a=t.readSync(s.dataId),l=Array.from(t.readSync(i.dataId)),[c,u,h]=KM(a,s.shape,s.dtype,o,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],i.dtype,new Int32Array(h))]}const Gk={kernelName:Zm,backendName:"webgl",kernelFunc:Vk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wk(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,u]=O3(o,s.shape,s.dtype,a,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const Hk={kernelName:Jm,backendName:"webgl",kernelFunc:Wk};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xk(n){const{inputs:e,backend:t}=n,{data:s,indices:r,segmentIds:i}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(r.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${r.shape}`);if(i.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${i.shape}`);const o=t.readSync(s.dataId),a=t.readSync(r.dataId),l=t.readSync(i.dataId),[c,u]=O3(o,s.shape,s.dtype,a,l);return t.makeTensorInfo(u,s.dtype,c)}const jk={kernelName:Qm,backendName:"webgl",kernelFunc:Xk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qk(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:r,sparseValues:i,defaultValue:o}=e,{outputShape:a}=s,{sliceRank:l,numUpdates:c,strides:u,outputSize:h}=Ch(i,r,a),d=!1,p=new $4(c,l,r.shape.length,i.shape.length,u,[h,1],d),f=t.runWebGLProgram(p,[i,r,o],i.dtype),m=Me({inputs:{x:f},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(f),m}const Kk={kernelName:e1,backendName:"webgl",kernelFunc:qk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yk(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{numOrSizeSplits:i,axis:o}=s,a=gn(o,r.shape)[0],l=kg(r,i,a),c=r.shape.length,u=new Array(c).fill(0),h=r.shape.slice();return l.map(d=>{const p=[...h];p[a]=d;const f=Bo({inputs:{x:r},backend:t,attrs:{begin:u,size:p}});return u[a]+=d,f})}const Zk={kernelName:qm,backendName:"webgl",kernelFunc:Yk};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O4="return sqrt(x);",Jk=vt({opSnippet:O4,packedOpSnippet:O4,cpuKernelImpl:YM}),Qk={kernelName:Hm,backendName:"webgl",kernelFunc:Jk};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e$="return x * x;",t$=vt({opSnippet:e$}),n$={kernelName:V9,backendName:"webgl",kernelFunc:t$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B4="return (a - b) * (a - b);",s$=vn({opSnippet:B4,packedOpSnippet:B4}),r$={kernelName:t1,backendName:"webgl",kernelFunc:s$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$({inputs:n,attrs:e,backend:t}){const{x:s}=n,r=ks+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,i=new Yr(s.shape,r);return t.runWebGLProgram(i,[s],s.dtype)}const o$={kernelName:m1,backendName:"webgl",kernelFunc:i$};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class a${constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const r=s.length,i=Dt(s.length),o=Dt(s.length);let a="";if(r===1)a="coords * strides + begin";else{let l=0;a=s.map((c,u)=>(l++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${i} begin = ${i}(${e});
      ${i} strides = ${i}(${t});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{begin:i,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:y,isSimpleSlice:g,begin:x,end:b,strides:w}=S2(r.shape,i,o,a,l,c,u,h,d);let C;if(m)C=Me({inputs:{x:r},backend:t,attrs:{shape:f}});else if(y||g){O(r.shape.length>=1,()=>`Input must have rank at least 1, got: ${r.shape.length}`);const E=p2(x,b,w),A=Bo({inputs:{x:r},backend:t,attrs:{begin:x,size:E}});C=Me({inputs:{x:A},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(A)}else if(t.shouldExecuteOnCPU([r])){const A=t.readSync(r.dataId),$=xn(r.shape,r.dtype,A),B=ZM(p,$,w,x);C=t.makeTensorInfo(f,r.dtype,B.values)}else{const A=new a$(x,w,p);C=t.runWebGLProgram(A,[r],r.dtype)}const M=Me({inputs:{x:C},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(C),M}const c$={kernelName:n1,backendName:"webgl",kernelFunc:l$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u$(n){const{inputs:e,backend:t,attrs:s}=n,{separator:r,nGramWidths:i,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.readSync(u.dataId),p=t.readSync(h.dataId),[f,m]=JM(d,p,r,i,o,a,l,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",m)]}const h$={kernelName:s1,backendName:"webgl",kernelFunc:u$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d$(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:r}=s,{input:i,delimiter:o}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(i.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${i.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=t.readSync(i.dataId),l=t.readSync(o.dataId)[0],[c,u,h]=QM(a,l,r),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const p$={kernelName:r1,backendName:"webgl",kernelFunc:d$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f$(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:r}=s,{input:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=t.readSync(i.dataId),a=eA(o,r);return t.makeTensorInfo(i.shape,"int32",a)}const m$={kernelName:i1,backendName:"webgl",kernelFunc:f$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g$="return tan(x);",x$=vt({opSnippet:g$}),y$={kernelName:a1,backendName:"webgl",kernelFunc:x$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v$=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,b$=vt({opSnippet:v$}),w$={kernelName:l1,backendName:"webgl",kernelFunc:b$};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _${constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let o=0;o<s.length;o++)s[o]=e[o]*t[o];this.outputShape=s,this.rank=s.length;const r=Dt(this.rank),i=S$(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        setOutput(getA(${i}));
      }
    `}}function S$(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let r=0;r<n.length;r++)s.push(`imod(${t[r]}, ${n[r]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z4(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{reps:i}=s;if(r.dtype==="string"||r.shape.length>5){const l=t.readSync(r.dataId),c=r.dtype==="string"?l.map(d=>Oa(d)):l,u=xn(r.shape,r.dtype,c),h=nA(u,i);return t.makeTensorInfo(h.shape,h.dtype,h.values)}const o=new _$(r.shape,i);return t.runWebGLProgram(o,[r],r.dtype)}const T$={kernelName:eh,backendName:"webgl",kernelFunc:z4};class E${constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class C${constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gi(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function U4(n){let e=1;for(;e<n;)e*=2;return e}function M$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r}=e,{k:i,sorted:o}=s,a=ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=r.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([r])||u<a||i>l){const B=t.readSync(r.dataId),[R,K]=sA(B,c,r.dtype,i,o);return[t.makeTensorInfo(R.shape,R.dtype,R.values),t.makeTensorInfo(K.shape,K.dtype,K.values)]}if(i===0)return c[c.length-1]=0,[t.makeTensorInfo(c,r.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[r,hl({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(r.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(r):r,m=Se(c)/u,y=Me({inputs:{x:p},attrs:{shape:[m,u]},backend:t});d&&Gi(t,p);const g=U4(i),x=U4(u);let b=null;const w=()=>b===null?[y,y]:[y,b],C=(B,R,K)=>{const F=w(),z=new E$(K),H=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[B],[R]],j=b;b=t.runWebGLProgram(z,F,"int32",H),Gi(t,j)};for(let B=1;B<g;B*=2){const R=B*2;for(let K=B;K>=1;K/=2)C(R,K,[m,x])}for(let B=x;B>g;B/=2){const R=w(),K=new C$([m,B/2]),z=[[u],[b===null?1:0],[g]],V=b;b=t.runWebGLProgram(K,R,"int32",z),Gi(t,V);const H=g/2,j=H*2;for(let ae=H;ae>=1;ae/=2)C(j,ae,b.shape)}let M=b;b=Bo({inputs:{x:b},backend:t,attrs:{begin:0,size:[m,i]}}),Gi(t,M);let E=C4({inputs:{x:y,indices:b},backend:t,attrs:{axis:1,batchDims:1}});Gi(t,y);const A=c.slice(0,-1);A.push(i),M=b,b=Me({inputs:{x:b},attrs:{shape:A},backend:t}),Gi(t,M);const $=E;return E=Me({inputs:{x:E},attrs:{shape:A},backend:t}),Gi(t,$),[E,b]}const A$={kernelName:c1,backendName:"webgl",kernelFunc:M$};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class R${constructor(e,t,s,r,i,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=s==="nearest"?1:2;let l;switch(r){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${i});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${i});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n){const{inputs:e,backend:t,attrs:s}=n,{image:r,transforms:i}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=s,[u,h,d,p]=r.shape,[f,m]=c!=null?c:[h,d],y=[u,f,m,p],g=new R$(h,d,o,a,l,y);return t.runWebGLProgram(g,[r,i],"float32")}const N$={kernelName:u1,backendName:"webgl",kernelFunc:I$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n){const{inputs:e,attrs:t,backend:s}=n,{axis:r}=t,{x:i}=e;il(i,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=s.readSync(i.dataId),{outputValues:a,outputShape:l,indices:c}=rA(o,r,i.shape,i.dtype);return[s.makeTensorInfo(l,i.dtype,a),s.makeTensorInfo([c.length],"int32",c)]}const P$={kernelName:d1,backendName:"webgl",kernelFunc:L$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n){const{inputs:e,backend:t,attrs:s}=n,{value:r}=e;let{axis:i}=s;i<0&&(i+=r.shape.length);const o=r,a=o.shape.length,l=r.shape[i],c=new Array(a-1);let u=0;for(let m=0;m<a;m++)m!==i&&(c[u++]=o.shape[m]);const h=[],d=new Array(a).fill(0),p=o.shape.slice();p[i]=1;const f=new Array(l);for(let m=0;m<f.length;m++){d[i]=m;const y=Bo({inputs:{x:o},backend:t,attrs:{begin:d,size:p}}),g=Me({inputs:{x:y},backend:t,attrs:{shape:c}});f[m]=g,h.push(y)}return h.forEach(m=>t.disposeIntermediateTensorInfo(m)),f}const k$={kernelName:p1,backendName:"webgl",kernelFunc:D$};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $${constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,r=e.batchSize,i=e.inSize,o=e.numSegments,a=o*Math.ceil(i/s);this.outputShape=[r,a];const l="0.0",c="sumValue",u=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";i%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return initializationValue;
        }
      `);let f="";i%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${i}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(n){const{inputs:e,backend:t,attrs:s}=n,{x:r,segmentIds:i}=e,{numSegments:o}=s,a=r.shape.length,l=[];let c=0;const u=gs([c],a);let h=r;u!=null&&(h=Nn({inputs:{x:r},backend:t,attrs:{perm:u}}),l.push(h),c=xs(1,a)[0]);const d=qg(h.shape,c,o),p=Se([h.shape[c]]),f=Me({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const m=xh(r.dtype),y=(w,C,M,E,A)=>{const $=w.shape[0],B=w.shape[1],R=jg(B,A),K={windowSize:R,inSize:B,batchSize:$,numSegments:A},F=new $$(K,C),z=t.compileAndRun(F,[w,M],E);if(l.push(z),z.shape[1]===A)return z;const V=k4({backend:t,attrs:{start:0,stop:A,step:1,dtype:"float32"}}),H=z4({inputs:{x:V},backend:t,attrs:{reps:[B/R]}});return l.push(V),l.push(H),y(z,C,H,E,A)},g=y(f,"unsortedSegmentSum",i,m,o),x=Me({inputs:{x:g},backend:t,attrs:{shape:d}});let b=x;if(u!=null){l.push(x);const w=Bh(u);b=Nn({inputs:{x:b},backend:t,attrs:{perm:w}})}return l.forEach(w=>t.disposeIntermediateTensorInfo(w)),b}const O$={kernelName:G9,backendName:"webgl",kernelFunc:F$};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B$=[pP,gP,ZA,QA,nR,iR,aR,uR,dR,fR,yR,bR,SR,CR,PR,RR,$R,zR,OR,WR,XR,qR,JR,iI,aI,cI,mI,xI,wI,TI,LA,RI,BI,UI,PI,HI,jI,GI,YI,QI,nN,rN,oN,cN,mN,xN,hN,bN,SN,EN,RN,PN,FN,zN,UN,VN,WN,XN,qN,YN,JN,nL,iL,lL,uL,pL,gL,bL,TL,NA,CL,MI,RL,LL,kL,DA,BL,GL,HL,JL,KL,nP,iP,cP,yP,CP,TP,IP,LP,DP,_P,$P,OP,VP,XP,YP,rD,BA,oD,cD,dD,mD,hI,yD,bD,_D,ED,RD,$A,ND,LD,dI,eD,kD,GD,BD,UA,jD,YD,ek,sk,ak,ck,dk,mk,xk,bk,Sk,Ek,Ak,Nk,Dk,sI,nD,Fk,Bk,Uk,Gk,Hk,jk,Kk,Zk,Qk,n$,r$,o$,c$,h$,p$,m$,tD,qA,y$,w$,T$,A$,N$,KA,P$,k$,O$,vD];for(const n of B$)X9(n);async function z$(){return(await navigator.mediaDevices.enumerateDevices()).filter(t=>t.kind==="videoinput")}async function U$(n,e,t){try{return await navigator.mediaDevices.getUserMedia({video:{deviceId:n,width:e,height:t}})}catch(s){return Promise.reject(s)}}function V$(n){var e;(e=n.srcObject)==null||e.getTracks().forEach(t=>{t.stop()}),n.autoplay=!0,n.playsInline=!0}function G$(n,e,t){return new Promise(async s=>{const r=await z$();if(r.length){const i=await U$(r[0].deviceId,e,t);V$(n),n.onloadeddata=s,n.srcObject=i}})}/**
 * @license
 * Copyright 2010-2021 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Fd="135",W$=0,V4=1,H$=2,G4=1,X$=2,dl=3,Vo=0,un=1,Wi=2,W4=1,Jr=0,pl=1,H4=2,X4=3,j4=4,j$=5,Go=100,q$=101,K$=102,q4=103,K4=104,Y$=200,Z$=201,J$=202,Q$=203,Y4=204,Z4=205,eF=206,tF=207,nF=208,sF=209,rF=210,iF=0,oF=1,aF=2,Od=3,lF=4,cF=5,uF=6,hF=7,Wc=0,dF=1,pF=2,Hi=0,fF=1,mF=2,gF=3,xF=4,yF=5,J4=300,fl=301,ml=302,Bd=303,zd=304,Hc=306,Ud=307,Wo=1e3,Yn=1001,Xc=1002,hn=1003,Vd=1004,Gd=1005,Zn=1006,Q4=1007,Ho=1008,Qr=1009,vF=1010,bF=1011,gl=1012,wF=1013,jc=1014,Er=1015,Xo=1016,_F=1017,SF=1018,TF=1019,jo=1020,EF=1021,ei=1022,Ln=1023,CF=1024,MF=1025,AF=Ln,Xi=1026,qo=1027,RF=1028,IF=1029,NF=1030,LF=1031,PF=1032,DF=1033,ex=33776,tx=33777,nx=33778,sx=33779,rx=35840,ix=35841,ox=35842,ax=35843,kF=36196,lx=37492,cx=37496,$F=37808,FF=37809,OF=37810,BF=37811,zF=37812,UF=37813,VF=37814,GF=37815,WF=37816,HF=37817,XF=37818,jF=37819,qF=37820,KF=37821,YF=36492,ZF=37840,JF=37841,QF=37842,eO=37843,tO=37844,nO=37845,sO=37846,rO=37847,iO=37848,oO=37849,aO=37850,lO=37851,cO=37852,uO=37853,hO=2200,dO=2201,pO=2202,xl=2300,Ko=2301,Wd=2302,Yo=2400,Zo=2401,qc=2402,Hd=2500,ux=2501,fO=0,mO=1,hx=2,Jn=3e3,ti=3001,Xd=3007,jd=3002,dx=3004,px=3005,fx=3006,gO=3200,xO=3201,ji=0,yO=1,qd=7680,vO=519,yl=35044,Kc=35048,mx="300 es";class qi{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const r=this._listeners[e];if(r!==void 0){const i=r.indexOf(t);i!==-1&&r.splice(i,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const r=s.slice(0);for(let i=0,o=r.length;i<o;i++)r[i].call(this,e);e.target=null}}}const Tn=[];for(let n=0;n<256;n++)Tn[n]=(n<16?"0":"")+n.toString(16);let Yc=1234567;const vl=Math.PI/180,bl=180/Math.PI;function Ss(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(Tn[n&255]+Tn[n>>8&255]+Tn[n>>16&255]+Tn[n>>24&255]+"-"+Tn[e&255]+Tn[e>>8&255]+"-"+Tn[e>>16&15|64]+Tn[e>>24&255]+"-"+Tn[t&63|128]+Tn[t>>8&255]+"-"+Tn[t>>16&255]+Tn[t>>24&255]+Tn[s&255]+Tn[s>>8&255]+Tn[s>>16&255]+Tn[s>>24&255]).toUpperCase()}function Qn(n,e,t){return Math.max(e,Math.min(t,n))}function Kd(n,e){return(n%e+e)%e}function bO(n,e,t,s,r){return s+(n-e)*(r-s)/(t-e)}function wO(n,e,t){return n!==e?(t-n)/(e-n):0}function wl(n,e,t){return(1-t)*n+t*e}function _O(n,e,t,s){return wl(n,e,1-Math.exp(-t*s))}function SO(n,e=1){return e-Math.abs(Kd(n,e*2)-e)}function TO(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function EO(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function CO(n,e){return n+Math.floor(Math.random()*(e-n+1))}function MO(n,e){return n+Math.random()*(e-n)}function AO(n){return n*(.5-Math.random())}function RO(n){return n!==void 0&&(Yc=n%2147483647),Yc=Yc*16807%2147483647,(Yc-1)/2147483646}function IO(n){return n*vl}function NO(n){return n*bl}function Yd(n){return(n&n-1)==0&&n!==0}function gx(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function xx(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function LO(n,e,t,s,r){const i=Math.cos,o=Math.sin,a=i(t/2),l=o(t/2),c=i((e+s)/2),u=o((e+s)/2),h=i((e-s)/2),d=o((e-s)/2),p=i((s-e)/2),f=o((s-e)/2);switch(r){case"XYX":n.set(a*u,l*h,l*d,a*c);break;case"YZY":n.set(l*d,a*u,l*h,a*c);break;case"ZXZ":n.set(l*h,l*d,a*u,a*c);break;case"XZX":n.set(a*u,l*f,l*p,a*c);break;case"YXY":n.set(l*p,a*u,l*f,a*c);break;case"ZYZ":n.set(l*f,l*p,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+r)}}var PO=Object.freeze({__proto__:null,DEG2RAD:vl,RAD2DEG:bl,generateUUID:Ss,clamp:Qn,euclideanModulo:Kd,mapLinear:bO,inverseLerp:wO,lerp:wl,damp:_O,pingpong:SO,smoothstep:TO,smootherstep:EO,randInt:CO,randFloat:MO,randFloatSpread:AO,seededRandom:RO,degToRad:IO,radToDeg:NO,isPowerOfTwo:Yd,ceilPowerOfTwo:gx,floorPowerOfTwo:xx,setQuaternionFromProperEuler:LO});class pe{constructor(e=0,t=0){this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this)}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this)}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6],this.y=r[1]*t+r[4]*s+r[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t,s){return s!==void 0&&console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),r=Math.sin(t),i=this.x-e.x,o=this.y-e.y;return this.x=i*s-o*r+e.x,this.y=i*r+o*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}pe.prototype.isVector2=!0;class En{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(e,t,s,r,i,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=r,u[2]=a,u[3]=t,u[4]=i,u[5]=l,u[6]=s,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,i=this.elements,o=s[0],a=s[3],l=s[6],c=s[1],u=s[4],h=s[7],d=s[2],p=s[5],f=s[8],m=r[0],y=r[3],g=r[6],x=r[1],b=r[4],w=r[7],C=r[2],M=r[5],E=r[8];return i[0]=o*m+a*x+l*C,i[3]=o*y+a*b+l*M,i[6]=o*g+a*w+l*E,i[1]=c*m+u*x+h*C,i[4]=c*y+u*b+h*M,i[7]=c*g+u*w+h*E,i[2]=d*m+p*x+f*C,i[5]=d*y+p*b+f*M,i[8]=d*g+p*w+f*E,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return t*o*u-t*a*c-s*i*u+s*a*l+r*i*c-r*o*l}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=u*o-a*c,d=a*l-u*i,p=c*i-o*l,f=t*h+s*d+r*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/f;return e[0]=h*m,e[1]=(r*c-u*s)*m,e[2]=(a*s-r*o)*m,e[3]=d*m,e[4]=(u*t-r*l)*m,e[5]=(r*i-a*t)*m,e[6]=p*m,e[7]=(s*l-c*t)*m,e[8]=(o*t-s*i)*m,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,r,i,o,a){const l=Math.cos(i),c=Math.sin(i);return this.set(s*l,s*c,-s*(l*o+c*a)+o+e,-r*c,r*l,-r*(-c*o+l*a)+a+t,0,0,1),this}scale(e,t){const s=this.elements;return s[0]*=e,s[3]*=e,s[6]*=e,s[1]*=t,s[4]*=t,s[7]*=t,this}rotate(e){const t=Math.cos(e),s=Math.sin(e),r=this.elements,i=r[0],o=r[3],a=r[6],l=r[1],c=r[4],u=r[7];return r[0]=t*i+s*l,r[3]=t*o+s*c,r[6]=t*a+s*u,r[1]=-s*i+t*l,r[4]=-s*o+t*c,r[7]=-s*a+t*u,this}translate(e,t){const s=this.elements;return s[0]+=e*s[2],s[3]+=e*s[5],s[6]+=e*s[8],s[1]+=t*s[2],s[4]+=t*s[5],s[7]+=t*s[8],this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<9;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}En.prototype.isMatrix3=!0;function yx(n){if(n.length===0)return-1/0;let e=n[0];for(let t=1,s=n.length;t<s;++t)n[t]>e&&(e=n[t]);return e}function Zc(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function vx(n,e=0){let t=3735928559^e,s=1103547991^e;for(let r=0,i;r<n.length;r++)i=n.charCodeAt(r),t=Math.imul(t^i,2654435761),s=Math.imul(s^i,1597334677);return t=Math.imul(t^t>>>16,2246822507)^Math.imul(s^s>>>13,3266489909),s=Math.imul(s^s>>>16,2246822507)^Math.imul(t^t>>>13,3266489909),4294967296*(2097151&s)+(t>>>0)}let Jo;class Qo{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement=="undefined")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{Jo===void 0&&(Jo=Zc("canvas")),Jo.width=e.width,Jo.height=e.height;const s=Jo.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),t=Jo}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}}let DO=0;class dn extends qi{constructor(e=dn.DEFAULT_IMAGE,t=dn.DEFAULT_MAPPING,s=Yn,r=Yn,i=Zn,o=Ho,a=Ln,l=Qr,c=1,u=Jn){super();Object.defineProperty(this,"id",{value:DO++}),this.uuid=Ss(),this.name="",this.image=e,this.mipmaps=[],this.mapping=t,this.wrapS=s,this.wrapT=r,this.magFilter=i,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new pe(0,0),this.repeat=new pe(1,1),this.center=new pe(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new En,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.encoding=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.image=e.image,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.encoding=e.encoding,this.userData=JSON.parse(JSON.stringify(e.userData)),this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.5,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};if(this.image!==void 0){const r=this.image;if(r.uuid===void 0&&(r.uuid=Ss()),!t&&e.images[r.uuid]===void 0){let i;if(Array.isArray(r)){i=[];for(let o=0,a=r.length;o<a;o++)r[o].isDataTexture?i.push(Zd(r[o].image)):i.push(Zd(r[o]))}else i=Zd(r);e.images[r.uuid]={uuid:r.uuid,url:i}}s.image=r.uuid}return JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==J4)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Wo:e.x=e.x-Math.floor(e.x);break;case Yn:e.x=e.x<0?0:1;break;case Xc:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Wo:e.y=e.y-Math.floor(e.y);break;case Yn:e.y=e.y<0?0:1;break;case Xc:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&this.version++}}dn.DEFAULT_IMAGE=void 0;dn.DEFAULT_MAPPING=J4;dn.prototype.isTexture=!0;function Zd(n){return typeof HTMLImageElement!="undefined"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&n instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&n instanceof ImageBitmap?Qo.getDataURL(n):n.data?{data:Array.prototype.slice.call(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}class $t{constructor(e=0,t=0,s=0,r=1){this.x=e,this.y=t,this.z=s,this.w=r}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,r){return this.x=e,this.y=t,this.z=s,this.w=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,i=this.w,o=e.elements;return this.x=o[0]*t+o[4]*s+o[8]*r+o[12]*i,this.y=o[1]*t+o[5]*s+o[9]*r+o[13]*i,this.z=o[2]*t+o[6]*s+o[10]*r+o[14]*i,this.w=o[3]*t+o[7]*s+o[11]*r+o[15]*i,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,r,i;const o=.01,a=.1,l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],p=l[5],f=l[9],m=l[2],y=l[6],g=l[10];if(Math.abs(u-d)<o&&Math.abs(h-m)<o&&Math.abs(f-y)<o){if(Math.abs(u+d)<a&&Math.abs(h+m)<a&&Math.abs(f+y)<a&&Math.abs(c+p+g-3)<a)return this.set(1,0,0,0),this;t=Math.PI;const b=(c+1)/2,w=(p+1)/2,C=(g+1)/2,M=(u+d)/4,E=(h+m)/4,A=(f+y)/4;return b>w&&b>C?b<o?(s=0,r=.707106781,i=.707106781):(s=Math.sqrt(b),r=M/s,i=E/s):w>C?w<o?(s=.707106781,r=0,i=.707106781):(r=Math.sqrt(w),s=M/r,i=A/r):C<o?(s=.707106781,r=.707106781,i=0):(i=Math.sqrt(C),s=E/i,r=A/i),this.set(s,r,i,t),this}let x=Math.sqrt((y-f)*(y-f)+(h-m)*(h-m)+(d-u)*(d-u));return Math.abs(x)<.001&&(x=1),this.x=(y-f)/x,this.y=(h-m)/x,this.z=(d-u)/x,this.w=Math.acos((c+p+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this.w=this.w<0?Math.ceil(this.w):Math.floor(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t,s){return s!==void 0&&console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}$t.prototype.isVector4=!0;class Ts extends qi{constructor(e,t,s={}){super();this.width=e,this.height=t,this.depth=1,this.scissor=new $t(0,0,e,t),this.scissorTest=!1,this.viewport=new $t(0,0,e,t),this.texture=new dn(void 0,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.encoding),this.texture.isRenderTargetTexture=!0,this.texture.image={width:e,height:t,depth:1},this.texture.generateMipmaps=s.generateMipmaps!==void 0?s.generateMipmaps:!1,this.texture.internalFormat=s.internalFormat!==void 0?s.internalFormat:null,this.texture.minFilter=s.minFilter!==void 0?s.minFilter:Zn,this.depthBuffer=s.depthBuffer!==void 0?s.depthBuffer:!0,this.stencilBuffer=s.stencilBuffer!==void 0?s.stencilBuffer:!1,this.depthTexture=s.depthTexture!==void 0?s.depthTexture:null}setTexture(e){e.image={width:this.width,height:this.height,depth:this.depth},this.texture=e}setSize(e,t,s=1){(this.width!==e||this.height!==t||this.depth!==s)&&(this.width=e,this.height=t,this.depth=s,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=s,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.image=Vu({},this.texture.image),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this}dispose(){this.dispatchEvent({type:"dispose"})}}Ts.prototype.isWebGLRenderTarget=!0;class kO extends Ts{constructor(e,t,s){super(e,t);const r=this.texture;this.texture=[];for(let i=0;i<s;i++)this.texture[i]=r.clone()}setSize(e,t,s=1){if(this.width!==e||this.height!==t||this.depth!==s){this.width=e,this.height=t,this.depth=s;for(let r=0,i=this.texture.length;r<i;r++)this.texture[r].image.width=e,this.texture[r].image.height=t,this.texture[r].image.depth=s;this.dispose()}return this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t),this}copy(e){this.dispose(),this.width=e.width,this.height=e.height,this.depth=e.depth,this.viewport.set(0,0,this.width,this.height),this.scissor.set(0,0,this.width,this.height),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.depthTexture=e.depthTexture,this.texture.length=0;for(let t=0,s=e.texture.length;t<s;t++)this.texture[t]=e.texture[t].clone();return this}}kO.prototype.isWebGLMultipleRenderTargets=!0;class Jd extends Ts{constructor(e,t,s={}){super(e,t,s);this.samples=4,this.ignoreDepthForMultisampleCopy=s.ignoreDepth!==void 0?s.ignoreDepth:!0,this.useRenderToTexture=s.useRenderToTexture!==void 0?s.useRenderToTexture:!1,this.useRenderbuffer=this.useRenderToTexture===!1}copy(e){return super.copy.call(this,e),this.samples=e.samples,this.useRenderToTexture=e.useRenderToTexture,this.useRenderbuffer=e.useRenderbuffer,this}}Jd.prototype.isWebGLMultisampleRenderTarget=!0;class Vn{constructor(e=0,t=0,s=0,r=1){this._x=e,this._y=t,this._z=s,this._w=r}static slerp(e,t,s,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),s.slerpQuaternions(e,t,r)}static slerpFlat(e,t,s,r,i,o,a){let l=s[r+0],c=s[r+1],u=s[r+2],h=s[r+3];const d=i[o+0],p=i[o+1],f=i[o+2],m=i[o+3];if(a===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(a===1){e[t+0]=d,e[t+1]=p,e[t+2]=f,e[t+3]=m;return}if(h!==m||l!==d||c!==p||u!==f){let y=1-a;const g=l*d+c*p+u*f+h*m,x=g>=0?1:-1,b=1-g*g;if(b>Number.EPSILON){const C=Math.sqrt(b),M=Math.atan2(C,g*x);y=Math.sin(y*M)/C,a=Math.sin(a*M)/C}const w=a*x;if(l=l*y+d*w,c=c*y+p*w,u=u*y+f*w,h=h*y+m*w,y===1-a){const C=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=C,c*=C,u*=C,h*=C}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,s,r,i,o){const a=s[r],l=s[r+1],c=s[r+2],u=s[r+3],h=i[o],d=i[o+1],p=i[o+2],f=i[o+3];return e[t]=a*f+u*h+l*p-c*d,e[t+1]=l*f+u*d+c*h-a*p,e[t+2]=c*f+u*p+a*d-l*h,e[t+3]=u*f-a*h-l*d-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,r){return this._x=e,this._y=t,this._z=s,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){if(!(e&&e.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const s=e._x,r=e._y,i=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(s/2),u=a(r/2),h=a(i/2),d=l(s/2),p=l(r/2),f=l(i/2);switch(o){case"XYZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"YXZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"ZXY":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"ZYX":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"YZX":this._x=d*u*h+c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h-d*p*f;break;case"XZY":this._x=d*u*h-c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,r=Math.sin(s);return this._x=e.x*r,this._y=e.y*r,this._z=e.z*r,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],r=t[4],i=t[8],o=t[1],a=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=s+a+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(i-c)*p,this._z=(o-r)*p}else if(s>a&&s>h){const p=2*Math.sqrt(1+s-a-h);this._w=(u-l)/p,this._x=.25*p,this._y=(r+o)/p,this._z=(i+c)/p}else if(a>h){const p=2*Math.sqrt(1+a-s-h);this._w=(i-c)/p,this._x=(r+o)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+h-s-a);this._w=(o-r)/p,this._x=(i+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(Qn(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const r=Math.min(1,t/s);return this.slerp(e,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e,t){return t!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(e,t)):this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,r=e._y,i=e._z,o=e._w,a=t._x,l=t._y,c=t._z,u=t._w;return this._x=s*u+o*a+r*c-i*l,this._y=r*u+o*l+i*a-s*c,this._z=i*u+o*c+s*l-r*a,this._w=o*u-s*a-r*l-i*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,r=this._y,i=this._z,o=this._w;let a=o*e._w+s*e._x+r*e._y+i*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=s,this._y=r,this._z=i,this;const l=1-a*a;if(l<=Number.EPSILON){const p=1-t;return this._w=p*o+t*this._w,this._x=p*s+t*this._x,this._y=p*r+t*this._y,this._z=p*i+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=o*h+this._w*d,this._x=s*h+this._x*d,this._y=r*h+this._y*d,this._z=i*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,s){this.copy(e).slerp(t,s)}random(){const e=Math.random(),t=Math.sqrt(1-e),s=Math.sqrt(e),r=2*Math.PI*Math.random(),i=2*Math.PI*Math.random();return this.set(t*Math.cos(r),s*Math.sin(i),s*Math.cos(i),t*Math.sin(r))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}Vn.prototype.isQuaternion=!0;class L{constructor(e=0,t=0,s=0){this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e,t){return t!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(e,t)):(this.x+=e.x,this.y+=e.y,this.z+=e.z,this)}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e,t){return t!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(e,t)):(this.x-=e.x,this.y-=e.y,this.z-=e.z,this)}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(e,t)):(this.x*=e.x,this.y*=e.y,this.z*=e.z,this)}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return e&&e.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(bx.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(bx.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6]*r,this.y=i[1]*t+i[4]*s+i[7]*r,this.z=i[2]*t+i[5]*s+i[8]*r,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,r=this.z,i=e.elements,o=1/(i[3]*t+i[7]*s+i[11]*r+i[15]);return this.x=(i[0]*t+i[4]*s+i[8]*r+i[12])*o,this.y=(i[1]*t+i[5]*s+i[9]*r+i[13])*o,this.z=(i[2]*t+i[6]*s+i[10]*r+i[14])*o,this}applyQuaternion(e){const t=this.x,s=this.y,r=this.z,i=e.x,o=e.y,a=e.z,l=e.w,c=l*t+o*r-a*s,u=l*s+a*t-i*r,h=l*r+i*s-o*t,d=-i*t-o*s-a*r;return this.x=c*l+d*-i+u*-a-h*-o,this.y=u*l+d*-o+h*-i-c*-a,this.z=h*l+d*-a+c*-o-u*-i,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,r=this.z,i=e.elements;return this.x=i[0]*t+i[4]*s+i[8]*r,this.y=i[1]*t+i[5]*s+i[9]*r,this.z=i[2]*t+i[6]*s+i[10]*r,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e,t){return t!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(e,t)):this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,r=e.y,i=e.z,o=t.x,a=t.y,l=t.z;return this.x=r*l-i*a,this.y=i*o-s*l,this.z=s*a-r*o,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return Qd.copy(this).projectOnVector(e),this.sub(Qd)}reflect(e){return this.sub(Qd.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(Qn(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,r=this.z-e.z;return t*t+s*s+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const r=Math.sin(t)*e;return this.x=r*Math.sin(s),this.y=Math.cos(t)*e,this.z=r*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),r=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=r,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t,s){return s!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,s=Math.sqrt(1-e**2);return this.x=s*Math.cos(t),this.y=s*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}L.prototype.isVector3=!0;const Qd=new L,bx=new Vn;class jt{constructor(e=new L(1/0,1/0,1/0),t=new L(-1/0,-1/0,-1/0)){this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){let t=1/0,s=1/0,r=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.length;l<c;l+=3){const u=e[l],h=e[l+1],d=e[l+2];u<t&&(t=u),h<s&&(s=h),d<r&&(r=d),u>i&&(i=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,s,r),this.max.set(i,o,a),this}setFromBufferAttribute(e){let t=1/0,s=1/0,r=1/0,i=-1/0,o=-1/0,a=-1/0;for(let l=0,c=e.count;l<c;l++){const u=e.getX(l),h=e.getY(l),d=e.getZ(l);u<t&&(t=u),h<s&&(s=h),d<r&&(r=d),u>i&&(i=u),h>o&&(o=h),d>a&&(a=d)}return this.min.set(t,s,r),this.max.set(i,o,a),this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=_l.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e){return this.makeEmpty(),this.expandByObject(e)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e){e.updateWorldMatrix(!1,!1);const t=e.geometry;t!==void 0&&(t.boundingBox===null&&t.computeBoundingBox(),ep.copy(t.boundingBox),ep.applyMatrix4(e.matrixWorld),this.union(ep));const s=e.children;for(let r=0,i=s.length;r<i;r++)this.expandByObject(s[r]);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,_l),_l.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Sl),Jc.subVectors(this.max,Sl),ea.subVectors(e.a,Sl),ta.subVectors(e.b,Sl),na.subVectors(e.c,Sl),ni.subVectors(ta,ea),si.subVectors(na,ta),Ki.subVectors(ea,na);let t=[0,-ni.z,ni.y,0,-si.z,si.y,0,-Ki.z,Ki.y,ni.z,0,-ni.x,si.z,0,-si.x,Ki.z,0,-Ki.x,-ni.y,ni.x,0,-si.y,si.x,0,-Ki.y,Ki.x,0];return!tp(t,ea,ta,na,Jc)||(t=[1,0,0,0,1,0,0,0,1],!tp(t,ea,ta,na,Jc))?!1:(Qc.crossVectors(ni,si),t=[Qc.x,Qc.y,Qc.z],tp(t,ea,ta,na,Jc))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return _l.copy(e).clamp(this.min,this.max).sub(e).length()}getBoundingSphere(e){return this.getCenter(e.center),e.radius=this.getSize(_l).length()*.5,e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Cr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Cr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Cr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Cr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Cr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Cr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Cr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Cr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Cr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}jt.prototype.isBox3=!0;const Cr=[new L,new L,new L,new L,new L,new L,new L,new L],_l=new L,ep=new jt,ea=new L,ta=new L,na=new L,ni=new L,si=new L,Ki=new L,Sl=new L,Jc=new L,Qc=new L,Yi=new L;function tp(n,e,t,s,r){for(let i=0,o=n.length-3;i<=o;i+=3){Yi.fromArray(n,i);const a=r.x*Math.abs(Yi.x)+r.y*Math.abs(Yi.y)+r.z*Math.abs(Yi.z),l=e.dot(Yi),c=t.dot(Yi),u=s.dot(Yi);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const $O=new jt,wx=new L,np=new L,sp=new L;class Zi{constructor(e=new L,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):$O.setFromPoints(e).getCenter(s);let r=0;for(let i=0,o=e.length;i<o;i++)r=Math.max(r,s.distanceToSquared(e[i]));return this.radius=Math.sqrt(r),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){sp.subVectors(e,this.center);const t=sp.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),r=(s-this.radius)*.5;this.center.add(sp.multiplyScalar(r/s)),this.radius+=r}return this}union(e){return np.subVectors(e.center,this.center).normalize().multiplyScalar(e.radius),this.expandByPoint(wx.copy(e.center).add(np)),this.expandByPoint(wx.copy(e.center).sub(np)),this}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Mr=new L,rp=new L,eu=new L,ri=new L,ip=new L,tu=new L,op=new L;class sa{constructor(e=new L,t=new L(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.direction).multiplyScalar(e).add(this.origin)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Mr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.direction).multiplyScalar(s).add(this.origin)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Mr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Mr.copy(this.direction).multiplyScalar(t).add(this.origin),Mr.distanceToSquared(e))}distanceSqToSegment(e,t,s,r){rp.copy(e).add(t).multiplyScalar(.5),eu.copy(t).sub(e).normalize(),ri.copy(this.origin).sub(rp);const i=e.distanceTo(t)*.5,o=-this.direction.dot(eu),a=ri.dot(this.direction),l=-ri.dot(eu),c=ri.lengthSq(),u=Math.abs(1-o*o);let h,d,p,f;if(u>0)if(h=o*l-a,d=o*a-l,f=i*u,h>=0)if(d>=-f)if(d<=f){const m=1/u;h*=m,d*=m,p=h*(h+o*d+2*a)+d*(o*h+d+2*l)+c}else d=i,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d=-i,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;else d<=-f?(h=Math.max(0,-(-o*i+a)),d=h>0?-i:Math.min(Math.max(-i,-l),i),p=-h*h+d*(d+2*l)+c):d<=f?(h=0,d=Math.min(Math.max(-i,-l),i),p=d*(d+2*l)+c):(h=Math.max(0,-(o*i+a)),d=h>0?i:Math.min(Math.max(-i,-l),i),p=-h*h+d*(d+2*l)+c);else d=o>0?-i:i,h=Math.max(0,-(o*d+a)),p=-h*h+d*(d+2*l)+c;return s&&s.copy(this.direction).multiplyScalar(h).add(this.origin),r&&r.copy(eu).multiplyScalar(d).add(rp),p}intersectSphere(e,t){Mr.subVectors(e.center,this.origin);const s=Mr.dot(this.direction),r=Mr.dot(Mr)-s*s,i=e.radius*e.radius;if(r>i)return null;const o=Math.sqrt(i-r),a=s-o,l=s+o;return a<0&&l<0?null:a<0?this.at(l,t):this.at(a,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,r,i,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(s=(e.min.x-d.x)*c,r=(e.max.x-d.x)*c):(s=(e.max.x-d.x)*c,r=(e.min.x-d.x)*c),u>=0?(i=(e.min.y-d.y)*u,o=(e.max.y-d.y)*u):(i=(e.max.y-d.y)*u,o=(e.min.y-d.y)*u),s>o||i>r||((i>s||s!==s)&&(s=i),(o<r||r!==r)&&(r=o),h>=0?(a=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(a=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),s>l||a>r)||((a>s||s!==s)&&(s=a),(l<r||r!==r)&&(r=l),r<0)?null:this.at(s>=0?s:r,t)}intersectsBox(e){return this.intersectBox(e,Mr)!==null}intersectTriangle(e,t,s,r,i){ip.subVectors(t,e),tu.subVectors(s,e),op.crossVectors(ip,tu);let o=this.direction.dot(op),a;if(o>0){if(r)return null;a=1}else if(o<0)a=-1,o=-o;else return null;ri.subVectors(this.origin,e);const l=a*this.direction.dot(tu.crossVectors(ri,tu));if(l<0)return null;const c=a*this.direction.dot(ip.cross(ri));if(c<0||l+c>o)return null;const u=-a*ri.dot(op);return u<0?null:this.at(u/o,i)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ze{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,s,r,i,o,a,l,c,u,h,d,p,f,m,y){const g=this.elements;return g[0]=e,g[4]=t,g[8]=s,g[12]=r,g[1]=i,g[5]=o,g[9]=a,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=p,g[7]=f,g[11]=m,g[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ze().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,r=1/ra.setFromMatrixColumn(e,0).length(),i=1/ra.setFromMatrixColumn(e,1).length(),o=1/ra.setFromMatrixColumn(e,2).length();return t[0]=s[0]*r,t[1]=s[1]*r,t[2]=s[2]*r,t[3]=0,t[4]=s[4]*i,t[5]=s[5]*i,t[6]=s[6]*i,t[7]=0,t[8]=s[8]*o,t[9]=s[9]*o,t[10]=s[10]*o,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,s=e.x,r=e.y,i=e.z,o=Math.cos(s),a=Math.sin(s),l=Math.cos(r),c=Math.sin(r),u=Math.cos(i),h=Math.sin(i);if(e.order==="XYZ"){const d=o*u,p=o*h,f=a*u,m=a*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=p+f*c,t[5]=d-m*c,t[9]=-a*l,t[2]=m-d*c,t[6]=f+p*c,t[10]=o*l}else if(e.order==="YXZ"){const d=l*u,p=l*h,f=c*u,m=c*h;t[0]=d+m*a,t[4]=f*a-p,t[8]=o*c,t[1]=o*h,t[5]=o*u,t[9]=-a,t[2]=p*a-f,t[6]=m+d*a,t[10]=o*l}else if(e.order==="ZXY"){const d=l*u,p=l*h,f=c*u,m=c*h;t[0]=d-m*a,t[4]=-o*h,t[8]=f+p*a,t[1]=p+f*a,t[5]=o*u,t[9]=m-d*a,t[2]=-o*c,t[6]=a,t[10]=o*l}else if(e.order==="ZYX"){const d=o*u,p=o*h,f=a*u,m=a*h;t[0]=l*u,t[4]=f*c-p,t[8]=d*c+m,t[1]=l*h,t[5]=m*c+d,t[9]=p*c-f,t[2]=-c,t[6]=a*l,t[10]=o*l}else if(e.order==="YZX"){const d=o*l,p=o*c,f=a*l,m=a*c;t[0]=l*u,t[4]=m-d*h,t[8]=f*h+p,t[1]=h,t[5]=o*u,t[9]=-a*u,t[2]=-c*u,t[6]=p*h+f,t[10]=d-m*h}else if(e.order==="XZY"){const d=o*l,p=o*c,f=a*l,m=a*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+m,t[5]=o*u,t[9]=p*h-f,t[2]=f*h-p,t[6]=a*u,t[10]=m*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(FO,e,OO)}lookAt(e,t,s){const r=this.elements;return is.subVectors(e,t),is.lengthSq()===0&&(is.z=1),is.normalize(),ii.crossVectors(s,is),ii.lengthSq()===0&&(Math.abs(s.z)===1?is.x+=1e-4:is.z+=1e-4,is.normalize(),ii.crossVectors(s,is)),ii.normalize(),nu.crossVectors(is,ii),r[0]=ii.x,r[4]=nu.x,r[8]=is.x,r[1]=ii.y,r[5]=nu.y,r[9]=is.y,r[2]=ii.z,r[6]=nu.z,r[10]=is.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,r=t.elements,i=this.elements,o=s[0],a=s[4],l=s[8],c=s[12],u=s[1],h=s[5],d=s[9],p=s[13],f=s[2],m=s[6],y=s[10],g=s[14],x=s[3],b=s[7],w=s[11],C=s[15],M=r[0],E=r[4],A=r[8],$=r[12],B=r[1],R=r[5],K=r[9],F=r[13],z=r[2],V=r[6],H=r[10],j=r[14],ae=r[3],fe=r[7],Q=r[11],te=r[15];return i[0]=o*M+a*B+l*z+c*ae,i[4]=o*E+a*R+l*V+c*fe,i[8]=o*A+a*K+l*H+c*Q,i[12]=o*$+a*F+l*j+c*te,i[1]=u*M+h*B+d*z+p*ae,i[5]=u*E+h*R+d*V+p*fe,i[9]=u*A+h*K+d*H+p*Q,i[13]=u*$+h*F+d*j+p*te,i[2]=f*M+m*B+y*z+g*ae,i[6]=f*E+m*R+y*V+g*fe,i[10]=f*A+m*K+y*H+g*Q,i[14]=f*$+m*F+y*j+g*te,i[3]=x*M+b*B+w*z+C*ae,i[7]=x*E+b*R+w*V+C*fe,i[11]=x*A+b*K+w*H+C*Q,i[15]=x*$+b*F+w*j+C*te,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],r=e[8],i=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],p=e[14],f=e[3],m=e[7],y=e[11],g=e[15];return f*(+i*l*h-r*c*h-i*a*d+s*c*d+r*a*p-s*l*p)+m*(+t*l*p-t*c*d+i*o*d-r*o*p+r*c*u-i*l*u)+y*(+t*c*h-t*a*p-i*o*h+s*o*p+i*a*u-s*c*u)+g*(-r*a*u-t*l*h+t*a*d+r*o*h-s*o*d+s*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],r=e[2],i=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],m=e[13],y=e[14],g=e[15],x=h*y*c-m*d*c+m*l*p-a*y*p-h*l*g+a*d*g,b=f*d*c-u*y*c-f*l*p+o*y*p+u*l*g-o*d*g,w=u*m*c-f*h*c+f*a*p-o*m*p-u*a*g+o*h*g,C=f*h*l-u*m*l-f*a*d+o*m*d+u*a*y-o*h*y,M=t*x+s*b+r*w+i*C;if(M===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const E=1/M;return e[0]=x*E,e[1]=(m*d*i-h*y*i-m*r*p+s*y*p+h*r*g-s*d*g)*E,e[2]=(a*y*i-m*l*i+m*r*c-s*y*c-a*r*g+s*l*g)*E,e[3]=(h*l*i-a*d*i-h*r*c+s*d*c+a*r*p-s*l*p)*E,e[4]=b*E,e[5]=(u*y*i-f*d*i+f*r*p-t*y*p-u*r*g+t*d*g)*E,e[6]=(f*l*i-o*y*i-f*r*c+t*y*c+o*r*g-t*l*g)*E,e[7]=(o*d*i-u*l*i+u*r*c-t*d*c-o*r*p+t*l*p)*E,e[8]=w*E,e[9]=(f*h*i-u*m*i-f*s*p+t*m*p+u*s*g-t*h*g)*E,e[10]=(o*m*i-f*a*i+f*s*c-t*m*c-o*s*g+t*a*g)*E,e[11]=(u*a*i-o*h*i-u*s*c+t*h*c+o*s*p-t*a*p)*E,e[12]=C*E,e[13]=(u*m*r-f*h*r+f*s*d-t*m*d-u*s*y+t*h*y)*E,e[14]=(f*a*r-o*m*r-f*s*l+t*m*l+o*s*y-t*a*y)*E,e[15]=(o*h*r-u*a*r+u*s*l-t*h*l-o*s*d+t*a*d)*E,this}scale(e){const t=this.elements,s=e.x,r=e.y,i=e.z;return t[0]*=s,t[4]*=r,t[8]*=i,t[1]*=s,t[5]*=r,t[9]*=i,t[2]*=s,t[6]*=r,t[10]*=i,t[3]*=s,t[7]*=r,t[11]*=i,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],r=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,r))}makeTranslation(e,t,s){return this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),r=Math.sin(t),i=1-s,o=e.x,a=e.y,l=e.z,c=i*o,u=i*a;return this.set(c*o+s,c*a-r*l,c*l+r*a,0,c*a+r*l,u*a+s,u*l-r*o,0,c*l-r*a,u*l+r*o,i*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,r,i,o){return this.set(1,s,i,0,e,1,o,0,t,r,1,0,0,0,0,1),this}compose(e,t,s){const r=this.elements,i=t._x,o=t._y,a=t._z,l=t._w,c=i+i,u=o+o,h=a+a,d=i*c,p=i*u,f=i*h,m=o*u,y=o*h,g=a*h,x=l*c,b=l*u,w=l*h,C=s.x,M=s.y,E=s.z;return r[0]=(1-(m+g))*C,r[1]=(p+w)*C,r[2]=(f-b)*C,r[3]=0,r[4]=(p-w)*M,r[5]=(1-(d+g))*M,r[6]=(y+x)*M,r[7]=0,r[8]=(f+b)*E,r[9]=(y-x)*E,r[10]=(1-(d+m))*E,r[11]=0,r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=1,this}decompose(e,t,s){const r=this.elements;let i=ra.set(r[0],r[1],r[2]).length();const o=ra.set(r[4],r[5],r[6]).length(),a=ra.set(r[8],r[9],r[10]).length();this.determinant()<0&&(i=-i),e.x=r[12],e.y=r[13],e.z=r[14],$s.copy(this);const c=1/i,u=1/o,h=1/a;return $s.elements[0]*=c,$s.elements[1]*=c,$s.elements[2]*=c,$s.elements[4]*=u,$s.elements[5]*=u,$s.elements[6]*=u,$s.elements[8]*=h,$s.elements[9]*=h,$s.elements[10]*=h,t.setFromRotationMatrix($s),s.x=i,s.y=o,s.z=a,this}makePerspective(e,t,s,r,i,o){o===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const a=this.elements,l=2*i/(t-e),c=2*i/(s-r),u=(t+e)/(t-e),h=(s+r)/(s-r),d=-(o+i)/(o-i),p=-2*o*i/(o-i);return a[0]=l,a[4]=0,a[8]=u,a[12]=0,a[1]=0,a[5]=c,a[9]=h,a[13]=0,a[2]=0,a[6]=0,a[10]=d,a[14]=p,a[3]=0,a[7]=0,a[11]=-1,a[15]=0,this}makeOrthographic(e,t,s,r,i,o){const a=this.elements,l=1/(t-e),c=1/(s-r),u=1/(o-i),h=(t+e)*l,d=(s+r)*c,p=(o+i)*u;return a[0]=2*l,a[4]=0,a[8]=0,a[12]=-h,a[1]=0,a[5]=2*c,a[9]=0,a[13]=-d,a[2]=0,a[6]=0,a[10]=-2*u,a[14]=-p,a[3]=0,a[7]=0,a[11]=0,a[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let r=0;r<16;r++)if(t[r]!==s[r])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}ze.prototype.isMatrix4=!0;const ra=new L,$s=new ze,FO=new L(0,0,0),OO=new L(1,1,1),ii=new L,nu=new L,is=new L,_x=new ze,Sx=new Vn;class ia{constructor(e=0,t=0,s=0,r=ia.DefaultOrder){this._x=e,this._y=t,this._z=s,this._order=r}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,r=this._order){return this._x=e,this._y=t,this._z=s,this._order=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const r=e.elements,i=r[0],o=r[4],a=r[8],l=r[1],c=r[5],u=r[9],h=r[2],d=r[6],p=r[10];switch(t){case"XYZ":this._y=Math.asin(Qn(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-o,i)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-Qn(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,i),this._z=0);break;case"ZXY":this._x=Math.asin(Qn(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,i));break;case"ZYX":this._y=Math.asin(-Qn(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,i)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(Qn(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,i)):(this._x=0,this._y=Math.atan2(a,p));break;case"XZY":this._z=Math.asin(-Qn(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(a,i)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return _x.makeRotationFromQuaternion(e),this.setFromRotationMatrix(_x,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Sx.setFromEuler(this),this.setFromQuaternion(Sx,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}toVector3(e){return e?e.set(this._x,this._y,this._z):new L(this._x,this._y,this._z)}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}}ia.prototype.isEuler=!0;ia.DefaultOrder="XYZ";ia.RotationOrders=["XYZ","YZX","ZXY","XZY","YXZ","ZYX"];class BO{constructor(){this.mask=1|0}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=4294967295|0}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!=0}isEnabled(e){return(this.mask&(1<<e|0))!=0}}let zO=0;const Tx=new L,oa=new Vn,Ar=new ze,su=new L,Tl=new L,UO=new L,VO=new Vn,Ex=new L(1,0,0),Cx=new L(0,1,0),Mx=new L(0,0,1),GO={type:"added"},Ax={type:"removed"};class Ye extends qi{constructor(){super();Object.defineProperty(this,"id",{value:zO++}),this.uuid=Ss(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Ye.DefaultUp.clone();const e=new L,t=new ia,s=new Vn,r=new L(1,1,1);function i(){s.setFromEuler(t,!1)}function o(){t.setFromQuaternion(s,void 0,!1)}t._onChange(i),s._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:r},modelViewMatrix:{value:new ze},normalMatrix:{value:new En}}),this.matrix=new ze,this.matrixWorld=new ze,this.matrixAutoUpdate=Ye.DefaultMatrixAutoUpdate,this.matrixWorldNeedsUpdate=!1,this.layers=new BO,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return oa.setFromAxisAngle(e,t),this.quaternion.multiply(oa),this}rotateOnWorldAxis(e,t){return oa.setFromAxisAngle(e,t),this.quaternion.premultiply(oa),this}rotateX(e){return this.rotateOnAxis(Ex,e)}rotateY(e){return this.rotateOnAxis(Cx,e)}rotateZ(e){return this.rotateOnAxis(Mx,e)}translateOnAxis(e,t){return Tx.copy(e).applyQuaternion(this.quaternion),this.position.add(Tx.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Ex,e)}translateY(e){return this.translateOnAxis(Cx,e)}translateZ(e){return this.translateOnAxis(Mx,e)}localToWorld(e){return e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return e.applyMatrix4(Ar.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?su.copy(e):su.set(e,t,s);const r=this.parent;this.updateWorldMatrix(!0,!1),Tl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ar.lookAt(Tl,su,this.up):Ar.lookAt(su,Tl,this.up),this.quaternion.setFromRotationMatrix(Ar),r&&(Ar.extractRotation(r.matrixWorld),oa.setFromRotationMatrix(Ar),this.quaternion.premultiply(oa.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(GO)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(Ax)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){for(let e=0;e<this.children.length;e++){const t=this.children[e];t.parent=null,t.dispatchEvent(Ax)}return this.children.length=0,this}attach(e){return this.updateWorldMatrix(!0,!1),Ar.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Ar.multiply(e.parent.matrixWorld)),e.applyMatrix4(Ar),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,r=this.children.length;s<r;s++){const o=this.children[s].getObjectByProperty(e,t);if(o!==void 0)return o}}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Tl,e,UO),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Tl,VO,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,r=t.length;s<r;s++)t[s].updateMatrixWorld(e)}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const r=this.children;for(let i=0,o=r.length;i<o;i++)r[i].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{}},s.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const r={};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.castShadow===!0&&(r.castShadow=!0),this.receiveShadow===!0&&(r.receiveShadow=!0),this.visible===!1&&(r.visible=!1),this.frustumCulled===!1&&(r.frustumCulled=!1),this.renderOrder!==0&&(r.renderOrder=this.renderOrder),JSON.stringify(this.userData)!=="{}"&&(r.userData=this.userData),r.layers=this.layers.mask,r.matrix=this.matrix.toArray(),this.matrixAutoUpdate===!1&&(r.matrixAutoUpdate=!1),this.isInstancedMesh&&(r.type="InstancedMesh",r.count=this.count,r.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(r.instanceColor=this.instanceColor.toJSON()));function i(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?r.background=this.background.toJSON():this.background.isTexture&&(r.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&(r.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){r.geometry=i(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];i(e.shapes,h)}else i(e.shapes,l)}}if(this.isSkinnedMesh&&(r.bindMode=this.bindMode,r.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(i(e.skeletons,this.skeleton),r.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(i(e.materials,this.material[l]));r.material=a}else r.material=i(e.materials,this.material);if(this.children.length>0){r.children=[];for(let a=0;a<this.children.length;a++)r.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){r.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];r.animations.push(i(e.animations,l))}}if(t){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),h=o(e.shapes),d=o(e.skeletons),p=o(e.animations);a.length>0&&(s.geometries=a),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),u.length>0&&(s.images=u),h.length>0&&(s.shapes=h),d.length>0&&(s.skeletons=d),p.length>0&&(s.animations=p)}return s.object=r,s;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const r=e.children[s];this.add(r.clone())}return this}}Ye.DefaultUp=new L(0,1,0);Ye.DefaultMatrixAutoUpdate=!0;Ye.prototype.isObject3D=!0;const Fs=new L,Rr=new L,ap=new L,Ir=new L,aa=new L,la=new L,Rx=new L,lp=new L,cp=new L,up=new L;class on{constructor(e=new L,t=new L,s=new L){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,r){r.subVectors(s,t),Fs.subVectors(e,t),r.cross(Fs);const i=r.lengthSq();return i>0?r.multiplyScalar(1/Math.sqrt(i)):r.set(0,0,0)}static getBarycoord(e,t,s,r,i){Fs.subVectors(r,t),Rr.subVectors(s,t),ap.subVectors(e,t);const o=Fs.dot(Fs),a=Fs.dot(Rr),l=Fs.dot(ap),c=Rr.dot(Rr),u=Rr.dot(ap),h=o*c-a*a;if(h===0)return i.set(-2,-1,-1);const d=1/h,p=(c*l-a*u)*d,f=(o*u-a*l)*d;return i.set(1-p-f,f,p)}static containsPoint(e,t,s,r){return this.getBarycoord(e,t,s,r,Ir),Ir.x>=0&&Ir.y>=0&&Ir.x+Ir.y<=1}static getUV(e,t,s,r,i,o,a,l){return this.getBarycoord(e,t,s,r,Ir),l.set(0,0),l.addScaledVector(i,Ir.x),l.addScaledVector(o,Ir.y),l.addScaledVector(a,Ir.z),l}static isFrontFacing(e,t,s,r){return Fs.subVectors(s,t),Rr.subVectors(e,t),Fs.cross(Rr).dot(r)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,r){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[r]),this}setFromAttributeAndIndices(e,t,s,r){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Fs.subVectors(this.c,this.b),Rr.subVectors(this.a,this.b),Fs.cross(Rr).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return on.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return on.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,s,r,i){return on.getUV(e,this.a,this.b,this.c,t,s,r,i)}containsPoint(e){return on.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return on.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,r=this.b,i=this.c;let o,a;aa.subVectors(r,s),la.subVectors(i,s),lp.subVectors(e,s);const l=aa.dot(lp),c=la.dot(lp);if(l<=0&&c<=0)return t.copy(s);cp.subVectors(e,r);const u=aa.dot(cp),h=la.dot(cp);if(u>=0&&h<=u)return t.copy(r);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return o=l/(l-u),t.copy(s).addScaledVector(aa,o);up.subVectors(e,i);const p=aa.dot(up),f=la.dot(up);if(f>=0&&p<=f)return t.copy(i);const m=p*c-l*f;if(m<=0&&c>=0&&f<=0)return a=c/(c-f),t.copy(s).addScaledVector(la,a);const y=u*f-p*h;if(y<=0&&h-u>=0&&p-f>=0)return Rx.subVectors(i,r),a=(h-u)/(h-u+(p-f)),t.copy(r).addScaledVector(Rx,a);const g=1/(y+m+d);return o=m*g,a=d*g,t.copy(s).addScaledVector(aa,o).addScaledVector(la,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}let WO=0;class pn extends qi{constructor(){super();Object.defineProperty(this,"id",{value:WO++}),this.uuid=Ss(),this.name="",this.type="Material",this.fog=!0,this.blending=pl,this.side=Vo,this.vertexColors=!1,this.opacity=1,this.format=Ln,this.transparent=!1,this.blendSrc=Y4,this.blendDst=Z4,this.blendEquation=Go,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.depthFunc=Od,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=vO,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=qd,this.stencilZFail=qd,this.stencilZPass=qd,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn("THREE.Material: '"+t+"' parameter is undefined.");continue}if(t==="shading"){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=s===W4;continue}const r=this[t];if(r===void 0){console.warn("THREE."+this.type+": '"+t+"' is not a property of this material.");continue}r&&r.isColor?r.set(s):r&&r.isVector3&&s&&s.isVector3?r.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==pl&&(s.blending=this.blending),this.side!==Vo&&(s.side=this.side),this.vertexColors&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.format!==Ln&&(s.format=this.format),this.transparent===!0&&(s.transparent=this.transparent),s.depthFunc=this.depthFunc,s.depthTest=this.depthTest,s.depthWrite=this.depthWrite,s.colorWrite=this.colorWrite,s.stencilWrite=this.stencilWrite,s.stencilWriteMask=this.stencilWriteMask,s.stencilFunc=this.stencilFunc,s.stencilRef=this.stencilRef,s.stencilFuncMask=this.stencilFuncMask,s.stencilFail=this.stencilFail,s.stencilZFail=this.stencilZFail,s.stencilZPass=this.stencilZPass,this.rotation&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaToCoverage===!0&&(s.alphaToCoverage=this.alphaToCoverage),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=this.premultipliedAlpha),this.wireframe===!0&&(s.wireframe=this.wireframe),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=this.flatShading),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),JSON.stringify(this.userData)!=="{}"&&(s.userData=this.userData);function r(i){const o=[];for(const a in i){const l=i[a];delete l.metadata,o.push(l)}return o}if(t){const i=r(e.textures),o=r(e.images);i.length>0&&(s.textures=i),o.length>0&&(s.images=o)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.fog=e.fog,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.format=e.format,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const r=t.length;s=new Array(r);for(let i=0;i!==r;++i)s[i]=t[i].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}pn.prototype.isMaterial=!0;const Ix={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},Os={h:0,s:0,l:0},ru={h:0,s:0,l:0};function hp(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}function dp(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function pp(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}class Le{constructor(e,t,s){return t===void 0&&s===void 0?this.set(e):this.setRGB(e,t,s)}set(e){return e&&e.isColor?this.copy(e):typeof e=="number"?this.setHex(e):typeof e=="string"&&this.setStyle(e),this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,this}setRGB(e,t,s){return this.r=e,this.g=t,this.b=s,this}setHSL(e,t,s){if(e=Kd(e,1),t=Qn(t,0,1),s=Qn(s,0,1),t===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+t):s+t-s*t,i=2*s-r;this.r=hp(i,r,e+1/3),this.g=hp(i,r,e),this.b=hp(i,r,e-1/3)}return this}setStyle(e){function t(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let s;if(s=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(e)){let r;const i=s[1],o=s[2];switch(i){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(255,parseInt(r[1],10))/255,this.g=Math.min(255,parseInt(r[2],10))/255,this.b=Math.min(255,parseInt(r[3],10))/255,t(r[4]),this;if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return this.r=Math.min(100,parseInt(r[1],10))/100,this.g=Math.min(100,parseInt(r[2],10))/100,this.b=Math.min(100,parseInt(r[3],10))/100,t(r[4]),this;break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o)){const a=parseFloat(r[1])/360,l=parseInt(r[2],10)/100,c=parseInt(r[3],10)/100;return t(r[4]),this.setHSL(a,l,c)}break}}else if(s=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=s[1],i=r.length;if(i===3)return this.r=parseInt(r.charAt(0)+r.charAt(0),16)/255,this.g=parseInt(r.charAt(1)+r.charAt(1),16)/255,this.b=parseInt(r.charAt(2)+r.charAt(2),16)/255,this;if(i===6)return this.r=parseInt(r.charAt(0)+r.charAt(1),16)/255,this.g=parseInt(r.charAt(2)+r.charAt(3),16)/255,this.b=parseInt(r.charAt(4)+r.charAt(5),16)/255,this}return e&&e.length>0?this.setColorName(e):this}setColorName(e){const t=Ix[e.toLowerCase()];return t!==void 0?this.setHex(t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copyGammaToLinear(e,t=2){return this.r=Math.pow(e.r,t),this.g=Math.pow(e.g,t),this.b=Math.pow(e.b,t),this}copyLinearToGamma(e,t=2){const s=t>0?1/t:1;return this.r=Math.pow(e.r,s),this.g=Math.pow(e.g,s),this.b=Math.pow(e.b,s),this}convertGammaToLinear(e){return this.copyGammaToLinear(this,e),this}convertLinearToGamma(e){return this.copyLinearToGamma(this,e),this}copySRGBToLinear(e){return this.r=dp(e.r),this.g=dp(e.g),this.b=dp(e.b),this}copyLinearToSRGB(e){return this.r=pp(e.r),this.g=pp(e.g),this.b=pp(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(){return this.r*255<<16^this.g*255<<8^this.b*255<<0}getHexString(){return("000000"+this.getHex().toString(16)).slice(-6)}getHSL(e){const t=this.r,s=this.g,r=this.b,i=Math.max(t,s,r),o=Math.min(t,s,r);let a,l;const c=(o+i)/2;if(o===i)a=0,l=0;else{const u=i-o;switch(l=c<=.5?u/(i+o):u/(2-i-o),i){case t:a=(s-r)/u+(s<r?6:0);break;case s:a=(r-t)/u+2;break;case r:a=(t-s)/u+4;break}a/=6}return e.h=a,e.s=l,e.l=c,e}getStyle(){return"rgb("+(this.r*255|0)+","+(this.g*255|0)+","+(this.b*255|0)+")"}offsetHSL(e,t,s){return this.getHSL(Os),Os.h+=e,Os.s+=t,Os.l+=s,this.setHSL(Os.h,Os.s,Os.l),this}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(Os),e.getHSL(ru);const s=wl(Os.h,ru.h,t),r=wl(Os.s,ru.s,t),i=wl(Os.l,ru.l,t);return this.setHSL(s,r,i),this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),e.normalized===!0&&(this.r/=255,this.g/=255,this.b/=255),this}toJSON(){return this.getHex()}}Le.NAMES=Ix;Le.prototype.isColor=!0;Le.prototype.r=1;Le.prototype.g=1;Le.prototype.b=1;class Ks extends pn{constructor(e){super();this.type="MeshBasicMaterial",this.color=new Le(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}Ks.prototype.isMeshBasicMaterial=!0;const Gt=new L,iu=new pe;class en{constructor(e,t,s){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s===!0,this.usage=yl,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let r=0,i=this.itemSize;r<i;r++)this.array[e+r]=t.array[s+r];return this}copyArray(e){return this.array.set(e),this}copyColorsArray(e){const t=this.array;let s=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",r),o=new Le),t[s++]=o.r,t[s++]=o.g,t[s++]=o.b}return this}copyVector2sArray(e){const t=this.array;let s=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",r),o=new pe),t[s++]=o.x,t[s++]=o.y}return this}copyVector3sArray(e){const t=this.array;let s=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",r),o=new L),t[s++]=o.x,t[s++]=o.y,t[s++]=o.z}return this}copyVector4sArray(e){const t=this.array;let s=0;for(let r=0,i=e.length;r<i;r++){let o=e[r];o===void 0&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",r),o=new $t),t[s++]=o.x,t[s++]=o.y,t[s++]=o.z,t[s++]=o.w}return this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)iu.fromBufferAttribute(this,t),iu.applyMatrix3(e),this.setXY(t,iu.x,iu.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)Gt.fromBufferAttribute(this,t),Gt.applyMatrix3(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)Gt.x=this.getX(t),Gt.y=this.getY(t),Gt.z=this.getZ(t),Gt.applyMatrix4(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Gt.x=this.getX(t),Gt.y=this.getY(t),Gt.z=this.getZ(t),Gt.applyNormalMatrix(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Gt.x=this.getX(t),Gt.y=this.getY(t),Gt.z=this.getZ(t),Gt.transformDirection(e),this.setXYZ(t,Gt.x,Gt.y,Gt.z);return this}set(e,t=0){return this.array.set(e,t),this}getX(e){return this.array[e*this.itemSize]}setX(e,t){return this.array[e*this.itemSize]=t,this}getY(e){return this.array[e*this.itemSize+1]}setY(e,t){return this.array[e*this.itemSize+1]=t,this}getZ(e){return this.array[e*this.itemSize+2]}setZ(e,t){return this.array[e*this.itemSize+2]=t,this}getW(e){return this.array[e*this.itemSize+3]}setW(e,t){return this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,r){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this}setXYZW(e,t,s,r,i){return e*=this.itemSize,this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=r,this.array[e+3]=i,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==yl&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}en.prototype.isBufferAttribute=!0;class Nx extends en{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class Lx extends en{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class HO extends en{constructor(e,t,s){super(new Uint16Array(e),t,s)}}HO.prototype.isFloat16BufferAttribute=!0;class tn extends en{constructor(e,t,s){super(new Float32Array(e),t,s)}}let XO=0;const Es=new ze,fp=new Ye,ca=new L,os=new jt,El=new jt,bn=new L;class Wt extends qi{constructor(){super();Object.defineProperty(this,"id",{value:XO++}),this.uuid=Ss(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(yx(e)>65535?Lx:Nx)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const i=new En().getNormalMatrix(e);s.applyNormalMatrix(i),s.needsUpdate=!0}const r=this.attributes.tangent;return r!==void 0&&(r.transformDirection(e),r.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Es.makeRotationFromQuaternion(e),this.applyMatrix4(Es),this}rotateX(e){return Es.makeRotationX(e),this.applyMatrix4(Es),this}rotateY(e){return Es.makeRotationY(e),this.applyMatrix4(Es),this}rotateZ(e){return Es.makeRotationZ(e),this.applyMatrix4(Es),this}translate(e,t,s){return Es.makeTranslation(e,t,s),this.applyMatrix4(Es),this}scale(e,t,s){return Es.makeScale(e,t,s),this.applyMatrix4(Es),this}lookAt(e){return fp.lookAt(e),fp.updateMatrix(),this.applyMatrix4(fp.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(ca).negate(),this.translate(ca.x,ca.y,ca.z),this}setFromPoints(e){const t=[];for(let s=0,r=e.length;s<r;s++){const i=e[s];t.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new tn(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new jt);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new L(-1/0,-1/0,-1/0),new L(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,r=t.length;s<r;s++){const i=t[s];os.setFromBufferAttribute(i),this.morphTargetsRelative?(bn.addVectors(this.boundingBox.min,os.min),this.boundingBox.expandByPoint(bn),bn.addVectors(this.boundingBox.max,os.max),this.boundingBox.expandByPoint(bn)):(this.boundingBox.expandByPoint(os.min),this.boundingBox.expandByPoint(os.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Zi);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new L,1/0);return}if(e){const s=this.boundingSphere.center;if(os.setFromBufferAttribute(e),t)for(let i=0,o=t.length;i<o;i++){const a=t[i];El.setFromBufferAttribute(a),this.morphTargetsRelative?(bn.addVectors(os.min,El.min),os.expandByPoint(bn),bn.addVectors(os.max,El.max),os.expandByPoint(bn)):(os.expandByPoint(El.min),os.expandByPoint(El.max))}os.getCenter(s);let r=0;for(let i=0,o=e.count;i<o;i++)bn.fromBufferAttribute(e,i),r=Math.max(r,s.distanceToSquared(bn));if(t)for(let i=0,o=t.length;i<o;i++){const a=t[i],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)bn.fromBufferAttribute(a,c),l&&(ca.fromBufferAttribute(e,c),bn.add(ca)),r=Math.max(r,s.distanceToSquared(bn))}this.boundingSphere.radius=Math.sqrt(r),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.array,r=t.position.array,i=t.normal.array,o=t.uv.array,a=r.length/3;t.tangent===void 0&&this.setAttribute("tangent",new en(new Float32Array(4*a),4));const l=t.tangent.array,c=[],u=[];for(let B=0;B<a;B++)c[B]=new L,u[B]=new L;const h=new L,d=new L,p=new L,f=new pe,m=new pe,y=new pe,g=new L,x=new L;function b(B,R,K){h.fromArray(r,B*3),d.fromArray(r,R*3),p.fromArray(r,K*3),f.fromArray(o,B*2),m.fromArray(o,R*2),y.fromArray(o,K*2),d.sub(h),p.sub(h),m.sub(f),y.sub(f);const F=1/(m.x*y.y-y.x*m.y);!isFinite(F)||(g.copy(d).multiplyScalar(y.y).addScaledVector(p,-m.y).multiplyScalar(F),x.copy(p).multiplyScalar(m.x).addScaledVector(d,-y.x).multiplyScalar(F),c[B].add(g),c[R].add(g),c[K].add(g),u[B].add(x),u[R].add(x),u[K].add(x))}let w=this.groups;w.length===0&&(w=[{start:0,count:s.length}]);for(let B=0,R=w.length;B<R;++B){const K=w[B],F=K.start,z=K.count;for(let V=F,H=F+z;V<H;V+=3)b(s[V+0],s[V+1],s[V+2])}const C=new L,M=new L,E=new L,A=new L;function $(B){E.fromArray(i,B*3),A.copy(E);const R=c[B];C.copy(R),C.sub(E.multiplyScalar(E.dot(R))).normalize(),M.crossVectors(A,R);const F=M.dot(u[B])<0?-1:1;l[B*4]=C.x,l[B*4+1]=C.y,l[B*4+2]=C.z,l[B*4+3]=F}for(let B=0,R=w.length;B<R;++B){const K=w[B],F=K.start,z=K.count;for(let V=F,H=F+z;V<H;V+=3)$(s[V+0]),$(s[V+1]),$(s[V+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new en(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let d=0,p=s.count;d<p;d++)s.setXYZ(d,0,0,0);const r=new L,i=new L,o=new L,a=new L,l=new L,c=new L,u=new L,h=new L;if(e)for(let d=0,p=e.count;d<p;d+=3){const f=e.getX(d+0),m=e.getX(d+1),y=e.getX(d+2);r.fromBufferAttribute(t,f),i.fromBufferAttribute(t,m),o.fromBufferAttribute(t,y),u.subVectors(o,i),h.subVectors(r,i),u.cross(h),a.fromBufferAttribute(s,f),l.fromBufferAttribute(s,m),c.fromBufferAttribute(s,y),a.add(u),l.add(u),c.add(u),s.setXYZ(f,a.x,a.y,a.z),s.setXYZ(m,l.x,l.y,l.z),s.setXYZ(y,c.x,c.y,c.z)}else for(let d=0,p=t.count;d<p;d+=3)r.fromBufferAttribute(t,d+0),i.fromBufferAttribute(t,d+1),o.fromBufferAttribute(t,d+2),u.subVectors(o,i),h.subVectors(r,i),u.cross(h),s.setXYZ(d+0,u.x,u.y,u.z),s.setXYZ(d+1,u.x,u.y,u.z),s.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),s.needsUpdate=!0}}merge(e,t){if(!(e&&e.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",e);return}t===void 0&&(t=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const s=this.attributes;for(const r in s){if(e.attributes[r]===void 0)continue;const o=s[r].array,a=e.attributes[r],l=a.array,c=a.itemSize*t,u=Math.min(l.length,o.length-c);for(let h=0,d=c;h<u;h++,d++)o[d]=l[h]}return this}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)bn.fromBufferAttribute(e,t),bn.normalize(),e.setXYZ(t,bn.x,bn.y,bn.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,h=a.normalized,d=new c.constructor(l.length*u);let p=0,f=0;for(let m=0,y=l.length;m<y;m++){a.isInterleavedBufferAttribute?p=l[m]*a.data.stride+a.offset:p=l[m]*u;for(let g=0;g<u;g++)d[f++]=c[p++]}return new en(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new Wt,s=this.index.array,r=this.attributes;for(const a in r){const l=r[a],c=e(l,s);t.setAttribute(a,c)}const i=this.morphAttributes;for(const a in i){const l=[],c=i[a];for(let u=0,h=c.length;u<h;u++){const d=c[u],p=e(d,s);l.push(p)}t.morphAttributes[a]=l}t.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const r={};let i=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h];u.push(p.toJSON(e.data))}u.length>0&&(r[l]=u,i=!0)}i&&(e.data.morphAttributes=r,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(t));const r=e.attributes;for(const c in r){const u=r[c];this.setAttribute(c,u.clone(t))}const i=e.morphAttributes;for(const c in i){const u=[],h=i[c];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const h=o[c];this.addGroup(h.start,h.count,h.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,e.parameters!==void 0&&(this.parameters=Object.assign({},e.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}Wt.prototype.isBufferGeometry=!0;const Px=new ze,ua=new sa,mp=new Zi,oi=new L,ai=new L,li=new L,gp=new L,xp=new L,yp=new L,ou=new L,au=new L,lu=new L,cu=new pe,uu=new pe,hu=new pe,vp=new L,du=new L;class fn extends Ye{constructor(e=new Wt,t=new Ks){super();this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=e.material,this.geometry=e.geometry,this}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(e,t){const s=this.geometry,r=this.material,i=this.matrixWorld;if(r===void 0||(s.boundingSphere===null&&s.computeBoundingSphere(),mp.copy(s.boundingSphere),mp.applyMatrix4(i),e.ray.intersectsSphere(mp)===!1)||(Px.copy(i).invert(),ua.copy(e.ray).applyMatrix4(Px),s.boundingBox!==null&&ua.intersectsBox(s.boundingBox)===!1))return;let o;if(s.isBufferGeometry){const a=s.index,l=s.attributes.position,c=s.morphAttributes.position,u=s.morphTargetsRelative,h=s.attributes.uv,d=s.attributes.uv2,p=s.groups,f=s.drawRange;if(a!==null)if(Array.isArray(r))for(let m=0,y=p.length;m<y;m++){const g=p[m],x=r[g.materialIndex],b=Math.max(g.start,f.start),w=Math.min(a.count,Math.min(g.start+g.count,f.start+f.count));for(let C=b,M=w;C<M;C+=3){const E=a.getX(C),A=a.getX(C+1),$=a.getX(C+2);o=pu(this,x,e,ua,l,c,u,h,d,E,A,$),o&&(o.faceIndex=Math.floor(C/3),o.face.materialIndex=g.materialIndex,t.push(o))}}else{const m=Math.max(0,f.start),y=Math.min(a.count,f.start+f.count);for(let g=m,x=y;g<x;g+=3){const b=a.getX(g),w=a.getX(g+1),C=a.getX(g+2);o=pu(this,r,e,ua,l,c,u,h,d,b,w,C),o&&(o.faceIndex=Math.floor(g/3),t.push(o))}}else if(l!==void 0)if(Array.isArray(r))for(let m=0,y=p.length;m<y;m++){const g=p[m],x=r[g.materialIndex],b=Math.max(g.start,f.start),w=Math.min(l.count,Math.min(g.start+g.count,f.start+f.count));for(let C=b,M=w;C<M;C+=3){const E=C,A=C+1,$=C+2;o=pu(this,x,e,ua,l,c,u,h,d,E,A,$),o&&(o.faceIndex=Math.floor(C/3),o.face.materialIndex=g.materialIndex,t.push(o))}}else{const m=Math.max(0,f.start),y=Math.min(l.count,f.start+f.count);for(let g=m,x=y;g<x;g+=3){const b=g,w=g+1,C=g+2;o=pu(this,r,e,ua,l,c,u,h,d,b,w,C),o&&(o.faceIndex=Math.floor(g/3),t.push(o))}}}else s.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}fn.prototype.isMesh=!0;function jO(n,e,t,s,r,i,o,a){let l;if(e.side===un?l=s.intersectTriangle(o,i,r,!0,a):l=s.intersectTriangle(r,i,o,e.side!==Wi,a),l===null)return null;du.copy(a),du.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(du);return c<t.near||c>t.far?null:{distance:c,point:du.clone(),object:n}}function pu(n,e,t,s,r,i,o,a,l,c,u,h){oi.fromBufferAttribute(r,c),ai.fromBufferAttribute(r,u),li.fromBufferAttribute(r,h);const d=n.morphTargetInfluences;if(i&&d){ou.set(0,0,0),au.set(0,0,0),lu.set(0,0,0);for(let f=0,m=i.length;f<m;f++){const y=d[f],g=i[f];y!==0&&(gp.fromBufferAttribute(g,c),xp.fromBufferAttribute(g,u),yp.fromBufferAttribute(g,h),o?(ou.addScaledVector(gp,y),au.addScaledVector(xp,y),lu.addScaledVector(yp,y)):(ou.addScaledVector(gp.sub(oi),y),au.addScaledVector(xp.sub(ai),y),lu.addScaledVector(yp.sub(li),y)))}oi.add(ou),ai.add(au),li.add(lu)}n.isSkinnedMesh&&(n.boneTransform(c,oi),n.boneTransform(u,ai),n.boneTransform(h,li));const p=jO(n,e,t,s,oi,ai,li,vp);if(p){a&&(cu.fromBufferAttribute(a,c),uu.fromBufferAttribute(a,u),hu.fromBufferAttribute(a,h),p.uv=on.getUV(vp,oi,ai,li,cu,uu,hu,new pe)),l&&(cu.fromBufferAttribute(l,c),uu.fromBufferAttribute(l,u),hu.fromBufferAttribute(l,h),p.uv2=on.getUV(vp,oi,ai,li,cu,uu,hu,new pe));const f={a:c,b:u,c:h,normal:new L,materialIndex:0};on.getNormal(oi,ai,li,f.normal),p.face=f}return p}class Cl extends Wt{constructor(e=1,t=1,s=1,r=1,i=1,o=1){super();this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:r,heightSegments:i,depthSegments:o};const a=this;r=Math.floor(r),i=Math.floor(i),o=Math.floor(o);const l=[],c=[],u=[],h=[];let d=0,p=0;f("z","y","x",-1,-1,s,t,e,o,i,0),f("z","y","x",1,-1,s,t,-e,o,i,1),f("x","z","y",1,1,e,s,t,r,o,2),f("x","z","y",1,-1,e,s,-t,r,o,3),f("x","y","z",1,-1,e,t,s,r,i,4),f("x","y","z",-1,-1,e,t,-s,r,i,5),this.setIndex(l),this.setAttribute("position",new tn(c,3)),this.setAttribute("normal",new tn(u,3)),this.setAttribute("uv",new tn(h,2));function f(m,y,g,x,b,w,C,M,E,A,$){const B=w/E,R=C/A,K=w/2,F=C/2,z=M/2,V=E+1,H=A+1;let j=0,ae=0;const fe=new L;for(let Q=0;Q<H;Q++){const te=Q*R-F;for(let Te=0;Te<V;Te++){const we=Te*B-K;fe[m]=we*x,fe[y]=te*b,fe[g]=z,c.push(fe.x,fe.y,fe.z),fe[m]=0,fe[y]=0,fe[g]=M>0?1:-1,u.push(fe.x,fe.y,fe.z),h.push(Te/E),h.push(1-Q/A),j+=1}}for(let Q=0;Q<A;Q++)for(let te=0;te<E;te++){const Te=d+te+V*Q,we=d+te+V*(Q+1),Pe=d+(te+1)+V*(Q+1),it=d+(te+1)+V*Q;l.push(Te,we,it),l.push(we,Pe,it),ae+=6}a.addGroup(p,ae,$),p+=ae,d+=j}}static fromJSON(e){return new Cl(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function ha(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const r=n[t][s];r&&(r.isColor||r.isMatrix3||r.isMatrix4||r.isVector2||r.isVector3||r.isVector4||r.isTexture||r.isQuaternion)?e[t][s]=r.clone():Array.isArray(r)?e[t][s]=r.slice():e[t][s]=r}}return e}function Pn(n){const e={};for(let t=0;t<n.length;t++){const s=ha(n[t]);for(const r in s)e[r]=s[r]}return e}const qO={clone:ha,merge:Pn};var KO=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,YO=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Ji extends pn{constructor(e){super();this.type="ShaderMaterial",this.defines={},this.uniforms={},this.vertexShader=KO,this.fragmentShader=YO,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&(e.attributes!==void 0&&console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."),this.setValues(e))}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ha(e.uniforms),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const r in this.uniforms){const o=this.uniforms[r].value;o&&o.isTexture?t.uniforms[r]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?t.uniforms[r]={type:"c",value:o.getHex()}:o&&o.isVector2?t.uniforms[r]={type:"v2",value:o.toArray()}:o&&o.isVector3?t.uniforms[r]={type:"v3",value:o.toArray()}:o&&o.isVector4?t.uniforms[r]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?t.uniforms[r]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?t.uniforms[r]={type:"m4",value:o.toArray()}:t.uniforms[r]={value:o}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader;const s={};for(const r in this.extensions)this.extensions[r]===!0&&(s[r]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}Ji.prototype.isShaderMaterial=!0;class bp extends Ye{constructor(){super();this.type="Camera",this.matrixWorldInverse=new ze,this.projectionMatrix=new ze,this.projectionMatrixInverse=new ze}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(-t[8],-t[9],-t[10]).normalize()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}bp.prototype.isCamera=!0;class Gn extends bp{constructor(e=50,t=1,s=.1,r=2e3){super();this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=r,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=bl*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(vl*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return bl*2*Math.atan(Math.tan(vl*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,s,r,i,o){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(vl*.5*this.fov)/this.zoom,s=2*t,r=this.aspect*s,i=-.5*r;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;i+=o.offsetX*r/l,t-=o.offsetY*s/c,r*=o.width/l,s*=o.height/c}const a=this.filmOffset;a!==0&&(i+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(i,i+r,t,t-s,e,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}Gn.prototype.isPerspectiveCamera=!0;const da=90,pa=1;class wp extends Ye{constructor(e,t,s){super();if(this.type="CubeCamera",s.isWebGLCubeRenderTarget!==!0){console.error("THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.");return}this.renderTarget=s;const r=new Gn(da,pa,e,t);r.layers=this.layers,r.up.set(0,-1,0),r.lookAt(new L(1,0,0)),this.add(r);const i=new Gn(da,pa,e,t);i.layers=this.layers,i.up.set(0,-1,0),i.lookAt(new L(-1,0,0)),this.add(i);const o=new Gn(da,pa,e,t);o.layers=this.layers,o.up.set(0,0,1),o.lookAt(new L(0,1,0)),this.add(o);const a=new Gn(da,pa,e,t);a.layers=this.layers,a.up.set(0,0,-1),a.lookAt(new L(0,-1,0)),this.add(a);const l=new Gn(da,pa,e,t);l.layers=this.layers,l.up.set(0,-1,0),l.lookAt(new L(0,0,1)),this.add(l);const c=new Gn(da,pa,e,t);c.layers=this.layers,c.up.set(0,-1,0),c.lookAt(new L(0,0,-1)),this.add(c)}update(e,t){this.parent===null&&this.updateMatrixWorld();const s=this.renderTarget,[r,i,o,a,l,c]=this.children,u=e.xr.enabled,h=e.getRenderTarget();e.xr.enabled=!1;const d=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0),e.render(t,r),e.setRenderTarget(s,1),e.render(t,i),e.setRenderTarget(s,2),e.render(t,o),e.setRenderTarget(s,3),e.render(t,a),e.setRenderTarget(s,4),e.render(t,l),s.texture.generateMipmaps=d,e.setRenderTarget(s,5),e.render(t,c),e.setRenderTarget(h),e.xr.enabled=u}}class fu extends dn{constructor(e,t,s,r,i,o,a,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:fl;super(e,t,s,r,i,o,a,l,c,u);this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}fu.prototype.isCubeTexture=!0;class Dx extends Ts{constructor(e,t,s){Number.isInteger(t)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),t=s);super(e,e,t);t=t||{},this.texture=new fu(void 0,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.encoding),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Zn,this.texture._needsFlipEnvMap=!1}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.format=Ln,this.texture.encoding=t.encoding,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},r=new Cl(5,5,5),i=new Ji({name:"CubemapFromEquirect",uniforms:ha(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:un,blending:Jr});i.uniforms.tEquirect.value=t;const o=new fn(r,i),a=t.minFilter;return t.minFilter===Ho&&(t.minFilter=Zn),new wp(1,10,this).update(e,o),t.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,t,s,r){const i=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(t,s,r);e.setRenderTarget(i)}}Dx.prototype.isWebGLCubeRenderTarget=!0;const _p=new L,ZO=new L,JO=new En;class Nr{constructor(e=new L(1,0,0),t=0){this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,r){return this.normal.set(e,t,s),this.constant=r,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const r=_p.subVectors(s,t).cross(ZO.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(r,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(this.normal).multiplyScalar(-this.distanceToPoint(e)).add(e)}intersectLine(e,t){const s=e.delta(_p),r=this.normal.dot(s);if(r===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const i=-(e.start.dot(this.normal)+this.constant)/r;return i<0||i>1?null:t.copy(s).multiplyScalar(i).add(e.start)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||JO.getNormalMatrix(e),r=this.coplanarPoint(_p).applyMatrix4(e),i=this.normal.applyMatrix3(s).normalize();return this.constant=-r.dot(i),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}Nr.prototype.isPlane=!0;const fa=new Zi,mu=new L;class gu{constructor(e=new Nr,t=new Nr,s=new Nr,r=new Nr,i=new Nr,o=new Nr){this.planes=[e,t,s,r,i,o]}set(e,t,s,r,i,o){const a=this.planes;return a[0].copy(e),a[1].copy(t),a[2].copy(s),a[3].copy(r),a[4].copy(i),a[5].copy(o),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e){const t=this.planes,s=e.elements,r=s[0],i=s[1],o=s[2],a=s[3],l=s[4],c=s[5],u=s[6],h=s[7],d=s[8],p=s[9],f=s[10],m=s[11],y=s[12],g=s[13],x=s[14],b=s[15];return t[0].setComponents(a-r,h-l,m-d,b-y).normalize(),t[1].setComponents(a+r,h+l,m+d,b+y).normalize(),t[2].setComponents(a+i,h+c,m+p,b+g).normalize(),t[3].setComponents(a-i,h-c,m-p,b-g).normalize(),t[4].setComponents(a-o,h-u,m-f,b-x).normalize(),t[5].setComponents(a+o,h+u,m+f,b+x).normalize(),this}intersectsObject(e){const t=e.geometry;return t.boundingSphere===null&&t.computeBoundingSphere(),fa.copy(t.boundingSphere).applyMatrix4(e.matrixWorld),this.intersectsSphere(fa)}intersectsSprite(e){return fa.center.set(0,0,0),fa.radius=.7071067811865476,fa.applyMatrix4(e.matrixWorld),this.intersectsSphere(fa)}intersectsSphere(e){const t=this.planes,s=e.center,r=-e.radius;for(let i=0;i<6;i++)if(t[i].distanceToPoint(s)<r)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const r=t[s];if(mu.x=r.normal.x>0?e.max.x:e.min.x,mu.y=r.normal.y>0?e.max.y:e.min.y,mu.z=r.normal.z>0?e.max.z:e.min.z,r.distanceToPoint(mu)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function kx(){let n=null,e=!1,t=null,s=null;function r(i,o){t(i,o),s=n.requestAnimationFrame(r)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(r),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(i){t=i},setContext:function(i){n=i}}}function QO(n,e){const t=e.isWebGL2,s=new WeakMap;function r(c,u){const h=c.array,d=c.usage,p=n.createBuffer();n.bindBuffer(u,p),n.bufferData(u,h,d),c.onUploadCallback();let f=5126;return h instanceof Float32Array?f=5126:h instanceof Float64Array?console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array."):h instanceof Uint16Array?c.isFloat16BufferAttribute?t?f=5131:console.warn("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."):f=5123:h instanceof Int16Array?f=5122:h instanceof Uint32Array?f=5125:h instanceof Int32Array?f=5124:h instanceof Int8Array?f=5120:(h instanceof Uint8Array||h instanceof Uint8ClampedArray)&&(f=5121),{buffer:p,type:f,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function i(c,u,h){const d=u.array,p=u.updateRange;n.bindBuffer(h,c),p.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1)}function o(c){return c.isInterleavedBufferAttribute&&(c=c.data),s.get(c)}function a(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=s.get(c);u&&(n.deleteBuffer(u.buffer),s.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=s.get(c);(!d||d.version<c.version)&&s.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=s.get(c);h===void 0?s.set(c,r(c,u)):h.version<c.version&&(i(h.buffer,c,u),h.version=c.version)}return{get:o,remove:a,update:l}}class ma extends Wt{constructor(e=1,t=1,s=1,r=1){super();this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:r};const i=e/2,o=t/2,a=Math.floor(s),l=Math.floor(r),c=a+1,u=l+1,h=e/a,d=t/l,p=[],f=[],m=[],y=[];for(let g=0;g<u;g++){const x=g*d-o;for(let b=0;b<c;b++){const w=b*h-i;f.push(w,-x,0),m.push(0,0,1),y.push(b/a),y.push(1-g/l)}}for(let g=0;g<l;g++)for(let x=0;x<a;x++){const b=x+c*g,w=x+c*(g+1),C=x+1+c*(g+1),M=x+1+c*g;p.push(b,w,M),p.push(w,C,M)}this.setIndex(p),this.setAttribute("position",new tn(f,3)),this.setAttribute("normal",new tn(m,3)),this.setAttribute("uv",new tn(y,2))}static fromJSON(e){return new ma(e.width,e.height,e.widthSegments,e.heightSegments)}}var eB=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vUv ).g;
#endif`,tB=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,nB=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,sB=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,rB=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,iB=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,oB="vec3 transformed = vec3( position );",aB=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,lB=`vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
	float D = D_GGX( alpha, dotNH );
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif`,cB=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vUv );
		vec2 dSTdy = dFdy( vUv );
		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );
		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,uB=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,hB=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,dB=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,pB=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,fB=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,mB=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,gB=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,xB=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,yB=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
struct GeometricContext {
	vec3 position;
	vec3 normal;
	vec3 viewDir;
#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal;
#endif
};
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float linearToRelativeLuminance( const in vec3 color ) {
	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );
	return dot( weights, color.rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}`,vB=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_maxMipLevel 8.0
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_maxTileSize 256.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
		vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
		vec2 f = fract( uv );
		uv += 0.5 - f;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		if ( mipInt < cubeUV_maxMipLevel ) {
			uv.y += 2.0 * cubeUV_maxTileSize;
		}
		uv.y += filterInt * 2.0 * cubeUV_minTileSize;
		uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
		uv *= texelSize;
		vec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x += texelSize;
		vec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.y += texelSize;
		vec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		uv.x -= texelSize;
		vec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;
		vec3 tm = mix( tl, tr, f.x );
		vec3 bm = mix( bl, br, f.x );
		return mix( tm, bm, f.y );
	}
	#define r0 1.0
	#define v0 0.339
	#define m0 - 2.0
	#define r1 0.8
	#define v1 0.276
	#define m1 - 1.0
	#define r4 0.4
	#define v4 0.046
	#define m4 2.0
	#define r5 0.305
	#define v5 0.016
	#define m5 3.0
	#define r6 0.21
	#define v6 0.0038
	#define m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= r1 ) {
			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
		} else if ( roughness >= r4 ) {
			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
		} else if ( roughness >= r5 ) {
			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
		} else if ( roughness >= r6 ) {
			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,bB=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,wB=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,_B=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );
#endif`,SB=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vUv );
	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,TB=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,EB="gl_FragColor = linearToOutputTexel( gl_FragColor );",CB=`
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 GammaToLinear( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );
}
vec4 LinearToGamma( in vec4 value, in float gammaFactor ) {
	return vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );
}
vec4 sRGBToLinear( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 LinearTosRGB( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 RGBEToLinear( in vec4 value ) {
	return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );
}
vec4 LinearToRGBE( in vec4 value ) {
	float maxComponent = max( max( value.r, value.g ), value.b );
	float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );
	return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );
}
vec4 RGBMToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * value.a * maxRange, 1.0 );
}
vec4 LinearToRGBM( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float M = clamp( maxRGB / maxRange, 0.0, 1.0 );
	M = ceil( M * 255.0 ) / 255.0;
	return vec4( value.rgb / ( M * maxRange ), M );
}
vec4 RGBDToLinear( in vec4 value, in float maxRange ) {
	return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );
}
vec4 LinearToRGBD( in vec4 value, in float maxRange ) {
	float maxRGB = max( value.r, max( value.g, value.b ) );
	float D = max( maxRange / maxRGB, 1.0 );
	D = clamp( floor( D ) / 255.0, 0.0, 1.0 );
	return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );
}`,MB=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
		envColor = envMapTexelToLinear( envColor );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,AB=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,RB=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,IB=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,NB=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,LB=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,PB=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,DB=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,kB=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,$B=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return texture2D( gradientMap, coord ).rgb;
	#else
		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );
	#endif
}`,FB=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vUv2 );
	vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#ifndef PHYSICALLY_CORRECT_LIGHTS
		lightMapIrradiance *= PI;
	#endif
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,OB=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,BB=`vec3 diffuse = vec3( 1.0 );
GeometricContext geometry;
geometry.position = mvPosition.xyz;
geometry.normal = normalize( transformedNormal );
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );
GeometricContext backGeometry;
backGeometry.position = geometry.position;
backGeometry.normal = -geometry.normal;
backGeometry.viewDir = geometry.viewDir;
vLightFront = vec3( 0.0 );
vIndirectFront = vec3( 0.0 );
#ifdef DOUBLE_SIDED
	vLightBack = vec3( 0.0 );
	vIndirectBack = vec3( 0.0 );
#endif
IncidentLight directLight;
float dotNL;
vec3 directLightColor_Diffuse;
vIndirectFront += getAmbientLightIrradiance( ambientLightColor );
vIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );
#ifdef DOUBLE_SIDED
	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );
	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );
#endif
#if NUM_POINT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		getPointLightInfo( pointLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_SPOT_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		getSpotLightInfo( spotLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_DIR_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );
		dotNL = dot( geometry.normal, directLight.direction );
		directLightColor_Diffuse = directLight.color;
		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;
		#ifdef DOUBLE_SIDED
			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;
		#endif
	}
	#pragma unroll_loop_end
#endif
#if NUM_HEMI_LIGHTS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		#ifdef DOUBLE_SIDED
			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );
		#endif
	}
	#pragma unroll_loop_end
#endif`,zB=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
uniform vec3 lightProbe[ 9 ];
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( PHYSICALLY_CORRECT_LIGHTS )
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#else
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometry.position;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometry.position;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,UB=`#if defined( USE_ENVMAP )
	#ifdef ENVMAP_MODE_REFRACTION
		uniform float refractionRatio;
	#endif
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#if defined( ENVMAP_TYPE_CUBE_UV )
			vec3 reflectVec;
			#ifdef ENVMAP_MODE_REFLECTION
				reflectVec = reflect( - viewDir, normal );
				reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			#else
				reflectVec = refract( - viewDir, normal, refractionRatio );
			#endif
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
#endif`,VB=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,GB=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon
#define Material_LightProbeLOD( material )	(0)`,WB=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,HB=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong
#define Material_LightProbeLOD( material )	(0)`,XB=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	#ifdef SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULARINTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;
		#endif
		#ifdef USE_SPECULARCOLORMAP
			specularColorFactor *= specularColorMapTexelToLinear( texture2D( specularColorMap, vUv ) ).rgb;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEENCOLORMAP
		material.sheenColor *= sheenColorMapTexelToLinear( texture2D( sheenColorMap, vUv ) ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEENROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;
	#endif
#endif`,jB=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
};
vec3 clearcoatSpecular = vec3( 0.0 );
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	vec3 FssEss = specularColor * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometry.normal;
		vec3 viewDir = geometry.viewDir;
		vec3 position = geometry.position;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		reflectedLight.directSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	vec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,qB=`
GeometricContext geometry;
geometry.position = - vViewPosition;
geometry.normal = normal;
geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
#ifdef USE_CLEARCOAT
	geometry.clearcoatNormal = clearcoatNormal;
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, geometry, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,KB=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vUv2 );
		vec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
		#ifndef PHYSICALLY_CORRECT_LIGHTS
			lightMapIrradiance *= PI;
		#endif
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometry.normal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,YB=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );
#endif`,ZB=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,JB=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,QB=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,ez=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,tz=`#ifdef USE_MAP
	vec4 texelColor = texture2D( map, vUv );
	texelColor = mapTexelToLinear( texelColor );
	diffuseColor *= texelColor;
#endif`,nz=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,sz=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
#endif
#ifdef USE_MAP
	vec4 mapTexel = texture2D( map, uv );
	diffuseColor *= mapTexelToLinear( mapTexel );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,rz=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	uniform mat3 uvTransform;
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,iz=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vUv );
	metalnessFactor *= texelMetalness.b;
#endif`,oz=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,az=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] > 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1, 2 ) * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,lz=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform vec2 morphTargetsTextureSize;
		vec3 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset, const in int stride ) {
			float texelIndex = float( vertexIndex * stride + offset );
			float y = floor( texelIndex / morphTargetsTextureSize.x );
			float x = texelIndex - y * morphTargetsTextureSize.x;
			vec3 morphUV = vec3( ( x + 0.5 ) / morphTargetsTextureSize.x, y / morphTargetsTextureSize.y, morphTargetIndex );
			return texture( morphTargetsTexture, morphUV ).xyz;
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,cz=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			#ifndef USE_MORPHNORMALS
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 1 ) * morphTargetInfluences[ i ];
			#else
				if ( morphTargetInfluences[ i ] > 0.0 ) transformed += getMorph( gl_VertexID, i, 0, 2 ) * morphTargetInfluences[ i ];
			#endif
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,uz=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );
	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	#ifdef USE_TANGENT
		vec3 tangent = normalize( vTangent );
		vec3 bitangent = normalize( vBitangent );
		#ifdef DOUBLE_SIDED
			tangent = tangent * faceDirection;
			bitangent = bitangent * faceDirection;
		#endif
		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )
			mat3 vTBN = mat3( tangent, bitangent, normal );
		#endif
	#endif
#endif
vec3 geometryNormal = normal;`,hz=`#ifdef OBJECTSPACE_NORMALMAP
	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( TANGENTSPACE_NORMALMAP )
	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	#ifdef USE_TANGENT
		normal = normalize( vTBN * mapN );
	#else
		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );
	#endif
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,dz=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,pz=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,fz=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,mz=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef OBJECTSPACE_NORMALMAP
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )
	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {
		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );
		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );
		vec2 st0 = dFdx( vUv.st );
		vec2 st1 = dFdy( vUv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );
		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );
	}
#endif`,gz=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = geometryNormal;
#endif`,xz=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	#ifdef USE_TANGENT
		clearcoatNormal = normalize( vTBN * clearcoatMapN );
	#else
		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );
	#endif
#endif`,yz=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif`,vz=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= transmissionAlpha + 0.1;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,bz=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {
	return linearClipZ * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * invClipZ - far );
}`,wz=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,_z=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Sz=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Tz=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Ez=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Cz=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,Mz=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );
		bool inFrustum = all( inFrustumVec );
		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );
		bool frustumTest = all( frustumTestVec );
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), 
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), 
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,Az=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];
		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,Rz=`#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0
		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		vec4 shadowWorldPosition;
	#endif
	#if NUM_DIR_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );
		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
	#endif
#endif`,Iz=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Nz=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Lz=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	#ifdef BONE_TEXTURE
		uniform highp sampler2D boneTexture;
		uniform int boneTextureSize;
		mat4 getBoneMatrix( const in float i ) {
			float j = i * 4.0;
			float x = mod( j, float( boneTextureSize ) );
			float y = floor( j / float( boneTextureSize ) );
			float dx = 1.0 / float( boneTextureSize );
			float dy = 1.0 / float( boneTextureSize );
			y = dy * ( y + 0.5 );
			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
			mat4 bone = mat4( v1, v2, v3, v4 );
			return bone;
		}
	#else
		uniform mat4 boneMatrices[ MAX_BONES ];
		mat4 getBoneMatrix( const in float i ) {
			mat4 bone = boneMatrices[ int(i) ];
			return bone;
		}
	#endif
#endif`,Pz=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,Dz=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,kz=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,$z=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,Fz=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Oz=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return toneMappingExposure * color;
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Bz=`#ifdef USE_TRANSMISSION
	float transmissionAlpha = 1.0;
	float transmissionFactor = transmission;
	float thicknessFactor = thickness;
	#ifdef USE_TRANSMISSIONMAP
		transmissionFactor *= texture2D( transmissionMap, vUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		thicknessFactor *= texture2D( thicknessMap, vUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmission = getIBLVolumeRefraction(
		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,
		attenuationColor, attenuationDistance );
	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );
	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );
#endif`,zz=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	vec3 getVolumeTransmissionRay( vec3 n, vec3 v, float thickness, float ior, mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( float roughness, float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( vec2 fragCoord, float roughness, float ior ) {
		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		#ifdef TEXTURE_LOD_EXT
			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#else
			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );
		#endif
	}
	vec3 applyVolumeAttenuation( vec3 radiance, float transmissionDistance, vec3 attenuationColor, float attenuationDistance ) {
		if ( attenuationDistance == 0.0 ) {
			return radiance;
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;
		}
	}
	vec4 getIBLVolumeRefraction( vec3 n, vec3 v, float roughness, vec3 diffuseColor, vec3 specularColor, float specularF90,
		vec3 position, mat4 modelMatrix, mat4 viewMatrix, mat4 projMatrix, float ior, float thickness,
		vec3 attenuationColor, float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
	}
#endif`,Uz=`#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )
	varying vec2 vUv;
#endif`,Vz=`#ifdef USE_UV
	#ifdef UVS_VERTEX_ONLY
		vec2 vUv;
	#else
		varying vec2 vUv;
	#endif
	uniform mat3 uvTransform;
#endif`,Gz=`#ifdef USE_UV
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
#endif`,Wz=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	varying vec2 vUv2;
#endif`,Hz=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	attribute vec2 uv2;
	varying vec2 vUv2;
	uniform mat3 uv2Transform;
#endif`,Xz=`#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )
	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;
#endif`,jz=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const qz=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,Kz=`uniform sampler2D t2D;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Yz=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Zz=`#include <envmap_common_pars_fragment>
uniform float opacity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	vec3 vReflect = vWorldDirection;
	#include <envmap_fragment>
	gl_FragColor = envColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,Jz=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,Qz=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,eU=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,tU=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,nU=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,sU=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	vec4 texColor = texture2D( tEquirect, sampleUV );
	gl_FragColor = mapTexelToLinear( texColor );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
}`,rU=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,iU=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,oU=`#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,aU=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel= texture2D( lightMap, vUv2 );
		reflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,lU=`#define LAMBERT
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <envmap_pars_vertex>
#include <bsdfs>
#include <lights_pars_begin>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <lights_lambert_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,cU=`uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
varying vec3 vLightFront;
varying vec3 vIndirectFront;
#ifdef DOUBLE_SIDED
	varying vec3 vLightBack;
	varying vec3 vIndirectBack;
#endif
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <fog_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <emissivemap_fragment>
	#ifdef DOUBLE_SIDED
		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;
	#else
		reflectedLight.indirectDiffuse += vIndirectFront;
	#endif
	#include <lightmap_fragment>
	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );
	#ifdef DOUBLE_SIDED
		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;
	#else
		reflectedLight.directDiffuse = vLightFront;
	#endif
	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,uU=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,hU=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
		matcapColor = matcapTexelToLinear( matcapColor );
	#else
		vec4 matcapColor = vec4( 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,dU=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	vViewPosition = - mvPosition.xyz;
#endif
}`,pU=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
}`,fU=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,mU=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <cube_uv_reflection_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,gU=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,xU=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULARINTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
	#ifdef USE_SPECULARCOLORMAP
		uniform sampler2D specularColorMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEENCOLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEENROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <bsdfs>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;
	#endif
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,yU=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <uv2_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <uv2_vertex>
	#include <color_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,vU=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <uv2_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bU=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <color_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,wU=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,_U=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,SU=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,TU=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,EU=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <output_fragment>
	#include <tonemapping_fragment>
	#include <encodings_fragment>
	#include <fog_fragment>
}`,ft={alphamap_fragment:eB,alphamap_pars_fragment:tB,alphatest_fragment:nB,alphatest_pars_fragment:sB,aomap_fragment:rB,aomap_pars_fragment:iB,begin_vertex:oB,beginnormal_vertex:aB,bsdfs:lB,bumpmap_pars_fragment:cB,clipping_planes_fragment:uB,clipping_planes_pars_fragment:hB,clipping_planes_pars_vertex:dB,clipping_planes_vertex:pB,color_fragment:fB,color_pars_fragment:mB,color_pars_vertex:gB,color_vertex:xB,common:yB,cube_uv_reflection_fragment:vB,defaultnormal_vertex:bB,displacementmap_pars_vertex:wB,displacementmap_vertex:_B,emissivemap_fragment:SB,emissivemap_pars_fragment:TB,encodings_fragment:EB,encodings_pars_fragment:CB,envmap_fragment:MB,envmap_common_pars_fragment:AB,envmap_pars_fragment:RB,envmap_pars_vertex:IB,envmap_physical_pars_fragment:UB,envmap_vertex:NB,fog_vertex:LB,fog_pars_vertex:PB,fog_fragment:DB,fog_pars_fragment:kB,gradientmap_pars_fragment:$B,lightmap_fragment:FB,lightmap_pars_fragment:OB,lights_lambert_vertex:BB,lights_pars_begin:zB,lights_toon_fragment:VB,lights_toon_pars_fragment:GB,lights_phong_fragment:WB,lights_phong_pars_fragment:HB,lights_physical_fragment:XB,lights_physical_pars_fragment:jB,lights_fragment_begin:qB,lights_fragment_maps:KB,lights_fragment_end:YB,logdepthbuf_fragment:ZB,logdepthbuf_pars_fragment:JB,logdepthbuf_pars_vertex:QB,logdepthbuf_vertex:ez,map_fragment:tz,map_pars_fragment:nz,map_particle_fragment:sz,map_particle_pars_fragment:rz,metalnessmap_fragment:iz,metalnessmap_pars_fragment:oz,morphnormal_vertex:az,morphtarget_pars_vertex:lz,morphtarget_vertex:cz,normal_fragment_begin:uz,normal_fragment_maps:hz,normal_pars_fragment:dz,normal_pars_vertex:pz,normal_vertex:fz,normalmap_pars_fragment:mz,clearcoat_normal_fragment_begin:gz,clearcoat_normal_fragment_maps:xz,clearcoat_pars_fragment:yz,output_fragment:vz,packing:bz,premultiplied_alpha_fragment:wz,project_vertex:_z,dithering_fragment:Sz,dithering_pars_fragment:Tz,roughnessmap_fragment:Ez,roughnessmap_pars_fragment:Cz,shadowmap_pars_fragment:Mz,shadowmap_pars_vertex:Az,shadowmap_vertex:Rz,shadowmask_pars_fragment:Iz,skinbase_vertex:Nz,skinning_pars_vertex:Lz,skinning_vertex:Pz,skinnormal_vertex:Dz,specularmap_fragment:kz,specularmap_pars_fragment:$z,tonemapping_fragment:Fz,tonemapping_pars_fragment:Oz,transmission_fragment:Bz,transmission_pars_fragment:zz,uv_pars_fragment:Uz,uv_pars_vertex:Vz,uv_vertex:Gz,uv2_pars_fragment:Wz,uv2_pars_vertex:Hz,uv2_vertex:Xz,worldpos_vertex:jz,background_vert:qz,background_frag:Kz,cube_vert:Yz,cube_frag:Zz,depth_vert:Jz,depth_frag:Qz,distanceRGBA_vert:eU,distanceRGBA_frag:tU,equirect_vert:nU,equirect_frag:sU,linedashed_vert:rU,linedashed_frag:iU,meshbasic_vert:oU,meshbasic_frag:aU,meshlambert_vert:lU,meshlambert_frag:cU,meshmatcap_vert:uU,meshmatcap_frag:hU,meshnormal_vert:dU,meshnormal_frag:pU,meshphong_vert:fU,meshphong_frag:mU,meshphysical_vert:gU,meshphysical_frag:xU,meshtoon_vert:yU,meshtoon_frag:vU,points_vert:bU,points_frag:wU,shadow_vert:_U,shadow_frag:SU,sprite_vert:TU,sprite_frag:EU},Ce={common:{diffuse:{value:new Le(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new En},uv2Transform:{value:new En},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new pe(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Le(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotShadowMap:{value:[]},spotShadowMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Le(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new En}},sprite:{diffuse:{value:new Le(16777215)},opacity:{value:1},center:{value:new pe(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new En}}},Ys={basic:{uniforms:Pn([Ce.common,Ce.specularmap,Ce.envmap,Ce.aomap,Ce.lightmap,Ce.fog]),vertexShader:ft.meshbasic_vert,fragmentShader:ft.meshbasic_frag},lambert:{uniforms:Pn([Ce.common,Ce.specularmap,Ce.envmap,Ce.aomap,Ce.lightmap,Ce.emissivemap,Ce.fog,Ce.lights,{emissive:{value:new Le(0)}}]),vertexShader:ft.meshlambert_vert,fragmentShader:ft.meshlambert_frag},phong:{uniforms:Pn([Ce.common,Ce.specularmap,Ce.envmap,Ce.aomap,Ce.lightmap,Ce.emissivemap,Ce.bumpmap,Ce.normalmap,Ce.displacementmap,Ce.fog,Ce.lights,{emissive:{value:new Le(0)},specular:{value:new Le(1118481)},shininess:{value:30}}]),vertexShader:ft.meshphong_vert,fragmentShader:ft.meshphong_frag},standard:{uniforms:Pn([Ce.common,Ce.envmap,Ce.aomap,Ce.lightmap,Ce.emissivemap,Ce.bumpmap,Ce.normalmap,Ce.displacementmap,Ce.roughnessmap,Ce.metalnessmap,Ce.fog,Ce.lights,{emissive:{value:new Le(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ft.meshphysical_vert,fragmentShader:ft.meshphysical_frag},toon:{uniforms:Pn([Ce.common,Ce.aomap,Ce.lightmap,Ce.emissivemap,Ce.bumpmap,Ce.normalmap,Ce.displacementmap,Ce.gradientmap,Ce.fog,Ce.lights,{emissive:{value:new Le(0)}}]),vertexShader:ft.meshtoon_vert,fragmentShader:ft.meshtoon_frag},matcap:{uniforms:Pn([Ce.common,Ce.bumpmap,Ce.normalmap,Ce.displacementmap,Ce.fog,{matcap:{value:null}}]),vertexShader:ft.meshmatcap_vert,fragmentShader:ft.meshmatcap_frag},points:{uniforms:Pn([Ce.points,Ce.fog]),vertexShader:ft.points_vert,fragmentShader:ft.points_frag},dashed:{uniforms:Pn([Ce.common,Ce.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ft.linedashed_vert,fragmentShader:ft.linedashed_frag},depth:{uniforms:Pn([Ce.common,Ce.displacementmap]),vertexShader:ft.depth_vert,fragmentShader:ft.depth_frag},normal:{uniforms:Pn([Ce.common,Ce.bumpmap,Ce.normalmap,Ce.displacementmap,{opacity:{value:1}}]),vertexShader:ft.meshnormal_vert,fragmentShader:ft.meshnormal_frag},sprite:{uniforms:Pn([Ce.sprite,Ce.fog]),vertexShader:ft.sprite_vert,fragmentShader:ft.sprite_frag},background:{uniforms:{uvTransform:{value:new En},t2D:{value:null}},vertexShader:ft.background_vert,fragmentShader:ft.background_frag},cube:{uniforms:Pn([Ce.envmap,{opacity:{value:1}}]),vertexShader:ft.cube_vert,fragmentShader:ft.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ft.equirect_vert,fragmentShader:ft.equirect_frag},distanceRGBA:{uniforms:Pn([Ce.common,Ce.displacementmap,{referencePosition:{value:new L},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:ft.distanceRGBA_vert,fragmentShader:ft.distanceRGBA_frag},shadow:{uniforms:Pn([Ce.lights,Ce.fog,{color:{value:new Le(0)},opacity:{value:1}}]),vertexShader:ft.shadow_vert,fragmentShader:ft.shadow_frag}};Ys.physical={uniforms:Pn([Ys.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new pe(1,1)},clearcoatNormalMap:{value:null},sheen:{value:0},sheenColor:{value:new Le(0)},sheenColorMap:{value:null},sheenRoughness:{value:0},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new pe},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Le(0)},specularIntensity:{value:0},specularIntensityMap:{value:null},specularColor:{value:new Le(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ft.meshphysical_vert,fragmentShader:ft.meshphysical_frag};function CU(n,e,t,s,r){const i=new Le(0);let o=0,a,l,c=null,u=0,h=null;function d(f,m){let y=!1,g=m.isScene===!0?m.background:null;g&&g.isTexture&&(g=e.get(g));const x=n.xr,b=x.getSession&&x.getSession();b&&b.environmentBlendMode==="additive"&&(g=null),g===null?p(i,o):g&&g.isColor&&(p(g,1),y=!0),(n.autoClear||y)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),g&&(g.isCubeTexture||g.mapping===Hc)?(l===void 0&&(l=new fn(new Cl(1,1,1),new Ji({name:"BackgroundCubeMaterial",uniforms:ha(Ys.cube.uniforms),vertexShader:Ys.cube.vertexShader,fragmentShader:Ys.cube.fragmentShader,side:un,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),l.geometry.deleteAttribute("uv"),l.onBeforeRender=function(w,C,M){this.matrixWorld.copyPosition(M.matrixWorld)},Object.defineProperty(l.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),s.update(l)),l.material.uniforms.envMap.value=g,l.material.uniforms.flipEnvMap.value=g.isCubeTexture&&g.isRenderTargetTexture===!1?-1:1,(c!==g||u!==g.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,c=g,u=g.version,h=n.toneMapping),f.unshift(l,l.geometry,l.material,0,0,null)):g&&g.isTexture&&(a===void 0&&(a=new fn(new ma(2,2),new Ji({name:"BackgroundMaterial",uniforms:ha(Ys.background.uniforms),vertexShader:Ys.background.vertexShader,fragmentShader:Ys.background.fragmentShader,side:Vo,depthTest:!1,depthWrite:!1,fog:!1})),a.geometry.deleteAttribute("normal"),Object.defineProperty(a.material,"map",{get:function(){return this.uniforms.t2D.value}}),s.update(a)),a.material.uniforms.t2D.value=g,g.matrixAutoUpdate===!0&&g.updateMatrix(),a.material.uniforms.uvTransform.value.copy(g.matrix),(c!==g||u!==g.version||h!==n.toneMapping)&&(a.material.needsUpdate=!0,c=g,u=g.version,h=n.toneMapping),f.unshift(a,a.geometry,a.material,0,0,null))}function p(f,m){t.buffers.color.setClear(f.r,f.g,f.b,m,r)}return{getClearColor:function(){return i},setClearColor:function(f,m=1){i.set(f),o=m,p(i,o)},getClearAlpha:function(){return o},setClearAlpha:function(f){o=f,p(i,o)},render:d}}function MU(n,e,t,s){const r=n.getParameter(34921),i=s.isWebGL2?null:e.get("OES_vertex_array_object"),o=s.isWebGL2||i!==null,a={},l=m(null);let c=l;function u(F,z,V,H,j){let ae=!1;if(o){const fe=f(H,V,z);c!==fe&&(c=fe,d(c.object)),ae=y(H,j),ae&&g(H,j)}else{const fe=z.wireframe===!0;(c.geometry!==H.id||c.program!==V.id||c.wireframe!==fe)&&(c.geometry=H.id,c.program=V.id,c.wireframe=fe,ae=!0)}F.isInstancedMesh===!0&&(ae=!0),j!==null&&t.update(j,34963),ae&&(E(F,z,V,H),j!==null&&n.bindBuffer(34963,t.get(j).buffer))}function h(){return s.isWebGL2?n.createVertexArray():i.createVertexArrayOES()}function d(F){return s.isWebGL2?n.bindVertexArray(F):i.bindVertexArrayOES(F)}function p(F){return s.isWebGL2?n.deleteVertexArray(F):i.deleteVertexArrayOES(F)}function f(F,z,V){const H=V.wireframe===!0;let j=a[F.id];j===void 0&&(j={},a[F.id]=j);let ae=j[z.id];ae===void 0&&(ae={},j[z.id]=ae);let fe=ae[H];return fe===void 0&&(fe=m(h()),ae[H]=fe),fe}function m(F){const z=[],V=[],H=[];for(let j=0;j<r;j++)z[j]=0,V[j]=0,H[j]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:z,enabledAttributes:V,attributeDivisors:H,object:F,attributes:{},index:null}}function y(F,z){const V=c.attributes,H=F.attributes;let j=0;for(const ae in H){const fe=V[ae],Q=H[ae];if(fe===void 0||fe.attribute!==Q||fe.data!==Q.data)return!0;j++}return c.attributesNum!==j||c.index!==z}function g(F,z){const V={},H=F.attributes;let j=0;for(const ae in H){const fe=H[ae],Q={};Q.attribute=fe,fe.data&&(Q.data=fe.data),V[ae]=Q,j++}c.attributes=V,c.attributesNum=j,c.index=z}function x(){const F=c.newAttributes;for(let z=0,V=F.length;z<V;z++)F[z]=0}function b(F){w(F,0)}function w(F,z){const V=c.newAttributes,H=c.enabledAttributes,j=c.attributeDivisors;V[F]=1,H[F]===0&&(n.enableVertexAttribArray(F),H[F]=1),j[F]!==z&&((s.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](F,z),j[F]=z)}function C(){const F=c.newAttributes,z=c.enabledAttributes;for(let V=0,H=z.length;V<H;V++)z[V]!==F[V]&&(n.disableVertexAttribArray(V),z[V]=0)}function M(F,z,V,H,j,ae){s.isWebGL2===!0&&(V===5124||V===5125)?n.vertexAttribIPointer(F,z,V,j,ae):n.vertexAttribPointer(F,z,V,H,j,ae)}function E(F,z,V,H){if(s.isWebGL2===!1&&(F.isInstancedMesh||H.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;x();const j=H.attributes,ae=V.getAttributes(),fe=z.defaultAttributeValues;for(const Q in ae){const te=ae[Q];if(te.location>=0){let Te=j[Q];if(Te===void 0&&(Q==="instanceMatrix"&&F.instanceMatrix&&(Te=F.instanceMatrix),Q==="instanceColor"&&F.instanceColor&&(Te=F.instanceColor)),Te!==void 0){const we=Te.normalized,Pe=Te.itemSize,it=t.get(Te);if(it===void 0)continue;const le=it.buffer,et=it.type,Ge=it.bytesPerElement;if(Te.isInterleavedBufferAttribute){const Ae=Te.data,Fe=Ae.stride,nt=Te.offset;if(Ae&&Ae.isInstancedInterleavedBuffer){for(let ne=0;ne<te.locationSize;ne++)w(te.location+ne,Ae.meshPerAttribute);F.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=Ae.meshPerAttribute*Ae.count)}else for(let ne=0;ne<te.locationSize;ne++)b(te.location+ne);n.bindBuffer(34962,le);for(let ne=0;ne<te.locationSize;ne++)M(te.location+ne,Pe/te.locationSize,et,we,Fe*Ge,(nt+Pe/te.locationSize*ne)*Ge)}else{if(Te.isInstancedBufferAttribute){for(let Ae=0;Ae<te.locationSize;Ae++)w(te.location+Ae,Te.meshPerAttribute);F.isInstancedMesh!==!0&&H._maxInstanceCount===void 0&&(H._maxInstanceCount=Te.meshPerAttribute*Te.count)}else for(let Ae=0;Ae<te.locationSize;Ae++)b(te.location+Ae);n.bindBuffer(34962,le);for(let Ae=0;Ae<te.locationSize;Ae++)M(te.location+Ae,Pe/te.locationSize,et,we,Pe*Ge,Pe/te.locationSize*Ae*Ge)}}else if(fe!==void 0){const we=fe[Q];if(we!==void 0)switch(we.length){case 2:n.vertexAttrib2fv(te.location,we);break;case 3:n.vertexAttrib3fv(te.location,we);break;case 4:n.vertexAttrib4fv(te.location,we);break;default:n.vertexAttrib1fv(te.location,we)}}}}C()}function A(){R();for(const F in a){const z=a[F];for(const V in z){const H=z[V];for(const j in H)p(H[j].object),delete H[j];delete z[V]}delete a[F]}}function $(F){if(a[F.id]===void 0)return;const z=a[F.id];for(const V in z){const H=z[V];for(const j in H)p(H[j].object),delete H[j];delete z[V]}delete a[F.id]}function B(F){for(const z in a){const V=a[z];if(V[F.id]===void 0)continue;const H=V[F.id];for(const j in H)p(H[j].object),delete H[j];delete V[F.id]}}function R(){K(),c!==l&&(c=l,d(c.object))}function K(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:u,reset:R,resetDefaultState:K,dispose:A,releaseStatesOfGeometry:$,releaseStatesOfProgram:B,initAttributes:x,enableAttribute:b,disableUnusedAttributes:C}}function AU(n,e,t,s){const r=s.isWebGL2;let i;function o(c){i=c}function a(c,u){n.drawArrays(i,c,u),t.update(u,i,1)}function l(c,u,h){if(h===0)return;let d,p;if(r)d=n,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](i,c,u,h),t.update(u,i,h)}this.setMode=o,this.render=a,this.renderInstances=l}function RU(n,e,t){let s;function r(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const E=e.get("EXT_texture_filter_anisotropic");s=n.getParameter(E.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function i(E){if(E==="highp"){if(n.getShaderPrecisionFormat(35633,36338).precision>0&&n.getShaderPrecisionFormat(35632,36338).precision>0)return"highp";E="mediump"}return E==="mediump"&&n.getShaderPrecisionFormat(35633,36337).precision>0&&n.getShaderPrecisionFormat(35632,36337).precision>0?"mediump":"lowp"}const o=typeof WebGL2RenderingContext!="undefined"&&n instanceof WebGL2RenderingContext||typeof WebGL2ComputeRenderingContext!="undefined"&&n instanceof WebGL2ComputeRenderingContext;let a=t.precision!==void 0?t.precision:"highp";const l=i(a);l!==a&&(console.warn("THREE.WebGLRenderer:",a,"not supported, using",l,"instead."),a=l);const c=o||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=n.getParameter(34930),d=n.getParameter(35660),p=n.getParameter(3379),f=n.getParameter(34076),m=n.getParameter(34921),y=n.getParameter(36347),g=n.getParameter(36348),x=n.getParameter(36349),b=d>0,w=o||e.has("OES_texture_float"),C=b&&w,M=o?n.getParameter(36183):0;return{isWebGL2:o,drawBuffers:c,getMaxAnisotropy:r,getMaxPrecision:i,precision:a,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:f,maxAttributes:m,maxVertexUniforms:y,maxVaryings:g,maxFragmentUniforms:x,vertexTextures:b,floatFragmentTextures:w,floatVertexTextures:C,maxSamples:M}}function IU(n){const e=this;let t=null,s=0,r=!1,i=!1;const o=new Nr,a=new En,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d,p){const f=h.length!==0||d||s!==0||r;return r=d,t=u(h,p,0),s=h.length,f},this.beginShadows=function(){i=!0,u(null)},this.endShadows=function(){i=!1,c()},this.setState=function(h,d,p){const f=h.clippingPlanes,m=h.clipIntersection,y=h.clipShadows,g=n.get(h);if(!r||f===null||f.length===0||i&&!y)i?u(null):c();else{const x=i?0:s,b=x*4;let w=g.clippingState||null;l.value=w,w=u(f,d,b,p);for(let C=0;C!==b;++C)w[C]=t[C];g.clippingState=w,this.numIntersection=m?this.numPlanes:0,this.numPlanes+=x}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function u(h,d,p,f){const m=h!==null?h.length:0;let y=null;if(m!==0){if(y=l.value,f!==!0||y===null){const g=p+m*4,x=d.matrixWorldInverse;a.getNormalMatrix(x),(y===null||y.length<g)&&(y=new Float32Array(g));for(let b=0,w=p;b!==m;++b,w+=4)o.copy(h[b]).applyMatrix4(x,a),o.normal.toArray(y,w),y[w+3]=o.constant}l.value=y,l.needsUpdate=!0}return e.numPlanes=m,e.numIntersection=0,y}}function NU(n){let e=new WeakMap;function t(o,a){return a===Bd?o.mapping=fl:a===zd&&(o.mapping=ml),o}function s(o){if(o&&o.isTexture&&o.isRenderTargetTexture===!1){const a=o.mapping;if(a===Bd||a===zd)if(e.has(o)){const l=e.get(o).texture;return t(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=n.getRenderTarget(),u=new Dx(l.height/2);return u.fromEquirectangularTexture(n,o),e.set(o,u),n.setRenderTarget(c),o.addEventListener("dispose",r),t(u.texture,o.mapping)}else return null}}return o}function r(o){const a=o.target;a.removeEventListener("dispose",r);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function i(){e=new WeakMap}return{get:s,dispose:i}}class Ml extends bp{constructor(e=-1,t=1,s=1,r=-1,i=.1,o=2e3){super();this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=r,this.near=i,this.far=o,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,r,i,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=r,this.view.width=i,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,r=(this.top+this.bottom)/2;let i=s-e,o=s+e,a=r+t,l=r-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;i+=c*this.view.offsetX,o=i+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(i,o,a,l,this.near,this.far),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}Ml.prototype.isOrthographicCamera=!0;class xu extends Ji{constructor(e){super(e);this.type="RawShaderMaterial"}}xu.prototype.isRawShaderMaterial=!0;const ga=4,ci=8,Zs=Math.pow(2,ci),$x=[.125,.215,.35,.446,.526,.582],Fx=ci-ga+1+$x.length,xa=20,Qi={[Jn]:0,[ti]:1,[jd]:2,[dx]:3,[px]:4,[fx]:5,[Xd]:6},Sp=new Ml,{_lodPlanes:Al,_sizeLods:Ox,_sigmas:yu}=DU(),Bx=new Le;let Tp=null;const eo=(1+Math.sqrt(5))/2,ya=1/eo,zx=[new L(1,1,1),new L(-1,1,1),new L(1,1,-1),new L(-1,1,-1),new L(0,eo,ya),new L(0,eo,-ya),new L(ya,0,eo),new L(-ya,0,eo),new L(eo,ya,0),new L(-eo,ya,0)];class LU{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._blurMaterial=kU(xa),this._equirectShader=null,this._cubemapShader=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,r=100){Tp=this._renderer.getRenderTarget();const i=this._allocateTargets();return this._sceneToCubeUV(e,s,r,i),t>0&&this._blur(i,0,0,t),this._applyPMREM(i),this._cleanup(i),i}fromEquirectangular(e){return this._fromTexture(e)}fromCubemap(e){return this._fromTexture(e)}compileCubemapShader(){this._cubemapShader===null&&(this._cubemapShader=Gx(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){this._equirectShader===null&&(this._equirectShader=Vx(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose(),this._cubemapShader!==null&&this._cubemapShader.dispose(),this._equirectShader!==null&&this._equirectShader.dispose();for(let e=0;e<Al.length;e++)Al[e].dispose()}_cleanup(e){this._pingPongRenderTarget.dispose(),this._renderer.setRenderTarget(Tp),e.scissorTest=!1,vu(e,0,0,e.width,e.height)}_fromTexture(e){Tp=this._renderer.getRenderTarget();const t=this._allocateTargets(e);return this._textureToCubeUV(e,t),this._applyPMREM(t),this._cleanup(t),t}_allocateTargets(e){const t={magFilter:hn,minFilter:hn,generateMipmaps:!1,type:Qr,format:AF,encoding:PU(e)?e.encoding:jd,depthBuffer:!1},s=Ux(t);return s.depthBuffer=!e,this._pingPongRenderTarget=Ux(t),s}_compileMaterial(e){const t=new fn(Al[0],e);this._renderer.compile(t,Sp)}_sceneToCubeUV(e,t,s,r){const i=90,o=1,a=new Gn(i,o,t,s),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.outputEncoding,p=u.toneMapping;u.getClearColor(Bx),u.toneMapping=Hi,u.outputEncoding=Jn,u.autoClear=!1;const f=new Ks({name:"PMREM.Background",side:un,depthWrite:!1,depthTest:!1}),m=new fn(new Cl,f);let y=!1;const g=e.background;g?g.isColor&&(f.color.copy(g),e.background=null,y=!0):(f.color.copy(Bx),y=!0);for(let x=0;x<6;x++){const b=x%3;b==0?(a.up.set(0,l[x],0),a.lookAt(c[x],0,0)):b==1?(a.up.set(0,0,l[x]),a.lookAt(0,c[x],0)):(a.up.set(0,l[x],0),a.lookAt(0,0,c[x])),vu(r,b*Zs,x>2?Zs:0,Zs,Zs),u.setRenderTarget(r),y&&u.render(m,a),u.render(e,a)}m.geometry.dispose(),m.material.dispose(),u.toneMapping=p,u.outputEncoding=d,u.autoClear=h,e.background=g}_setEncoding(e,t){e.value=Qi[t.encoding]}_textureToCubeUV(e,t){const s=this._renderer,r=e.mapping===fl||e.mapping===ml;r?this._cubemapShader==null&&(this._cubemapShader=Gx()):this._equirectShader==null&&(this._equirectShader=Vx());const i=r?this._cubemapShader:this._equirectShader,o=new fn(Al[0],i),a=i.uniforms;a.envMap.value=e,r||a.texelSize.value.set(1/e.image.width,1/e.image.height),this._setEncoding(a.inputEncoding,e),this._setEncoding(a.outputEncoding,t.texture),vu(t,0,0,3*Zs,2*Zs),s.setRenderTarget(t),s.render(o,Sp)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;for(let r=1;r<Fx;r++){const i=Math.sqrt(yu[r]*yu[r]-yu[r-1]*yu[r-1]),o=zx[(r-1)%zx.length];this._blur(e,r-1,r,i,o)}t.autoClear=s}_blur(e,t,s,r,i){const o=this._pingPongRenderTarget;this._halfBlur(e,o,t,s,r,"latitudinal",i),this._halfBlur(o,e,s,s,r,"longitudinal",i)}_halfBlur(e,t,s,r,i,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new fn(Al[r],c),d=c.uniforms,p=Ox[s]-1,f=isFinite(i)?Math.PI/(2*p):2*Math.PI/(2*xa-1),m=i/f,y=isFinite(i)?1+Math.floor(u*m):xa;y>xa&&console.warn(`sigmaRadians, ${i}, is too large and will clip, as it requested ${y} samples when the maximum is set to ${xa}`);const g=[];let x=0;for(let M=0;M<xa;++M){const E=M/m,A=Math.exp(-E*E/2);g.push(A),M==0?x+=A:M<y&&(x+=2*A)}for(let M=0;M<g.length;M++)g[M]=g[M]/x;d.envMap.value=e.texture,d.samples.value=y,d.weights.value=g,d.latitudinal.value=o==="latitudinal",a&&(d.poleAxis.value=a),d.dTheta.value=f,d.mipInt.value=ci-s,this._setEncoding(d.inputEncoding,e.texture),this._setEncoding(d.outputEncoding,e.texture);const b=Ox[r],w=3*Math.max(0,Zs-2*b),C=(r===0?0:2*Zs)+2*b*(r>ci-ga?r-ci+ga:0);vu(t,w,C,3*b,2*b),l.setRenderTarget(t),l.render(h,Sp)}}function PU(n){return n===void 0||n.type!==Qr?!1:n.encoding===Jn||n.encoding===ti||n.encoding===Xd}function DU(){const n=[],e=[],t=[];let s=ci;for(let r=0;r<Fx;r++){const i=Math.pow(2,s);e.push(i);let o=1/i;r>ci-ga?o=$x[r-ci+ga-1]:r==0&&(o=0),t.push(o);const a=1/(i-1),l=-a/2,c=1+a/2,u=[l,l,c,l,c,c,l,l,c,c,l,c],h=6,d=6,p=3,f=2,m=1,y=new Float32Array(p*d*h),g=new Float32Array(f*d*h),x=new Float32Array(m*d*h);for(let w=0;w<h;w++){const C=w%3*2/3-1,M=w>2?0:-1,E=[C,M,0,C+2/3,M,0,C+2/3,M+1,0,C,M,0,C+2/3,M+1,0,C,M+1,0];y.set(E,p*d*w),g.set(u,f*d*w);const A=[w,w,w,w,w,w];x.set(A,m*d*w)}const b=new Wt;b.setAttribute("position",new en(y,p)),b.setAttribute("uv",new en(g,f)),b.setAttribute("faceIndex",new en(x,m)),n.push(b),s>ga&&s--}return{_lodPlanes:n,_sizeLods:e,_sigmas:t}}function Ux(n){const e=new Ts(3*Zs,3*Zs,n);return e.texture.mapping=Hc,e.texture.name="PMREM.cubeUv",e.scissorTest=!0,e}function vu(n,e,t,s,r){n.viewport.set(e,t,s,r),n.scissor.set(e,t,s,r)}function kU(n){const e=new Float32Array(n),t=new L(0,1,0);return new xu({name:"SphericalGaussianBlur",defines:{n},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:e},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:t},inputEncoding:{value:Qi[Jn]},outputEncoding:{value:Qi[Jn]}},vertexShader:Ep(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${Cp()}

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Jr,depthTest:!1,depthWrite:!1})}function Vx(){const n=new pe(1,1);return new xu({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:n},inputEncoding:{value:Qi[Jn]},outputEncoding:{value:Qi[Jn]}},vertexShader:Ep(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${Cp()}

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Jr,depthTest:!1,depthWrite:!1})}function Gx(){return new xu({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},inputEncoding:{value:Qi[Jn]},outputEncoding:{value:Qi[Jn]}},vertexShader:Ep(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${Cp()}

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,blending:Jr,depthTest:!1,depthWrite:!1})}function Ep(){return`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function Cp(){return`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`}function $U(n){let e=new WeakMap,t=null;function s(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const l=a.mapping,c=l===Bd||l===zd,u=l===fl||l===ml;if(c||u){if(e.has(a))return e.get(a).texture;{const h=a.image;if(c&&h&&h.height>0||u&&h&&r(h)){const d=n.getRenderTarget();t===null&&(t=new LU(n));const p=c?t.fromEquirectangular(a):t.fromCubemap(a);return e.set(a,p),n.setRenderTarget(d),a.addEventListener("dispose",i),p.texture}else return null}}}return a}function r(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function i(a){const l=a.target;l.removeEventListener("dispose",i);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:o}}function FU(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let r;switch(s){case"WEBGL_depth_texture":r=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":r=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":r=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":r=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:r=n.getExtension(s)}return e[s]=r,r}return{has:function(s){return t(s)!==null},init:function(s){s.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(s){const r=t(s);return r===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),r}}}function OU(n,e,t,s){const r={},i=new WeakMap;function o(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const f in d.attributes)e.remove(d.attributes[f]);d.removeEventListener("dispose",o),delete r[d.id];const p=i.get(d);p&&(e.remove(p),i.delete(d)),s.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function a(h,d){return r[d.id]===!0||(d.addEventListener("dispose",o),r[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const f in d)e.update(d[f],34962);const p=h.morphAttributes;for(const f in p){const m=p[f];for(let y=0,g=m.length;y<g;y++)e.update(m[y],34962)}}function c(h){const d=[],p=h.index,f=h.attributes.position;let m=0;if(p!==null){const x=p.array;m=p.version;for(let b=0,w=x.length;b<w;b+=3){const C=x[b+0],M=x[b+1],E=x[b+2];d.push(C,M,M,E,E,C)}}else{const x=f.array;m=f.version;for(let b=0,w=x.length/3-1;b<w;b+=3){const C=b+0,M=b+1,E=b+2;d.push(C,M,M,E,E,C)}}const y=new(yx(d)>65535?Lx:Nx)(d,1);y.version=m;const g=i.get(h);g&&e.remove(g),i.set(h,y)}function u(h){const d=i.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&c(h)}else c(h);return i.get(h)}return{get:a,update:l,getWireframeAttribute:u}}function BU(n,e,t,s){const r=s.isWebGL2;let i;function o(d){i=d}let a,l;function c(d){a=d.type,l=d.bytesPerElement}function u(d,p){n.drawElements(i,p,a,d*l),t.update(p,i,1)}function h(d,p,f){if(f===0)return;let m,y;if(r)m=n,y="drawElementsInstanced";else if(m=e.get("ANGLE_instanced_arrays"),y="drawElementsInstancedANGLE",m===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}m[y](i,p,a,d*l,f),t.update(p,i,f)}this.setMode=o,this.setIndex=c,this.render=u,this.renderInstances=h}function zU(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(i,o,a){switch(t.calls++,o){case 4:t.triangles+=a*(i/3);break;case 1:t.lines+=a*(i/2);break;case 3:t.lines+=a*(i-1);break;case 2:t.lines+=a*i;break;case 0:t.points+=a*i;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function r(){t.frame++,t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:r,update:s}}class Mp extends dn{constructor(e=null,t=1,s=1,r=1){super(null);this.image={data:e,width:t,height:s,depth:r},this.magFilter=hn,this.minFilter=hn,this.wrapR=Yn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Mp.prototype.isDataTexture2DArray=!0;function UU(n,e){return n[0]-e[0]}function VU(n,e){return Math.abs(e[1])-Math.abs(n[1])}function Wx(n,e){let t=1;const s=e.isInterleavedBufferAttribute?e.data.array:e.array;s instanceof Int8Array?t=127:s instanceof Int16Array?t=32767:s instanceof Int32Array?t=2147483647:console.error("THREE.WebGLMorphtargets: Unsupported morph attribute data type: ",s),n.divideScalar(t)}function GU(n,e,t){const s={},r=new Float32Array(8),i=new WeakMap,o=new L,a=[];for(let c=0;c<8;c++)a[c]=[c,0];function l(c,u,h,d){const p=c.morphTargetInfluences;if(e.isWebGL2===!0){const f=u.morphAttributes.position.length;let m=i.get(u);if(m===void 0||m.count!==f){m!==void 0&&m.texture.dispose();const x=u.morphAttributes.normal!==void 0,b=u.morphAttributes.position,w=u.morphAttributes.normal||[],C=u.attributes.position.count,M=x===!0?2:1;let E=C*M,A=1;E>e.maxTextureSize&&(A=Math.ceil(E/e.maxTextureSize),E=e.maxTextureSize);const $=new Float32Array(E*A*4*f),B=new Mp($,E,A,f);B.format=Ln,B.type=Er;const R=M*4;for(let K=0;K<f;K++){const F=b[K],z=w[K],V=E*A*4*K;for(let H=0;H<F.count;H++){o.fromBufferAttribute(F,H),F.normalized===!0&&Wx(o,F);const j=H*R;$[V+j+0]=o.x,$[V+j+1]=o.y,$[V+j+2]=o.z,$[V+j+3]=0,x===!0&&(o.fromBufferAttribute(z,H),z.normalized===!0&&Wx(o,z),$[V+j+4]=o.x,$[V+j+5]=o.y,$[V+j+6]=o.z,$[V+j+7]=0)}}m={count:f,texture:B,size:new pe(E,A)},i.set(u,m)}let y=0;for(let x=0;x<p.length;x++)y+=p[x];const g=u.morphTargetsRelative?1:1-y;d.getUniforms().setValue(n,"morphTargetBaseInfluence",g),d.getUniforms().setValue(n,"morphTargetInfluences",p),d.getUniforms().setValue(n,"morphTargetsTexture",m.texture,t),d.getUniforms().setValue(n,"morphTargetsTextureSize",m.size)}else{const f=p===void 0?0:p.length;let m=s[u.id];if(m===void 0||m.length!==f){m=[];for(let w=0;w<f;w++)m[w]=[w,0];s[u.id]=m}for(let w=0;w<f;w++){const C=m[w];C[0]=w,C[1]=p[w]}m.sort(VU);for(let w=0;w<8;w++)w<f&&m[w][1]?(a[w][0]=m[w][0],a[w][1]=m[w][1]):(a[w][0]=Number.MAX_SAFE_INTEGER,a[w][1]=0);a.sort(UU);const y=u.morphAttributes.position,g=u.morphAttributes.normal;let x=0;for(let w=0;w<8;w++){const C=a[w],M=C[0],E=C[1];M!==Number.MAX_SAFE_INTEGER&&E?(y&&u.getAttribute("morphTarget"+w)!==y[M]&&u.setAttribute("morphTarget"+w,y[M]),g&&u.getAttribute("morphNormal"+w)!==g[M]&&u.setAttribute("morphNormal"+w,g[M]),r[w]=E,x+=E):(y&&u.hasAttribute("morphTarget"+w)===!0&&u.deleteAttribute("morphTarget"+w),g&&u.hasAttribute("morphNormal"+w)===!0&&u.deleteAttribute("morphNormal"+w),r[w]=0)}const b=u.morphTargetsRelative?1:1-x;d.getUniforms().setValue(n,"morphTargetBaseInfluence",b),d.getUniforms().setValue(n,"morphTargetInfluences",r)}}return{update:l}}function WU(n,e,t,s){let r=new WeakMap;function i(l){const c=s.render.frame,u=l.geometry,h=e.get(l,u);return r.get(h)!==c&&(e.update(h),r.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),t.update(l.instanceMatrix,34962),l.instanceColor!==null&&t.update(l.instanceColor,34962)),h}function o(){r=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:i,dispose:o}}class Hx extends dn{constructor(e=null,t=1,s=1,r=1){super(null);this.image={data:e,width:t,height:s,depth:r},this.magFilter=hn,this.minFilter=hn,this.wrapR=Yn,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}Hx.prototype.isDataTexture3D=!0;const Xx=new dn,jx=new Mp,qx=new Hx,Kx=new fu,Yx=[],Zx=[],Jx=new Float32Array(16),Qx=new Float32Array(9),ey=new Float32Array(4);function va(n,e,t){const s=n[0];if(s<=0||s>0)return n;const r=e*t;let i=Yx[r];if(i===void 0&&(i=new Float32Array(r),Yx[r]=i),e!==0){s.toArray(i,0);for(let o=1,a=0;o!==e;++o)a+=t,n[o].toArray(i,a)}return i}function Wn(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function Dn(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function bu(n,e){let t=Zx[e];t===void 0&&(t=new Int32Array(e),Zx[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function HU(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function XU(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Wn(t,e))return;n.uniform2fv(this.addr,e),Dn(t,e)}}function jU(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Wn(t,e))return;n.uniform3fv(this.addr,e),Dn(t,e)}}function qU(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Wn(t,e))return;n.uniform4fv(this.addr,e),Dn(t,e)}}function KU(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Wn(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Dn(t,e)}else{if(Wn(t,s))return;ey.set(s),n.uniformMatrix2fv(this.addr,!1,ey),Dn(t,s)}}function YU(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Wn(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Dn(t,e)}else{if(Wn(t,s))return;Qx.set(s),n.uniformMatrix3fv(this.addr,!1,Qx),Dn(t,s)}}function ZU(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Wn(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Dn(t,e)}else{if(Wn(t,s))return;Jx.set(s),n.uniformMatrix4fv(this.addr,!1,Jx),Dn(t,s)}}function JU(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function QU(n,e){const t=this.cache;Wn(t,e)||(n.uniform2iv(this.addr,e),Dn(t,e))}function eV(n,e){const t=this.cache;Wn(t,e)||(n.uniform3iv(this.addr,e),Dn(t,e))}function tV(n,e){const t=this.cache;Wn(t,e)||(n.uniform4iv(this.addr,e),Dn(t,e))}function nV(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function sV(n,e){const t=this.cache;Wn(t,e)||(n.uniform2uiv(this.addr,e),Dn(t,e))}function rV(n,e){const t=this.cache;Wn(t,e)||(n.uniform3uiv(this.addr,e),Dn(t,e))}function iV(n,e){const t=this.cache;Wn(t,e)||(n.uniform4uiv(this.addr,e),Dn(t,e))}function oV(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.safeSetTexture2D(e||Xx,r)}function aV(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTexture3D(e||qx,r)}function lV(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.safeSetTextureCube(e||Kx,r)}function cV(n,e,t){const s=this.cache,r=t.allocateTextureUnit();s[0]!==r&&(n.uniform1i(this.addr,r),s[0]=r),t.setTexture2DArray(e||jx,r)}function uV(n){switch(n){case 5126:return HU;case 35664:return XU;case 35665:return jU;case 35666:return qU;case 35674:return KU;case 35675:return YU;case 35676:return ZU;case 5124:case 35670:return JU;case 35667:case 35671:return QU;case 35668:case 35672:return eV;case 35669:case 35673:return tV;case 5125:return nV;case 36294:return sV;case 36295:return rV;case 36296:return iV;case 35678:case 36198:case 36298:case 36306:case 35682:return oV;case 35679:case 36299:case 36307:return aV;case 35680:case 36300:case 36308:case 36293:return lV;case 36289:case 36303:case 36311:case 36292:return cV}}function hV(n,e){n.uniform1fv(this.addr,e)}function dV(n,e){const t=va(e,this.size,2);n.uniform2fv(this.addr,t)}function pV(n,e){const t=va(e,this.size,3);n.uniform3fv(this.addr,t)}function fV(n,e){const t=va(e,this.size,4);n.uniform4fv(this.addr,t)}function mV(n,e){const t=va(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function gV(n,e){const t=va(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function xV(n,e){const t=va(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function yV(n,e){n.uniform1iv(this.addr,e)}function vV(n,e){n.uniform2iv(this.addr,e)}function bV(n,e){n.uniform3iv(this.addr,e)}function wV(n,e){n.uniform4iv(this.addr,e)}function _V(n,e){n.uniform1uiv(this.addr,e)}function SV(n,e){n.uniform2uiv(this.addr,e)}function TV(n,e){n.uniform3uiv(this.addr,e)}function EV(n,e){n.uniform4uiv(this.addr,e)}function CV(n,e,t){const s=e.length,r=bu(t,s);n.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)t.safeSetTexture2D(e[i]||Xx,r[i])}function MV(n,e,t){const s=e.length,r=bu(t,s);n.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)t.setTexture3D(e[i]||qx,r[i])}function AV(n,e,t){const s=e.length,r=bu(t,s);n.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)t.safeSetTextureCube(e[i]||Kx,r[i])}function RV(n,e,t){const s=e.length,r=bu(t,s);n.uniform1iv(this.addr,r);for(let i=0;i!==s;++i)t.setTexture2DArray(e[i]||jx,r[i])}function IV(n){switch(n){case 5126:return hV;case 35664:return dV;case 35665:return pV;case 35666:return fV;case 35674:return mV;case 35675:return gV;case 35676:return xV;case 5124:case 35670:return yV;case 35667:case 35671:return vV;case 35668:case 35672:return bV;case 35669:case 35673:return wV;case 5125:return _V;case 36294:return SV;case 36295:return TV;case 36296:return EV;case 35678:case 36198:case 36298:case 36306:case 35682:return CV;case 35679:case 36299:case 36307:return MV;case 35680:case 36300:case 36308:case 36293:return AV;case 36289:case 36303:case 36311:case 36292:return RV}}function NV(n,e,t){this.id=n,this.addr=t,this.cache=[],this.setValue=uV(e.type)}function ty(n,e,t){this.id=n,this.addr=t,this.cache=[],this.size=e.size,this.setValue=IV(e.type)}ty.prototype.updateCache=function(n){const e=this.cache;n instanceof Float32Array&&e.length!==n.length&&(this.cache=new Float32Array(n.length)),Dn(e,n)};function ny(n){this.id=n,this.seq=[],this.map={}}ny.prototype.setValue=function(n,e,t){const s=this.seq;for(let r=0,i=s.length;r!==i;++r){const o=s[r];o.setValue(n,e[o.id],t)}};const Ap=/(\w+)(\])?(\[|\.)?/g;function sy(n,e){n.seq.push(e),n.map[e.id]=e}function LV(n,e,t){const s=n.name,r=s.length;for(Ap.lastIndex=0;;){const i=Ap.exec(s),o=Ap.lastIndex;let a=i[1];const l=i[2]==="]",c=i[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===r){sy(t,c===void 0?new NV(a,n,e):new ty(a,n,e));break}else{let h=t.map[a];h===void 0&&(h=new ny(a),sy(t,h)),t=h}}}function ui(n,e){this.seq=[],this.map={};const t=n.getProgramParameter(e,35718);for(let s=0;s<t;++s){const r=n.getActiveUniform(e,s),i=n.getUniformLocation(e,r.name);LV(r,i,this)}}ui.prototype.setValue=function(n,e,t,s){const r=this.map[e];r!==void 0&&r.setValue(n,t,s)};ui.prototype.setOptional=function(n,e,t){const s=e[t];s!==void 0&&this.setValue(n,t,s)};ui.upload=function(n,e,t,s){for(let r=0,i=e.length;r!==i;++r){const o=e[r],a=t[o.id];a.needsUpdate!==!1&&o.setValue(n,a.value,s)}};ui.seqWithValue=function(n,e){const t=[];for(let s=0,r=n.length;s!==r;++s){const i=n[s];i.id in e&&t.push(i)}return t};function ry(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}let PV=0;function DV(n){const e=n.split(`
`);for(let t=0;t<e.length;t++)e[t]=t+1+": "+e[t];return e.join(`
`)}function iy(n){switch(n){case Jn:return["Linear","( value )"];case ti:return["sRGB","( value )"];case jd:return["RGBE","( value )"];case dx:return["RGBM","( value, 7.0 )"];case px:return["RGBM","( value, 16.0 )"];case fx:return["RGBD","( value, 256.0 )"];case Xd:return["Gamma","( value, float( GAMMA_FACTOR ) )"];default:return console.warn("THREE.WebGLProgram: Unsupported encoding:",n),["Linear","( value )"]}}function oy(n,e,t){const s=n.getShaderParameter(e,35713),r=n.getShaderInfoLog(e).trim();return s&&r===""?"":t.toUpperCase()+`

`+r+`

`+DV(n.getShaderSource(e))}function to(n,e){const t=iy(e);return"vec4 "+n+"( vec4 value ) { return "+t[0]+"ToLinear"+t[1]+"; }"}function kV(n,e){const t=iy(e);return"vec4 "+n+"( vec4 value ) { return LinearTo"+t[0]+t[1]+"; }"}function $V(n,e){let t;switch(e){case fF:t="Linear";break;case mF:t="Reinhard";break;case gF:t="OptimizedCineon";break;case xF:t="ACESFilmic";break;case yF:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function FV(n){return[n.extensionDerivatives||n.envMapCubeUV||n.bumpMap||n.tangentSpaceNormalMap||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(Rl).join(`
`)}function OV(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function BV(n,e){const t={},s=n.getProgramParameter(e,35721);for(let r=0;r<s;r++){const i=n.getActiveAttrib(e,r),o=i.name;let a=1;i.type===35674&&(a=2),i.type===35675&&(a=3),i.type===35676&&(a=4),t[o]={type:i.type,location:n.getAttribLocation(e,o),locationSize:a}}return t}function Rl(n){return n!==""}function ay(n,e){return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function ly(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const zV=/^[ \t]*#include +<([\w\d./]+)>/gm;function Rp(n){return n.replace(zV,UV)}function UV(n,e){const t=ft[e];if(t===void 0)throw new Error("Can not resolve #include <"+e+">");return Rp(t)}const VV=/#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,GV=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function cy(n){return n.replace(GV,uy).replace(VV,WV)}function WV(n,e,t,s){return console.warn("WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead."),uy(n,e,t,s)}function uy(n,e,t,s){let r="";for(let i=parseInt(e);i<parseInt(t);i++)r+=s.replace(/\[\s*i\s*\]/g,"[ "+i+" ]").replace(/UNROLLED_LOOP_INDEX/g,i);return r}function hy(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function HV(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===G4?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===X$?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===dl&&(e="SHADOWMAP_TYPE_VSM"),e}function XV(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case fl:case ml:e="ENVMAP_TYPE_CUBE";break;case Hc:case Ud:e="ENVMAP_TYPE_CUBE_UV";break}return e}function jV(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case ml:case Ud:e="ENVMAP_MODE_REFRACTION";break}return e}function qV(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Wc:e="ENVMAP_BLENDING_MULTIPLY";break;case dF:e="ENVMAP_BLENDING_MIX";break;case pF:e="ENVMAP_BLENDING_ADD";break}return e}function KV(n,e,t,s){const r=n.getContext(),i=t.defines;let o=t.vertexShader,a=t.fragmentShader;const l=HV(t),c=XV(t),u=jV(t),h=qV(t),d=n.gammaFactor>0?n.gammaFactor:1,p=t.isWebGL2?"":FV(t),f=OV(i),m=r.createProgram();let y,g,x=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(y=[f].filter(Rl).join(`
`),y.length>0&&(y+=`
`),g=[p,f].filter(Rl).join(`
`),g.length>0&&(g+=`
`)):(y=[hy(t),"#define SHADER_NAME "+t.shaderName,f,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.supportsVertexTextures?"#define VERTEX_TEXTURES":"","#define GAMMA_FACTOR "+d,"#define MAX_BONES "+t.maxBones,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.displacementMap&&t.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.useVertexTexture?"#define BONE_TEXTURE":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargets&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(Rl).join(`
`),g=[p,hy(t),"#define SHADER_NAME "+t.shaderName,f,"#define GAMMA_FACTOR "+d,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMap&&t.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",t.normalMap&&t.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",t.specularColorMap?"#define USE_SPECULARCOLORMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEENCOLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUvs?"#define USE_UV":"",t.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"",(t.extensionShaderTextureLOD||t.envMap)&&t.rendererExtensionShaderTextureLod?"#define TEXTURE_LOD_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Hi?"#define TONE_MAPPING":"",t.toneMapping!==Hi?ft.tonemapping_pars_fragment:"",t.toneMapping!==Hi?$V("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.format===ei?"#define OPAQUE":"",ft.encodings_pars_fragment,t.map?to("mapTexelToLinear",t.mapEncoding):"",t.matcap?to("matcapTexelToLinear",t.matcapEncoding):"",t.envMap?to("envMapTexelToLinear",t.envMapEncoding):"",t.emissiveMap?to("emissiveMapTexelToLinear",t.emissiveMapEncoding):"",t.specularColorMap?to("specularColorMapTexelToLinear",t.specularColorMapEncoding):"",t.sheenColorMap?to("sheenColorMapTexelToLinear",t.sheenColorMapEncoding):"",t.lightMap?to("lightMapTexelToLinear",t.lightMapEncoding):"",kV("linearToOutputTexel",t.outputEncoding),t.depthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(Rl).join(`
`)),o=Rp(o),o=ay(o,t),o=ly(o,t),a=Rp(a),a=ay(a,t),a=ly(a,t),o=cy(o),a=cy(a),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(x=`#version 300 es
`,y=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+y,g=["#define varying in",t.glslVersion===mx?"":"out highp vec4 pc_fragColor;",t.glslVersion===mx?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const b=x+y+o,w=x+g+a,C=ry(r,35633,b),M=ry(r,35632,w);if(r.attachShader(m,C),r.attachShader(m,M),t.index0AttributeName!==void 0?r.bindAttribLocation(m,0,t.index0AttributeName):t.morphTargets===!0&&r.bindAttribLocation(m,0,"position"),r.linkProgram(m),n.debug.checkShaderErrors){const $=r.getProgramInfoLog(m).trim(),B=r.getShaderInfoLog(C).trim(),R=r.getShaderInfoLog(M).trim();let K=!0,F=!0;if(r.getProgramParameter(m,35714)===!1){K=!1;const z=oy(r,C,"vertex"),V=oy(r,M,"fragment");console.error("THREE.WebGLProgram: Shader Error "+r.getError()+" - VALIDATE_STATUS "+r.getProgramParameter(m,35715)+`

Program Info Log: `+$+`
`+z+`
`+V)}else $!==""?console.warn("THREE.WebGLProgram: Program Info Log:",$):(B===""||R==="")&&(F=!1);F&&(this.diagnostics={runnable:K,programLog:$,vertexShader:{log:B,prefix:y},fragmentShader:{log:R,prefix:g}})}r.deleteShader(C),r.deleteShader(M);let E;this.getUniforms=function(){return E===void 0&&(E=new ui(r,m)),E};let A;return this.getAttributes=function(){return A===void 0&&(A=BV(r,m)),A},this.destroy=function(){s.releaseStatesOfProgram(this),r.deleteProgram(m),this.program=void 0},this.name=t.shaderName,this.id=PV++,this.cacheKey=e,this.usedTimes=1,this.program=m,this.vertexShader=C,this.fragmentShader=M,this}function YV(n,e,t,s,r,i,o){const a=[],l=r.isWebGL2,c=r.logarithmicDepthBuffer,u=r.floatVertexTextures,h=r.maxVertexUniforms,d=r.vertexTextures;let p=r.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"},m=["precision","isWebGL2","supportsVertexTextures","outputEncoding","instancing","instancingColor","map","mapEncoding","matcap","matcapEncoding","envMap","envMapMode","envMapEncoding","envMapCubeUV","lightMap","lightMapEncoding","aoMap","emissiveMap","emissiveMapEncoding","bumpMap","normalMap","objectSpaceNormalMap","tangentSpaceNormalMap","clearcoat","clearcoatMap","clearcoatRoughnessMap","clearcoatNormalMap","displacementMap","specularMap",,"roughnessMap","metalnessMap","gradientMap","alphaMap","alphaTest","combine","vertexColors","vertexAlphas","vertexTangents","vertexUvs","uvsVertexOnly","fog","useFog","fogExp2","flatShading","sizeAttenuation","logarithmicDepthBuffer","skinning","maxBones","useVertexTexture","morphTargets","morphNormals","morphTargetsCount","premultipliedAlpha","numDirLights","numPointLights","numSpotLights","numHemiLights","numRectAreaLights","numDirLightShadows","numPointLightShadows","numSpotLightShadows","shadowMapEnabled","shadowMapType","toneMapping","physicallyCorrectLights","doubleSided","flipSided","numClippingPlanes","numClipIntersection","depthPacking","dithering","format","specularIntensityMap","specularColorMap","specularColorMapEncoding","transmission","transmissionMap","thicknessMap","sheen","sheenColorMap","sheenColorMapEncoding","sheenRoughnessMap"];function y(E){const $=E.skeleton.bones;if(u)return 1024;{const R=Math.floor((h-20)/4),K=Math.min(R,$.length);return K<$.length?(console.warn("THREE.WebGLRenderer: Skeleton has "+$.length+" bones. This GPU supports "+K+"."),0):K}}function g(E){let A;return E&&E.isTexture?A=E.encoding:E&&E.isWebGLRenderTarget?(console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."),A=E.texture.encoding):A=Jn,A}function x(E,A,$,B,R){const K=B.fog,F=E.isMeshStandardMaterial?B.environment:null,z=(E.isMeshStandardMaterial?t:e).get(E.envMap||F),V=f[E.type],H=R.isSkinnedMesh?y(R):0;E.precision!==null&&(p=r.getMaxPrecision(E.precision),p!==E.precision&&console.warn("THREE.WebGLProgram.getParameters:",E.precision,"not supported, using",p,"instead."));let j,ae;if(V){const we=Ys[V];j=we.vertexShader,ae=we.fragmentShader}else j=E.vertexShader,ae=E.fragmentShader;const fe=n.getRenderTarget(),Q=E.alphaTest>0,te=E.clearcoat>0;return{isWebGL2:l,shaderID:V,shaderName:E.type,vertexShader:j,fragmentShader:ae,defines:E.defines,isRawShaderMaterial:E.isRawShaderMaterial===!0,glslVersion:E.glslVersion,precision:p,instancing:R.isInstancedMesh===!0,instancingColor:R.isInstancedMesh===!0&&R.instanceColor!==null,supportsVertexTextures:d,outputEncoding:fe!==null?g(fe.texture):n.outputEncoding,map:!!E.map,mapEncoding:g(E.map),matcap:!!E.matcap,matcapEncoding:g(E.matcap),envMap:!!z,envMapMode:z&&z.mapping,envMapEncoding:g(z),envMapCubeUV:!!z&&(z.mapping===Hc||z.mapping===Ud),lightMap:!!E.lightMap,lightMapEncoding:g(E.lightMap),aoMap:!!E.aoMap,emissiveMap:!!E.emissiveMap,emissiveMapEncoding:g(E.emissiveMap),bumpMap:!!E.bumpMap,normalMap:!!E.normalMap,objectSpaceNormalMap:E.normalMapType===yO,tangentSpaceNormalMap:E.normalMapType===ji,clearcoat:te,clearcoatMap:te&&!!E.clearcoatMap,clearcoatRoughnessMap:te&&!!E.clearcoatRoughnessMap,clearcoatNormalMap:te&&!!E.clearcoatNormalMap,displacementMap:!!E.displacementMap,roughnessMap:!!E.roughnessMap,metalnessMap:!!E.metalnessMap,specularMap:!!E.specularMap,specularIntensityMap:!!E.specularIntensityMap,specularColorMap:!!E.specularColorMap,specularColorMapEncoding:g(E.specularColorMap),alphaMap:!!E.alphaMap,alphaTest:Q,gradientMap:!!E.gradientMap,sheen:E.sheen>0,sheenColorMap:!!E.sheenColorMap,sheenColorMapEncoding:g(E.sheenColorMap),sheenRoughnessMap:!!E.sheenRoughnessMap,transmission:E.transmission>0,transmissionMap:!!E.transmissionMap,thicknessMap:!!E.thicknessMap,combine:E.combine,vertexTangents:!!E.normalMap&&!!R.geometry&&!!R.geometry.attributes.tangent,vertexColors:E.vertexColors,vertexAlphas:E.vertexColors===!0&&!!R.geometry&&!!R.geometry.attributes.color&&R.geometry.attributes.color.itemSize===4,vertexUvs:!!E.map||!!E.bumpMap||!!E.normalMap||!!E.specularMap||!!E.alphaMap||!!E.emissiveMap||!!E.roughnessMap||!!E.metalnessMap||!!E.clearcoatMap||!!E.clearcoatRoughnessMap||!!E.clearcoatNormalMap||!!E.displacementMap||!!E.transmissionMap||!!E.thicknessMap||!!E.specularIntensityMap||!!E.specularColorMap||!!E.sheenColorMap||E.sheenRoughnessMap,uvsVertexOnly:!(!!E.map||!!E.bumpMap||!!E.normalMap||!!E.specularMap||!!E.alphaMap||!!E.emissiveMap||!!E.roughnessMap||!!E.metalnessMap||!!E.clearcoatNormalMap||E.transmission>0||!!E.transmissionMap||!!E.thicknessMap||!!E.specularIntensityMap||!!E.specularColorMap||E.sheen>0||!!E.sheenColorMap||!!E.sheenRoughnessMap)&&!!E.displacementMap,fog:!!K,useFog:E.fog,fogExp2:K&&K.isFogExp2,flatShading:!!E.flatShading,sizeAttenuation:E.sizeAttenuation,logarithmicDepthBuffer:c,skinning:R.isSkinnedMesh===!0&&H>0,maxBones:H,useVertexTexture:u,morphTargets:!!R.geometry&&!!R.geometry.morphAttributes.position,morphNormals:!!R.geometry&&!!R.geometry.morphAttributes.normal,morphTargetsCount:!!R.geometry&&!!R.geometry.morphAttributes.position?R.geometry.morphAttributes.position.length:0,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,format:E.format,dithering:E.dithering,shadowMapEnabled:n.shadowMap.enabled&&$.length>0,shadowMapType:n.shadowMap.type,toneMapping:E.toneMapped?n.toneMapping:Hi,physicallyCorrectLights:n.physicallyCorrectLights,premultipliedAlpha:E.premultipliedAlpha,doubleSided:E.side===Wi,flipSided:E.side===un,depthPacking:E.depthPacking!==void 0?E.depthPacking:!1,index0AttributeName:E.index0AttributeName,extensionDerivatives:E.extensions&&E.extensions.derivatives,extensionFragDepth:E.extensions&&E.extensions.fragDepth,extensionDrawBuffers:E.extensions&&E.extensions.drawBuffers,extensionShaderTextureLOD:E.extensions&&E.extensions.shaderTextureLOD,rendererExtensionFragDepth:l||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:l||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:l||s.has("EXT_shader_texture_lod"),customProgramCacheKey:E.customProgramCacheKey()}}function b(E){const A=[];if(E.shaderID?A.push(E.shaderID):(A.push(vx(E.fragmentShader)),A.push(vx(E.vertexShader))),E.defines!==void 0)for(const $ in E.defines)A.push($),A.push(E.defines[$]);if(E.isRawShaderMaterial===!1){for(let $=0;$<m.length;$++)A.push(E[m[$]]);A.push(n.outputEncoding),A.push(n.gammaFactor)}return A.push(E.customProgramCacheKey),A.join()}function w(E){const A=f[E.type];let $;if(A){const B=Ys[A];$=qO.clone(B.uniforms)}else $=E.uniforms;return $}function C(E,A){let $;for(let B=0,R=a.length;B<R;B++){const K=a[B];if(K.cacheKey===A){$=K,++$.usedTimes;break}}return $===void 0&&($=new KV(n,A,E,i),a.push($)),$}function M(E){if(--E.usedTimes==0){const A=a.indexOf(E);a[A]=a[a.length-1],a.pop(),E.destroy()}}return{getParameters:x,getProgramCacheKey:b,getUniforms:w,acquireProgram:C,releaseProgram:M,programs:a}}function ZV(){let n=new WeakMap;function e(i){let o=n.get(i);return o===void 0&&(o={},n.set(i,o)),o}function t(i){n.delete(i)}function s(i,o,a){n.get(i)[o]=a}function r(){n=new WeakMap}return{get:e,remove:t,update:s,dispose:r}}function JV(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.program!==e.program?n.program.id-e.program.id:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function dy(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function py(n){const e=[];let t=0;const s=[],r=[],i=[],o={id:-1};function a(){t=0,s.length=0,r.length=0,i.length=0}function l(p,f,m,y,g,x){let b=e[t];const w=n.get(m);return b===void 0?(b={id:p.id,object:p,geometry:f,material:m,program:w.program||o,groupOrder:y,renderOrder:p.renderOrder,z:g,group:x},e[t]=b):(b.id=p.id,b.object=p,b.geometry=f,b.material=m,b.program=w.program||o,b.groupOrder=y,b.renderOrder=p.renderOrder,b.z=g,b.group=x),t++,b}function c(p,f,m,y,g,x){const b=l(p,f,m,y,g,x);m.transmission>0?r.push(b):m.transparent===!0?i.push(b):s.push(b)}function u(p,f,m,y,g,x){const b=l(p,f,m,y,g,x);m.transmission>0?r.unshift(b):m.transparent===!0?i.unshift(b):s.unshift(b)}function h(p,f){s.length>1&&s.sort(p||JV),r.length>1&&r.sort(f||dy),i.length>1&&i.sort(f||dy)}function d(){for(let p=t,f=e.length;p<f;p++){const m=e[p];if(m.id===null)break;m.id=null,m.object=null,m.geometry=null,m.material=null,m.program=null,m.group=null}}return{opaque:s,transmissive:r,transparent:i,init:a,push:c,unshift:u,finish:d,sort:h}}function QV(n){let e=new WeakMap;function t(r,i){let o;return e.has(r)===!1?(o=new py(n),e.set(r,[o])):i>=e.get(r).length?(o=new py(n),e.get(r).push(o)):o=e.get(r)[i],o}function s(){e=new WeakMap}return{get:t,dispose:s}}function eG(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new L,color:new Le};break;case"SpotLight":t={position:new L,direction:new L,color:new Le,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new L,color:new Le,distance:0,decay:0};break;case"HemisphereLight":t={direction:new L,skyColor:new Le,groundColor:new Le};break;case"RectAreaLight":t={color:new Le,position:new L,halfWidth:new L,halfHeight:new L};break}return n[e.id]=t,t}}}function tG(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new pe};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new pe};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new pe,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let nG=0;function sG(n,e){return(e.castShadow?1:0)-(n.castShadow?1:0)}function rG(n,e){const t=new eG,s=tG(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let u=0;u<9;u++)r.probe.push(new L);const i=new L,o=new ze,a=new ze;function l(u,h){let d=0,p=0,f=0;for(let $=0;$<9;$++)r.probe[$].set(0,0,0);let m=0,y=0,g=0,x=0,b=0,w=0,C=0,M=0;u.sort(sG);const E=h!==!0?Math.PI:1;for(let $=0,B=u.length;$<B;$++){const R=u[$],K=R.color,F=R.intensity,z=R.distance,V=R.shadow&&R.shadow.map?R.shadow.map.texture:null;if(R.isAmbientLight)d+=K.r*F*E,p+=K.g*F*E,f+=K.b*F*E;else if(R.isLightProbe)for(let H=0;H<9;H++)r.probe[H].addScaledVector(R.sh.coefficients[H],F);else if(R.isDirectionalLight){const H=t.get(R);if(H.color.copy(R.color).multiplyScalar(R.intensity*E),R.castShadow){const j=R.shadow,ae=s.get(R);ae.shadowBias=j.bias,ae.shadowNormalBias=j.normalBias,ae.shadowRadius=j.radius,ae.shadowMapSize=j.mapSize,r.directionalShadow[m]=ae,r.directionalShadowMap[m]=V,r.directionalShadowMatrix[m]=R.shadow.matrix,w++}r.directional[m]=H,m++}else if(R.isSpotLight){const H=t.get(R);if(H.position.setFromMatrixPosition(R.matrixWorld),H.color.copy(K).multiplyScalar(F*E),H.distance=z,H.coneCos=Math.cos(R.angle),H.penumbraCos=Math.cos(R.angle*(1-R.penumbra)),H.decay=R.decay,R.castShadow){const j=R.shadow,ae=s.get(R);ae.shadowBias=j.bias,ae.shadowNormalBias=j.normalBias,ae.shadowRadius=j.radius,ae.shadowMapSize=j.mapSize,r.spotShadow[g]=ae,r.spotShadowMap[g]=V,r.spotShadowMatrix[g]=R.shadow.matrix,M++}r.spot[g]=H,g++}else if(R.isRectAreaLight){const H=t.get(R);H.color.copy(K).multiplyScalar(F),H.halfWidth.set(R.width*.5,0,0),H.halfHeight.set(0,R.height*.5,0),r.rectArea[x]=H,x++}else if(R.isPointLight){const H=t.get(R);if(H.color.copy(R.color).multiplyScalar(R.intensity*E),H.distance=R.distance,H.decay=R.decay,R.castShadow){const j=R.shadow,ae=s.get(R);ae.shadowBias=j.bias,ae.shadowNormalBias=j.normalBias,ae.shadowRadius=j.radius,ae.shadowMapSize=j.mapSize,ae.shadowCameraNear=j.camera.near,ae.shadowCameraFar=j.camera.far,r.pointShadow[y]=ae,r.pointShadowMap[y]=V,r.pointShadowMatrix[y]=R.shadow.matrix,C++}r.point[y]=H,y++}else if(R.isHemisphereLight){const H=t.get(R);H.skyColor.copy(R.color).multiplyScalar(F*E),H.groundColor.copy(R.groundColor).multiplyScalar(F*E),r.hemi[b]=H,b++}}x>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Ce.LTC_FLOAT_1,r.rectAreaLTC2=Ce.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(r.rectAreaLTC1=Ce.LTC_HALF_1,r.rectAreaLTC2=Ce.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),r.ambient[0]=d,r.ambient[1]=p,r.ambient[2]=f;const A=r.hash;(A.directionalLength!==m||A.pointLength!==y||A.spotLength!==g||A.rectAreaLength!==x||A.hemiLength!==b||A.numDirectionalShadows!==w||A.numPointShadows!==C||A.numSpotShadows!==M)&&(r.directional.length=m,r.spot.length=g,r.rectArea.length=x,r.point.length=y,r.hemi.length=b,r.directionalShadow.length=w,r.directionalShadowMap.length=w,r.pointShadow.length=C,r.pointShadowMap.length=C,r.spotShadow.length=M,r.spotShadowMap.length=M,r.directionalShadowMatrix.length=w,r.pointShadowMatrix.length=C,r.spotShadowMatrix.length=M,A.directionalLength=m,A.pointLength=y,A.spotLength=g,A.rectAreaLength=x,A.hemiLength=b,A.numDirectionalShadows=w,A.numPointShadows=C,A.numSpotShadows=M,r.version=nG++)}function c(u,h){let d=0,p=0,f=0,m=0,y=0;const g=h.matrixWorldInverse;for(let x=0,b=u.length;x<b;x++){const w=u[x];if(w.isDirectionalLight){const C=r.directional[d];C.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),C.direction.sub(i),C.direction.transformDirection(g),d++}else if(w.isSpotLight){const C=r.spot[f];C.position.setFromMatrixPosition(w.matrixWorld),C.position.applyMatrix4(g),C.direction.setFromMatrixPosition(w.matrixWorld),i.setFromMatrixPosition(w.target.matrixWorld),C.direction.sub(i),C.direction.transformDirection(g),f++}else if(w.isRectAreaLight){const C=r.rectArea[m];C.position.setFromMatrixPosition(w.matrixWorld),C.position.applyMatrix4(g),a.identity(),o.copy(w.matrixWorld),o.premultiply(g),a.extractRotation(o),C.halfWidth.set(w.width*.5,0,0),C.halfHeight.set(0,w.height*.5,0),C.halfWidth.applyMatrix4(a),C.halfHeight.applyMatrix4(a),m++}else if(w.isPointLight){const C=r.point[p];C.position.setFromMatrixPosition(w.matrixWorld),C.position.applyMatrix4(g),p++}else if(w.isHemisphereLight){const C=r.hemi[y];C.direction.setFromMatrixPosition(w.matrixWorld),C.direction.transformDirection(g),C.direction.normalize(),y++}}}return{setup:l,setupView:c,state:r}}function fy(n,e){const t=new rG(n,e),s=[],r=[];function i(){s.length=0,r.length=0}function o(h){s.push(h)}function a(h){r.push(h)}function l(h){t.setup(s,h)}function c(h){t.setupView(s,h)}return{init:i,state:{lightsArray:s,shadowsArray:r,lights:t},setupLights:l,setupLightsView:c,pushLight:o,pushShadow:a}}function iG(n,e){let t=new WeakMap;function s(i,o=0){let a;return t.has(i)===!1?(a=new fy(n,e),t.set(i,[a])):o>=t.get(i).length?(a=new fy(n,e),t.get(i).push(a)):a=t.get(i)[o],a}function r(){t=new WeakMap}return{get:s,dispose:r}}class my extends pn{constructor(e){super();this.type="MeshDepthMaterial",this.depthPacking=gO,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}my.prototype.isMeshDepthMaterial=!0;class gy extends pn{constructor(e){super();this.type="MeshDistanceMaterial",this.referencePosition=new L,this.nearDistance=1,this.farDistance=1e3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.fog=!1,this.setValues(e)}copy(e){return super.copy(e),this.referencePosition.copy(e.referencePosition),this.nearDistance=e.nearDistance,this.farDistance=e.farDistance,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}gy.prototype.isMeshDistanceMaterial=!0;const oG=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,aG=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function xy(n,e,t){let s=new gu;const r=new pe,i=new pe,o=new $t,a=new my({depthPacking:xO}),l=new gy,c={},u=t.maxTextureSize,h={0:un,1:Vo,2:Wi},d=new Ji({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new pe},radius:{value:4}},vertexShader:oG,fragmentShader:aG}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new Wt;f.setAttribute("position",new en(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const m=new fn(f,d),y=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=G4,this.render=function(w,C,M){if(y.enabled===!1||y.autoUpdate===!1&&y.needsUpdate===!1||w.length===0)return;const E=n.getRenderTarget(),A=n.getActiveCubeFace(),$=n.getActiveMipmapLevel(),B=n.state;B.setBlending(Jr),B.buffers.color.setClear(1,1,1,1),B.buffers.depth.setTest(!0),B.setScissorTest(!1);for(let R=0,K=w.length;R<K;R++){const F=w[R],z=F.shadow;if(z===void 0){console.warn("THREE.WebGLShadowMap:",F,"has no shadow.");continue}if(z.autoUpdate===!1&&z.needsUpdate===!1)continue;r.copy(z.mapSize);const V=z.getFrameExtents();if(r.multiply(V),i.copy(z.mapSize),(r.x>u||r.y>u)&&(r.x>u&&(i.x=Math.floor(u/V.x),r.x=i.x*V.x,z.mapSize.x=i.x),r.y>u&&(i.y=Math.floor(u/V.y),r.y=i.y*V.y,z.mapSize.y=i.y)),z.map===null&&!z.isPointLightShadow&&this.type===dl){const j={minFilter:Zn,magFilter:Zn,format:Ln};z.map=new Ts(r.x,r.y,j),z.map.texture.name=F.name+".shadowMap",z.mapPass=new Ts(r.x,r.y,j),z.camera.updateProjectionMatrix()}if(z.map===null){const j={minFilter:hn,magFilter:hn,format:Ln};z.map=new Ts(r.x,r.y,j),z.map.texture.name=F.name+".shadowMap",z.camera.updateProjectionMatrix()}n.setRenderTarget(z.map),n.clear();const H=z.getViewportCount();for(let j=0;j<H;j++){const ae=z.getViewport(j);o.set(i.x*ae.x,i.y*ae.y,i.x*ae.z,i.y*ae.w),B.viewport(o),z.updateMatrices(F,j),s=z.getFrustum(),b(C,M,z.camera,F,this.type)}!z.isPointLightShadow&&this.type===dl&&g(z,M),z.needsUpdate=!1}y.needsUpdate=!1,n.setRenderTarget(E,A,$)};function g(w,C){const M=e.update(m);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,p.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,n.setRenderTarget(w.mapPass),n.clear(),n.renderBufferDirect(C,null,M,d,m,null),p.uniforms.shadow_pass.value=w.mapPass.texture,p.uniforms.resolution.value=w.mapSize,p.uniforms.radius.value=w.radius,n.setRenderTarget(w.map),n.clear(),n.renderBufferDirect(C,null,M,p,m,null)}function x(w,C,M,E,A,$,B){let R=null;const K=E.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(K!==void 0?R=K:R=E.isPointLight===!0?l:a,n.localClippingEnabled&&M.clipShadows===!0&&M.clippingPlanes.length!==0||M.displacementMap&&M.displacementScale!==0||M.alphaMap&&M.alphaTest>0){const F=R.uuid,z=M.uuid;let V=c[F];V===void 0&&(V={},c[F]=V);let H=V[z];H===void 0&&(H=R.clone(),V[z]=H),R=H}return R.visible=M.visible,R.wireframe=M.wireframe,B===dl?R.side=M.shadowSide!==null?M.shadowSide:M.side:R.side=M.shadowSide!==null?M.shadowSide:h[M.side],R.alphaMap=M.alphaMap,R.alphaTest=M.alphaTest,R.clipShadows=M.clipShadows,R.clippingPlanes=M.clippingPlanes,R.clipIntersection=M.clipIntersection,R.displacementMap=M.displacementMap,R.displacementScale=M.displacementScale,R.displacementBias=M.displacementBias,R.wireframeLinewidth=M.wireframeLinewidth,R.linewidth=M.linewidth,E.isPointLight===!0&&R.isMeshDistanceMaterial===!0&&(R.referencePosition.setFromMatrixPosition(E.matrixWorld),R.nearDistance=A,R.farDistance=$),R}function b(w,C,M,E,A){if(w.visible===!1)return;if(w.layers.test(C.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&A===dl)&&(!w.frustumCulled||s.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(M.matrixWorldInverse,w.matrixWorld);const R=e.update(w),K=w.material;if(Array.isArray(K)){const F=R.groups;for(let z=0,V=F.length;z<V;z++){const H=F[z],j=K[H.materialIndex];if(j&&j.visible){const ae=x(w,R,j,E,M.near,M.far,A);n.renderBufferDirect(M,null,R,ae,w,H)}}}else if(K.visible){const F=x(w,R,K,E,M.near,M.far,A);n.renderBufferDirect(M,null,R,F,w,null)}}const B=w.children;for(let R=0,K=B.length;R<K;R++)b(B[R],C,M,E,A)}}function lG(n,e,t){const s=t.isWebGL2;function r(){let U=!1;const me=new $t;let ue=null;const Ee=new $t(0,0,0,0);return{setMask:function(_e){ue!==_e&&!U&&(n.colorMask(_e,_e,_e,_e),ue=_e)},setLocked:function(_e){U=_e},setClear:function(_e,$e,Oe,qe,Ht){Ht===!0&&(_e*=qe,$e*=qe,Oe*=qe),me.set(_e,$e,Oe,qe),Ee.equals(me)===!1&&(n.clearColor(_e,$e,Oe,qe),Ee.copy(me))},reset:function(){U=!1,ue=null,Ee.set(-1,0,0,0)}}}function i(){let U=!1,me=null,ue=null,Ee=null;return{setTest:function(_e){_e?we(2929):Pe(2929)},setMask:function(_e){me!==_e&&!U&&(n.depthMask(_e),me=_e)},setFunc:function(_e){if(ue!==_e){if(_e)switch(_e){case iF:n.depthFunc(512);break;case oF:n.depthFunc(519);break;case aF:n.depthFunc(513);break;case Od:n.depthFunc(515);break;case lF:n.depthFunc(514);break;case cF:n.depthFunc(518);break;case uF:n.depthFunc(516);break;case hF:n.depthFunc(517);break;default:n.depthFunc(515)}else n.depthFunc(515);ue=_e}},setLocked:function(_e){U=_e},setClear:function(_e){Ee!==_e&&(n.clearDepth(_e),Ee=_e)},reset:function(){U=!1,me=null,ue=null,Ee=null}}}function o(){let U=!1,me=null,ue=null,Ee=null,_e=null,$e=null,Oe=null,qe=null,Ht=null;return{setTest:function(Xe){U||(Xe?we(2960):Pe(2960))},setMask:function(Xe){me!==Xe&&!U&&(n.stencilMask(Xe),me=Xe)},setFunc:function(Xe,Cn,Hn){(ue!==Xe||Ee!==Cn||_e!==Hn)&&(n.stencilFunc(Xe,Cn,Hn),ue=Xe,Ee=Cn,_e=Hn)},setOp:function(Xe,Cn,Hn){($e!==Xe||Oe!==Cn||qe!==Hn)&&(n.stencilOp(Xe,Cn,Hn),$e=Xe,Oe=Cn,qe=Hn)},setLocked:function(Xe){U=Xe},setClear:function(Xe){Ht!==Xe&&(n.clearStencil(Xe),Ht=Xe)},reset:function(){U=!1,me=null,ue=null,Ee=null,_e=null,$e=null,Oe=null,qe=null,Ht=null}}}const a=new r,l=new i,c=new o;let u={},h={},d=null,p=!1,f=null,m=null,y=null,g=null,x=null,b=null,w=null,C=!1,M=null,E=null,A=null,$=null,B=null;const R=n.getParameter(35661);let K=!1,F=0;const z=n.getParameter(7938);z.indexOf("WebGL")!==-1?(F=parseFloat(/^WebGL (\d)/.exec(z)[1]),K=F>=1):z.indexOf("OpenGL ES")!==-1&&(F=parseFloat(/^OpenGL ES (\d)/.exec(z)[1]),K=F>=2);let V=null,H={};const j=n.getParameter(3088),ae=n.getParameter(2978),fe=new $t().fromArray(j),Q=new $t().fromArray(ae);function te(U,me,ue){const Ee=new Uint8Array(4),_e=n.createTexture();n.bindTexture(U,_e),n.texParameteri(U,10241,9728),n.texParameteri(U,10240,9728);for(let $e=0;$e<ue;$e++)n.texImage2D(me+$e,0,6408,1,1,0,6408,5121,Ee);return _e}const Te={};Te[3553]=te(3553,3553,1),Te[34067]=te(34067,34069,6),a.setClear(0,0,0,1),l.setClear(1),c.setClear(0),we(2929),l.setFunc(Od),nt(!1),ne(V4),we(2884),Ae(Jr);function we(U){u[U]!==!0&&(n.enable(U),u[U]=!0)}function Pe(U){u[U]!==!1&&(n.disable(U),u[U]=!1)}function it(U,me){return h[U]!==me?(n.bindFramebuffer(U,me),h[U]=me,s&&(U===36009&&(h[36160]=me),U===36160&&(h[36009]=me)),!0):!1}function le(U){return d!==U?(n.useProgram(U),d=U,!0):!1}const et={[Go]:32774,[q$]:32778,[K$]:32779};if(s)et[q4]=32775,et[K4]=32776;else{const U=e.get("EXT_blend_minmax");U!==null&&(et[q4]=U.MIN_EXT,et[K4]=U.MAX_EXT)}const Ge={[Y$]:0,[Z$]:1,[J$]:768,[Y4]:770,[rF]:776,[nF]:774,[eF]:772,[Q$]:769,[Z4]:771,[sF]:775,[tF]:773};function Ae(U,me,ue,Ee,_e,$e,Oe,qe){if(U===Jr){p===!0&&(Pe(3042),p=!1);return}if(p===!1&&(we(3042),p=!0),U!==j$){if(U!==f||qe!==C){if((m!==Go||x!==Go)&&(n.blendEquation(32774),m=Go,x=Go),qe)switch(U){case pl:n.blendFuncSeparate(1,771,1,771);break;case H4:n.blendFunc(1,1);break;case X4:n.blendFuncSeparate(0,0,769,771);break;case j4:n.blendFuncSeparate(0,768,0,770);break;default:console.error("THREE.WebGLState: Invalid blending: ",U);break}else switch(U){case pl:n.blendFuncSeparate(770,771,1,771);break;case H4:n.blendFunc(770,1);break;case X4:n.blendFunc(0,769);break;case j4:n.blendFunc(0,768);break;default:console.error("THREE.WebGLState: Invalid blending: ",U);break}y=null,g=null,b=null,w=null,f=U,C=qe}return}_e=_e||me,$e=$e||ue,Oe=Oe||Ee,(me!==m||_e!==x)&&(n.blendEquationSeparate(et[me],et[_e]),m=me,x=_e),(ue!==y||Ee!==g||$e!==b||Oe!==w)&&(n.blendFuncSeparate(Ge[ue],Ge[Ee],Ge[$e],Ge[Oe]),y=ue,g=Ee,b=$e,w=Oe),f=U,C=null}function Fe(U,me){U.side===Wi?Pe(2884):we(2884);let ue=U.side===un;me&&(ue=!ue),nt(ue),U.blending===pl&&U.transparent===!1?Ae(Jr):Ae(U.blending,U.blendEquation,U.blendSrc,U.blendDst,U.blendEquationAlpha,U.blendSrcAlpha,U.blendDstAlpha,U.premultipliedAlpha),l.setFunc(U.depthFunc),l.setTest(U.depthTest),l.setMask(U.depthWrite),a.setMask(U.colorWrite);const Ee=U.stencilWrite;c.setTest(Ee),Ee&&(c.setMask(U.stencilWriteMask),c.setFunc(U.stencilFunc,U.stencilRef,U.stencilFuncMask),c.setOp(U.stencilFail,U.stencilZFail,U.stencilZPass)),ye(U.polygonOffset,U.polygonOffsetFactor,U.polygonOffsetUnits),U.alphaToCoverage===!0?we(32926):Pe(32926)}function nt(U){M!==U&&(U?n.frontFace(2304):n.frontFace(2305),M=U)}function ne(U){U!==W$?(we(2884),U!==E&&(U===V4?n.cullFace(1029):U===H$?n.cullFace(1028):n.cullFace(1032))):Pe(2884),E=U}function he(U){U!==A&&(K&&n.lineWidth(U),A=U)}function ye(U,me,ue){U?(we(32823),($!==me||B!==ue)&&(n.polygonOffset(me,ue),$=me,B=ue)):Pe(32823)}function Re(U){U?we(3089):Pe(3089)}function ve(U){U===void 0&&(U=33984+R-1),V!==U&&(n.activeTexture(U),V=U)}function We(U,me){V===null&&ve();let ue=H[V];ue===void 0&&(ue={type:void 0,texture:void 0},H[V]=ue),(ue.type!==U||ue.texture!==me)&&(n.bindTexture(U,me||Te[U]),ue.type=U,ue.texture=me)}function Ue(){const U=H[V];U!==void 0&&U.type!==void 0&&(n.bindTexture(U.type,null),U.type=void 0,U.texture=void 0)}function st(){try{n.compressedTexImage2D.apply(n,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function At(){try{n.texSubImage2D.apply(n,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function k(){try{n.texStorage2D.apply(n,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function N(){try{n.texImage2D.apply(n,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function ce(){try{n.texImage3D.apply(n,arguments)}catch(U){console.error("THREE.WebGLState:",U)}}function oe(U){fe.equals(U)===!1&&(n.scissor(U.x,U.y,U.z,U.w),fe.copy(U))}function ke(U){Q.equals(U)===!1&&(n.viewport(U.x,U.y,U.z,U.w),Q.copy(U))}function Ie(){n.disable(3042),n.disable(2884),n.disable(2929),n.disable(32823),n.disable(3089),n.disable(2960),n.disable(32926),n.blendEquation(32774),n.blendFunc(1,0),n.blendFuncSeparate(1,0,1,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(513),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(519,0,4294967295),n.stencilOp(7680,7680,7680),n.clearStencil(0),n.cullFace(1029),n.frontFace(2305),n.polygonOffset(0,0),n.activeTexture(33984),n.bindFramebuffer(36160,null),s===!0&&(n.bindFramebuffer(36009,null),n.bindFramebuffer(36008,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),u={},V=null,H={},h={},d=null,p=!1,f=null,m=null,y=null,g=null,x=null,b=null,w=null,C=!1,M=null,E=null,A=null,$=null,B=null,fe.set(0,0,n.canvas.width,n.canvas.height),Q.set(0,0,n.canvas.width,n.canvas.height),a.reset(),l.reset(),c.reset()}return{buffers:{color:a,depth:l,stencil:c},enable:we,disable:Pe,bindFramebuffer:it,useProgram:le,setBlending:Ae,setMaterial:Fe,setFlipSided:nt,setCullFace:ne,setLineWidth:he,setPolygonOffset:ye,setScissorTest:Re,activeTexture:ve,bindTexture:We,unbindTexture:Ue,compressedTexImage2D:st,texImage2D:N,texImage3D:ce,texStorage2D:k,texSubImage2D:At,scissor:oe,viewport:ke,reset:Ie}}function cG(n,e,t,s,r,i,o){const a=r.isWebGL2,l=r.maxTextures,c=r.maxCubemapSize,u=r.maxTextureSize,h=r.maxSamples,p=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):void 0,f=new WeakMap;let m,y=!1;try{y=typeof OffscreenCanvas!="undefined"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function g(k,N){return y?new OffscreenCanvas(k,N):Zc("canvas")}function x(k,N,ce,oe){let ke=1;if((k.width>oe||k.height>oe)&&(ke=oe/Math.max(k.width,k.height)),ke<1||N===!0)if(typeof HTMLImageElement!="undefined"&&k instanceof HTMLImageElement||typeof HTMLCanvasElement!="undefined"&&k instanceof HTMLCanvasElement||typeof ImageBitmap!="undefined"&&k instanceof ImageBitmap){const Ie=N?xx:Math.floor,U=Ie(ke*k.width),me=Ie(ke*k.height);m===void 0&&(m=g(U,me));const ue=ce?g(U,me):m;return ue.width=U,ue.height=me,ue.getContext("2d").drawImage(k,0,0,U,me),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+k.width+"x"+k.height+") to ("+U+"x"+me+")."),ue}else return"data"in k&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+k.width+"x"+k.height+")."),k;return k}function b(k){return Yd(k.width)&&Yd(k.height)}function w(k){return a?!1:k.wrapS!==Yn||k.wrapT!==Yn||k.minFilter!==hn&&k.minFilter!==Zn}function C(k,N){return k.generateMipmaps&&N&&k.minFilter!==hn&&k.minFilter!==Zn}function M(k){n.generateMipmap(k)}function E(k,N,ce){if(a===!1)return N;if(k!==null){if(n[k]!==void 0)return n[k];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+k+"'")}let oe=N;return N===6403&&(ce===5126&&(oe=33326),ce===5131&&(oe=33325),ce===5121&&(oe=33321)),N===6407&&(ce===5126&&(oe=34837),ce===5131&&(oe=34843),ce===5121&&(oe=32849)),N===6408&&(ce===5126&&(oe=34836),ce===5131&&(oe=34842),ce===5121&&(oe=32856)),(oe===33325||oe===33326||oe===34842||oe===34836)&&e.get("EXT_color_buffer_float"),oe}function A(k,N,ce){return C(k,ce)===!0?Math.log2(Math.max(N.width,N.height))+1:k.mipmaps.length>0?k.mipmaps.length:1}function $(k){return k===hn||k===Vd||k===Gd?9728:9729}function B(k){const N=k.target;N.removeEventListener("dispose",B),K(N),N.isVideoTexture&&f.delete(N),o.memory.textures--}function R(k){const N=k.target;N.removeEventListener("dispose",R),F(N)}function K(k){const N=s.get(k);N.__webglInit!==void 0&&(n.deleteTexture(N.__webglTexture),s.remove(k))}function F(k){const N=k.texture,ce=s.get(k),oe=s.get(N);if(!!k){if(oe.__webglTexture!==void 0&&(n.deleteTexture(oe.__webglTexture),o.memory.textures--),k.depthTexture&&k.depthTexture.dispose(),k.isWebGLCubeRenderTarget)for(let ke=0;ke<6;ke++)n.deleteFramebuffer(ce.__webglFramebuffer[ke]),ce.__webglDepthbuffer&&n.deleteRenderbuffer(ce.__webglDepthbuffer[ke]);else n.deleteFramebuffer(ce.__webglFramebuffer),ce.__webglDepthbuffer&&n.deleteRenderbuffer(ce.__webglDepthbuffer),ce.__webglMultisampledFramebuffer&&n.deleteFramebuffer(ce.__webglMultisampledFramebuffer),ce.__webglColorRenderbuffer&&n.deleteRenderbuffer(ce.__webglColorRenderbuffer),ce.__webglDepthRenderbuffer&&n.deleteRenderbuffer(ce.__webglDepthRenderbuffer);if(k.isWebGLMultipleRenderTargets)for(let ke=0,Ie=N.length;ke<Ie;ke++){const U=s.get(N[ke]);U.__webglTexture&&(n.deleteTexture(U.__webglTexture),o.memory.textures--),s.remove(N[ke])}s.remove(N),s.remove(k)}}let z=0;function V(){z=0}function H(){const k=z;return k>=l&&console.warn("THREE.WebGLTextures: Trying to use "+k+" texture units while this GPU supports only "+l),z+=1,k}function j(k,N){const ce=s.get(k);if(k.isVideoTexture&&ve(k),k.version>0&&ce.__version!==k.version){const oe=k.image;if(oe===void 0)console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined");else if(oe.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{it(ce,k,N);return}}t.activeTexture(33984+N),t.bindTexture(3553,ce.__webglTexture)}function ae(k,N){const ce=s.get(k);if(k.version>0&&ce.__version!==k.version){it(ce,k,N);return}t.activeTexture(33984+N),t.bindTexture(35866,ce.__webglTexture)}function fe(k,N){const ce=s.get(k);if(k.version>0&&ce.__version!==k.version){it(ce,k,N);return}t.activeTexture(33984+N),t.bindTexture(32879,ce.__webglTexture)}function Q(k,N){const ce=s.get(k);if(k.version>0&&ce.__version!==k.version){le(ce,k,N);return}t.activeTexture(33984+N),t.bindTexture(34067,ce.__webglTexture)}const te={[Wo]:10497,[Yn]:33071,[Xc]:33648},Te={[hn]:9728,[Vd]:9984,[Gd]:9986,[Zn]:9729,[Q4]:9985,[Ho]:9987};function we(k,N,ce){if(ce?(n.texParameteri(k,10242,te[N.wrapS]),n.texParameteri(k,10243,te[N.wrapT]),(k===32879||k===35866)&&n.texParameteri(k,32882,te[N.wrapR]),n.texParameteri(k,10240,Te[N.magFilter]),n.texParameteri(k,10241,Te[N.minFilter])):(n.texParameteri(k,10242,33071),n.texParameteri(k,10243,33071),(k===32879||k===35866)&&n.texParameteri(k,32882,33071),(N.wrapS!==Yn||N.wrapT!==Yn)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(k,10240,$(N.magFilter)),n.texParameteri(k,10241,$(N.minFilter)),N.minFilter!==hn&&N.minFilter!==Zn&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),e.has("EXT_texture_filter_anisotropic")===!0){const oe=e.get("EXT_texture_filter_anisotropic");if(N.type===Er&&e.has("OES_texture_float_linear")===!1||a===!1&&N.type===Xo&&e.has("OES_texture_half_float_linear")===!1)return;(N.anisotropy>1||s.get(N).__currentAnisotropy)&&(n.texParameterf(k,oe.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(N.anisotropy,r.getMaxAnisotropy())),s.get(N).__currentAnisotropy=N.anisotropy)}}function Pe(k,N){k.__webglInit===void 0&&(k.__webglInit=!0,N.addEventListener("dispose",B),k.__webglTexture=n.createTexture(),o.memory.textures++)}function it(k,N,ce){let oe=3553;N.isDataTexture2DArray&&(oe=35866),N.isDataTexture3D&&(oe=32879),Pe(k,N),t.activeTexture(33984+ce),t.bindTexture(oe,k.__webglTexture),n.pixelStorei(37440,N.flipY),n.pixelStorei(37441,N.premultiplyAlpha),n.pixelStorei(3317,N.unpackAlignment),n.pixelStorei(37443,0);const ke=w(N)&&b(N.image)===!1,Ie=x(N.image,ke,!1,u),U=b(Ie)||a,me=i.convert(N.format);let ue=i.convert(N.type),Ee=E(N.internalFormat,me,ue,N.encoding);we(oe,N,U);let _e;const $e=N.mipmaps;if(N.isDepthTexture)Ee=6402,a?N.type===Er?Ee=36012:N.type===jc?Ee=33190:N.type===jo?Ee=35056:Ee=33189:N.type===Er&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),N.format===Xi&&Ee===6402&&N.type!==gl&&N.type!==jc&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),N.type=gl,ue=i.convert(N.type)),N.format===qo&&Ee===6402&&(Ee=34041,N.type!==jo&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),N.type=jo,ue=i.convert(N.type))),t.texImage2D(3553,0,Ee,Ie.width,Ie.height,0,me,ue,null);else if(N.isDataTexture)if($e.length>0&&U){for(let Oe=0,qe=$e.length;Oe<qe;Oe++)_e=$e[Oe],t.texImage2D(3553,Oe,Ee,_e.width,_e.height,0,me,ue,_e.data);N.generateMipmaps=!1}else t.texImage2D(3553,0,Ee,Ie.width,Ie.height,0,me,ue,Ie.data);else if(N.isCompressedTexture)for(let Oe=0,qe=$e.length;Oe<qe;Oe++)_e=$e[Oe],N.format!==Ln&&N.format!==ei?me!==null?t.compressedTexImage2D(3553,Oe,Ee,_e.width,_e.height,0,_e.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):t.texImage2D(3553,Oe,Ee,_e.width,_e.height,0,me,ue,_e.data);else if(N.isDataTexture2DArray)t.texImage3D(35866,0,Ee,Ie.width,Ie.height,Ie.depth,0,me,ue,Ie.data);else if(N.isDataTexture3D)t.texImage3D(32879,0,Ee,Ie.width,Ie.height,Ie.depth,0,me,ue,Ie.data);else{const Oe=A(N,Ie,U),qe=a&&N.isVideoTexture!==!0,Ht=k.__version===void 0;if($e.length>0&&U){qe&&Ht&&t.texStorage2D(3553,Oe,Ee,$e[0].width,$e[0].height);for(let Xe=0,Cn=$e.length;Xe<Cn;Xe++)_e=$e[Xe],qe?t.texSubImage2D(3553,Xe,0,0,me,ue,_e):t.texImage2D(3553,Xe,Ee,me,ue,_e);N.generateMipmaps=!1}else qe?(Ht&&t.texStorage2D(3553,Oe,Ee,Ie.width,Ie.height),t.texSubImage2D(3553,0,0,0,me,ue,Ie)):t.texImage2D(3553,0,Ee,me,ue,Ie)}C(N,U)&&M(oe),k.__version=N.version,N.onUpdate&&N.onUpdate(N)}function le(k,N,ce){if(N.image.length!==6)return;Pe(k,N),t.activeTexture(33984+ce),t.bindTexture(34067,k.__webglTexture),n.pixelStorei(37440,N.flipY),n.pixelStorei(37441,N.premultiplyAlpha),n.pixelStorei(3317,N.unpackAlignment),n.pixelStorei(37443,0);const oe=N&&(N.isCompressedTexture||N.image[0].isCompressedTexture),ke=N.image[0]&&N.image[0].isDataTexture,Ie=[];for(let Oe=0;Oe<6;Oe++)!oe&&!ke?Ie[Oe]=x(N.image[Oe],!1,!0,c):Ie[Oe]=ke?N.image[Oe].image:N.image[Oe];const U=Ie[0],me=b(U)||a,ue=i.convert(N.format),Ee=i.convert(N.type),_e=E(N.internalFormat,ue,Ee,N.encoding);we(34067,N,me);let $e;if(oe)for(let Oe=0;Oe<6;Oe++){$e=Ie[Oe].mipmaps;for(let qe=0;qe<$e.length;qe++){const Ht=$e[qe];N.format!==Ln&&N.format!==ei?ue!==null?t.compressedTexImage2D(34069+Oe,qe,_e,Ht.width,Ht.height,0,Ht.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):t.texImage2D(34069+Oe,qe,_e,Ht.width,Ht.height,0,ue,Ee,Ht.data)}}else{$e=N.mipmaps;for(let Oe=0;Oe<6;Oe++)if(ke){t.texImage2D(34069+Oe,0,_e,Ie[Oe].width,Ie[Oe].height,0,ue,Ee,Ie[Oe].data);for(let qe=0;qe<$e.length;qe++){const Xe=$e[qe].image[Oe].image;t.texImage2D(34069+Oe,qe+1,_e,Xe.width,Xe.height,0,ue,Ee,Xe.data)}}else{t.texImage2D(34069+Oe,0,_e,ue,Ee,Ie[Oe]);for(let qe=0;qe<$e.length;qe++){const Ht=$e[qe];t.texImage2D(34069+Oe,qe+1,_e,ue,Ee,Ht.image[Oe])}}}C(N,me)&&M(34067),k.__version=N.version,N.onUpdate&&N.onUpdate(N)}function et(k,N,ce,oe,ke){const Ie=i.convert(ce.format),U=i.convert(ce.type),me=E(ce.internalFormat,Ie,U,ce.encoding);s.get(N).__hasExternalTextures||(ke===32879||ke===35866?t.texImage3D(ke,0,me,N.width,N.height,N.depth,0,Ie,U,null):t.texImage2D(ke,0,me,N.width,N.height,0,Ie,U,null)),t.bindFramebuffer(36160,k),N.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,oe,ke,s.get(ce).__webglTexture,0,Re(N)):n.framebufferTexture2D(36160,oe,ke,s.get(ce).__webglTexture,0),t.bindFramebuffer(36160,null)}function Ge(k,N,ce){if(n.bindRenderbuffer(36161,k),N.depthBuffer&&!N.stencilBuffer){let oe=33189;if(ce||N.useRenderToTexture){const ke=N.depthTexture;ke&&ke.isDepthTexture&&(ke.type===Er?oe=36012:ke.type===jc&&(oe=33190));const Ie=Re(N);N.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,Ie,oe,N.width,N.height):n.renderbufferStorageMultisample(36161,Ie,oe,N.width,N.height)}else n.renderbufferStorage(36161,oe,N.width,N.height);n.framebufferRenderbuffer(36160,36096,36161,k)}else if(N.depthBuffer&&N.stencilBuffer){const oe=Re(N);ce&&N.useRenderbuffer?n.renderbufferStorageMultisample(36161,oe,35056,N.width,N.height):N.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,oe,35056,N.width,N.height):n.renderbufferStorage(36161,34041,N.width,N.height),n.framebufferRenderbuffer(36160,33306,36161,k)}else{const oe=N.isWebGLMultipleRenderTargets===!0?N.texture[0]:N.texture,ke=i.convert(oe.format),Ie=i.convert(oe.type),U=E(oe.internalFormat,ke,Ie,oe.encoding),me=Re(N);ce&&N.useRenderbuffer?n.renderbufferStorageMultisample(36161,me,U,N.width,N.height):N.useRenderToTexture?p.renderbufferStorageMultisampleEXT(36161,me,U,N.width,N.height):n.renderbufferStorage(36161,U,N.width,N.height)}n.bindRenderbuffer(36161,null)}function Ae(k,N){if(N&&N.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(36160,k),!(N.depthTexture&&N.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(N.depthTexture).__webglTexture||N.depthTexture.image.width!==N.width||N.depthTexture.image.height!==N.height)&&(N.depthTexture.image.width=N.width,N.depthTexture.image.height=N.height,N.depthTexture.needsUpdate=!0),j(N.depthTexture,0);const oe=s.get(N.depthTexture).__webglTexture,ke=Re(N);if(N.depthTexture.format===Xi)N.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,36096,3553,oe,0,ke):n.framebufferTexture2D(36160,36096,3553,oe,0);else if(N.depthTexture.format===qo)N.useRenderToTexture?p.framebufferTexture2DMultisampleEXT(36160,33306,3553,oe,0,ke):n.framebufferTexture2D(36160,33306,3553,oe,0);else throw new Error("Unknown depthTexture format")}function Fe(k){const N=s.get(k),ce=k.isWebGLCubeRenderTarget===!0;if(k.depthTexture&&!N.__autoAllocateDepthBuffer){if(ce)throw new Error("target.depthTexture not supported in Cube render targets");Ae(N.__webglFramebuffer,k)}else if(ce){N.__webglDepthbuffer=[];for(let oe=0;oe<6;oe++)t.bindFramebuffer(36160,N.__webglFramebuffer[oe]),N.__webglDepthbuffer[oe]=n.createRenderbuffer(),Ge(N.__webglDepthbuffer[oe],k,!1)}else t.bindFramebuffer(36160,N.__webglFramebuffer),N.__webglDepthbuffer=n.createRenderbuffer(),Ge(N.__webglDepthbuffer,k,!1);t.bindFramebuffer(36160,null)}function nt(k,N,ce){const oe=s.get(k);N!==void 0&&et(oe.__webglFramebuffer,k,k.texture,36064,3553),ce!==void 0&&Fe(k)}function ne(k){const N=k.texture,ce=s.get(k),oe=s.get(N);k.addEventListener("dispose",R),k.isWebGLMultipleRenderTargets!==!0&&(oe.__webglTexture===void 0&&(oe.__webglTexture=n.createTexture()),oe.__version=N.version,o.memory.textures++);const ke=k.isWebGLCubeRenderTarget===!0,Ie=k.isWebGLMultipleRenderTargets===!0,U=N.isDataTexture3D||N.isDataTexture2DArray,me=b(k)||a;if(a&&N.format===ei&&(N.type===Er||N.type===Xo)&&(N.format=Ln,console.warn("THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.")),ke){ce.__webglFramebuffer=[];for(let ue=0;ue<6;ue++)ce.__webglFramebuffer[ue]=n.createFramebuffer()}else if(ce.__webglFramebuffer=n.createFramebuffer(),Ie)if(r.drawBuffers){const ue=k.texture;for(let Ee=0,_e=ue.length;Ee<_e;Ee++){const $e=s.get(ue[Ee]);$e.__webglTexture===void 0&&($e.__webglTexture=n.createTexture(),o.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");else if(k.useRenderbuffer)if(a){ce.__webglMultisampledFramebuffer=n.createFramebuffer(),ce.__webglColorRenderbuffer=n.createRenderbuffer(),n.bindRenderbuffer(36161,ce.__webglColorRenderbuffer);const ue=i.convert(N.format),Ee=i.convert(N.type),_e=E(N.internalFormat,ue,Ee,N.encoding),$e=Re(k);n.renderbufferStorageMultisample(36161,$e,_e,k.width,k.height),t.bindFramebuffer(36160,ce.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(36160,36064,36161,ce.__webglColorRenderbuffer),n.bindRenderbuffer(36161,null),k.depthBuffer&&(ce.__webglDepthRenderbuffer=n.createRenderbuffer(),Ge(ce.__webglDepthRenderbuffer,k,!0)),t.bindFramebuffer(36160,null)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");if(ke){t.bindTexture(34067,oe.__webglTexture),we(34067,N,me);for(let ue=0;ue<6;ue++)et(ce.__webglFramebuffer[ue],k,N,36064,34069+ue);C(N,me)&&M(34067),t.unbindTexture()}else if(Ie){const ue=k.texture;for(let Ee=0,_e=ue.length;Ee<_e;Ee++){const $e=ue[Ee],Oe=s.get($e);t.bindTexture(3553,Oe.__webglTexture),we(3553,$e,me),et(ce.__webglFramebuffer,k,$e,36064+Ee,3553),C($e,me)&&M(3553)}t.unbindTexture()}else{let ue=3553;U&&(a?ue=N.isDataTexture3D?32879:35866:console.warn("THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.")),t.bindTexture(ue,oe.__webglTexture),we(ue,N,me),et(ce.__webglFramebuffer,k,N,36064,ue),C(N,me)&&M(ue),t.unbindTexture()}k.depthBuffer&&Fe(k)}function he(k){const N=b(k)||a,ce=k.isWebGLMultipleRenderTargets===!0?k.texture:[k.texture];for(let oe=0,ke=ce.length;oe<ke;oe++){const Ie=ce[oe];if(C(Ie,N)){const U=k.isWebGLCubeRenderTarget?34067:3553,me=s.get(Ie).__webglTexture;t.bindTexture(U,me),M(U),t.unbindTexture()}}}function ye(k){if(k.useRenderbuffer)if(a){const N=k.width,ce=k.height;let oe=16384;const ke=[36064],Ie=k.stencilBuffer?33306:36096;k.depthBuffer&&ke.push(Ie),k.ignoreDepthForMultisampleCopy||(k.depthBuffer&&(oe|=256),k.stencilBuffer&&(oe|=1024));const U=s.get(k);t.bindFramebuffer(36008,U.__webglMultisampledFramebuffer),t.bindFramebuffer(36009,U.__webglFramebuffer),k.ignoreDepthForMultisampleCopy&&(n.invalidateFramebuffer(36008,[Ie]),n.invalidateFramebuffer(36009,[Ie])),n.blitFramebuffer(0,0,N,ce,0,0,N,ce,oe,9728),n.invalidateFramebuffer(36008,ke),t.bindFramebuffer(36008,null),t.bindFramebuffer(36009,U.__webglMultisampledFramebuffer)}else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")}function Re(k){return a&&(k.useRenderbuffer||k.useRenderToTexture)?Math.min(h,k.samples):0}function ve(k){const N=o.render.frame;f.get(k)!==N&&(f.set(k,N),k.update())}let We=!1,Ue=!1;function st(k,N){k&&k.isWebGLRenderTarget&&(We===!1&&(console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."),We=!0),k=k.texture),j(k,N)}function At(k,N){k&&k.isWebGLCubeRenderTarget&&(Ue===!1&&(console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."),Ue=!0),k=k.texture),Q(k,N)}this.allocateTextureUnit=H,this.resetTextureUnits=V,this.setTexture2D=j,this.setTexture2DArray=ae,this.setTexture3D=fe,this.setTextureCube=Q,this.rebindTextures=nt,this.setupRenderTarget=ne,this.updateRenderTargetMipmap=he,this.updateMultisampleRenderTarget=ye,this.setupDepthRenderbuffer=Fe,this.setupFrameBufferTexture=et,this.safeSetTexture2D=st,this.safeSetTextureCube=At}function uG(n,e,t){const s=t.isWebGL2;function r(i){let o;if(i===Qr)return 5121;if(i===_F)return 32819;if(i===SF)return 32820;if(i===TF)return 33635;if(i===vF)return 5120;if(i===bF)return 5122;if(i===gl)return 5123;if(i===wF)return 5124;if(i===jc)return 5125;if(i===Er)return 5126;if(i===Xo)return s?5131:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(i===EF)return 6406;if(i===ei)return 6407;if(i===Ln)return 6408;if(i===CF)return 6409;if(i===MF)return 6410;if(i===Xi)return 6402;if(i===qo)return 34041;if(i===RF)return 6403;if(i===IF)return 36244;if(i===NF)return 33319;if(i===LF)return 33320;if(i===PF)return 36248;if(i===DF)return 36249;if(i===ex||i===tx||i===nx||i===sx)if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(i===ex)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(i===tx)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(i===nx)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(i===sx)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(i===rx||i===ix||i===ox||i===ax)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(i===rx)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(i===ix)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(i===ox)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(i===ax)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(i===kF)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if((i===lx||i===cx)&&(o=e.get("WEBGL_compressed_texture_etc"),o!==null)){if(i===lx)return o.COMPRESSED_RGB8_ETC2;if(i===cx)return o.COMPRESSED_RGBA8_ETC2_EAC}if(i===$F||i===FF||i===OF||i===BF||i===zF||i===UF||i===VF||i===GF||i===WF||i===HF||i===XF||i===jF||i===qF||i===KF||i===ZF||i===JF||i===QF||i===eO||i===tO||i===nO||i===sO||i===rO||i===iO||i===oO||i===aO||i===lO||i===cO||i===uO)return o=e.get("WEBGL_compressed_texture_astc"),o!==null?i:null;if(i===YF)return o=e.get("EXT_texture_compression_bptc"),o!==null?i:null;if(i===jo)return s?34042:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null)}return{convert:r}}class yy extends Gn{constructor(e=[]){super();this.cameras=e}}yy.prototype.isArrayCamera=!0;class hi extends Ye{constructor(){super();this.type="Group"}}hi.prototype.isGroup=!0;const hG={type:"move"};class Ip{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new hi,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new hi,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new L,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new L),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new hi,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new L,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new L),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let r=null,i=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred")if(a!==null&&(r=t.getPose(e.targetRaySpace,s),r!==null&&(a.matrix.fromArray(r.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),r.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(r.linearVelocity)):a.hasLinearVelocity=!1,r.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(r.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(hG))),c&&e.hand){o=!0;for(const m of e.hand.values()){const y=t.getJointPose(m,s);if(c.joints[m.jointName]===void 0){const x=new hi;x.matrixAutoUpdate=!1,x.visible=!1,c.joints[m.jointName]=x,c.add(x)}const g=c.joints[m.jointName];y!==null&&(g.matrix.fromArray(y.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.jointRadius=y.radius),g.visible=y!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),p=.02,f=.005;c.inputState.pinching&&d>p+f?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=p-f&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(i=t.getPose(e.gripSpace,s),i!==null&&(l.matrix.fromArray(i.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),i.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(i.linearVelocity)):l.hasLinearVelocity=!1,i.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(i.angularVelocity)):l.hasAngularVelocity=!1));return a!==null&&(a.visible=r!==null),l!==null&&(l.visible=i!==null),c!==null&&(c.visible=o!==null),this}}class Np extends dn{constructor(e,t,s,r,i,o,a,l,c,u){if(u=u!==void 0?u:Xi,u!==Xi&&u!==qo)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&u===Xi&&(s=gl),s===void 0&&u===qo&&(s=jo);super(null,r,i,o,a,l,u,s,c);this.image={width:e,height:t},this.magFilter=a!==void 0?a:hn,this.minFilter=l!==void 0?l:hn,this.flipY=!1,this.generateMipmaps=!1}}Np.prototype.isDepthTexture=!0;class dG extends qi{constructor(e,t){super();const s=this;let r=null,i=1,o=null,a="local-floor";const l=e.extensions.has("WEBGL_multisampled_render_to_texture");let c=null,u=null,h=null,d=null,p=!1,f=null;const m=t.getContextAttributes();let y=null,g=null;const x=[],b=new Map,w=new Gn;w.layers.enable(1),w.viewport=new $t;const C=new Gn;C.layers.enable(2),C.viewport=new $t;const M=[w,C],E=new yy;E.layers.enable(1),E.layers.enable(2);let A=null,$=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(Q){let te=x[Q];return te===void 0&&(te=new Ip,x[Q]=te),te.getTargetRaySpace()},this.getControllerGrip=function(Q){let te=x[Q];return te===void 0&&(te=new Ip,x[Q]=te),te.getGripSpace()},this.getHand=function(Q){let te=x[Q];return te===void 0&&(te=new Ip,x[Q]=te),te.getHandSpace()};function B(Q){const te=b.get(Q.inputSource);te&&te.dispatchEvent({type:Q.type,data:Q.inputSource})}function R(){b.forEach(function(Q,te){Q.disconnect(te)}),b.clear(),A=null,$=null,e.setRenderTarget(y),d=null,h=null,u=null,r=null,g=null,fe.stop(),s.isPresenting=!1,s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(Q){i=Q,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(Q){a=Q,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return o},this.getBaseLayer=function(){return h!==null?h:d},this.getBinding=function(){return u},this.getFrame=function(){return f},this.getSession=function(){return r},this.setSession=async function(Q){if(r=Q,r!==null){if(y=e.getRenderTarget(),r.addEventListener("select",B),r.addEventListener("selectstart",B),r.addEventListener("selectend",B),r.addEventListener("squeeze",B),r.addEventListener("squeezestart",B),r.addEventListener("squeezeend",B),r.addEventListener("end",R),r.addEventListener("inputsourceschange",K),m.xrCompatible!==!0&&await t.makeXRCompatible(),r.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const te={antialias:r.renderState.layers===void 0?m.antialias:!0,alpha:m.alpha,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:i};d=new XRWebGLLayer(r,t,te),r.updateRenderState({baseLayer:d}),g=new Ts(d.framebufferWidth,d.framebufferHeight)}else{p=m.antialias;let te=null,Te=null,we=null;m.depth&&(we=m.stencil?35056:33189,te=m.stencil?qo:Xi,Te=m.stencil?jo:gl);const Pe={colorFormat:m.alpha||p?32856:32849,depthFormat:we,scaleFactor:i};u=new XRWebGLBinding(r,t),h=u.createProjectionLayer(Pe),r.updateRenderState({layers:[h]}),p?g=new Jd(h.textureWidth,h.textureHeight,{format:Ln,type:Qr,depthTexture:new Np(h.textureWidth,h.textureHeight,Te,void 0,void 0,void 0,void 0,void 0,void 0,te),stencilBuffer:m.stencil,ignoreDepth:h.ignoreDepthValues,useRenderToTexture:l}):g=new Ts(h.textureWidth,h.textureHeight,{format:m.alpha?Ln:ei,type:Qr,depthTexture:new Np(h.textureWidth,h.textureHeight,Te,void 0,void 0,void 0,void 0,void 0,void 0,te),stencilBuffer:m.stencil,ignoreDepth:h.ignoreDepthValues})}this.setFoveation(0),o=await r.requestReferenceSpace(a),fe.setContext(r),fe.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}};function K(Q){const te=r.inputSources;for(let Te=0;Te<x.length;Te++)b.set(te[Te],x[Te]);for(let Te=0;Te<Q.removed.length;Te++){const we=Q.removed[Te],Pe=b.get(we);Pe&&(Pe.dispatchEvent({type:"disconnected",data:we}),b.delete(we))}for(let Te=0;Te<Q.added.length;Te++){const we=Q.added[Te],Pe=b.get(we);Pe&&Pe.dispatchEvent({type:"connected",data:we})}}const F=new L,z=new L;function V(Q,te,Te){F.setFromMatrixPosition(te.matrixWorld),z.setFromMatrixPosition(Te.matrixWorld);const we=F.distanceTo(z),Pe=te.projectionMatrix.elements,it=Te.projectionMatrix.elements,le=Pe[14]/(Pe[10]-1),et=Pe[14]/(Pe[10]+1),Ge=(Pe[9]+1)/Pe[5],Ae=(Pe[9]-1)/Pe[5],Fe=(Pe[8]-1)/Pe[0],nt=(it[8]+1)/it[0],ne=le*Fe,he=le*nt,ye=we/(-Fe+nt),Re=ye*-Fe;te.matrixWorld.decompose(Q.position,Q.quaternion,Q.scale),Q.translateX(Re),Q.translateZ(ye),Q.matrixWorld.compose(Q.position,Q.quaternion,Q.scale),Q.matrixWorldInverse.copy(Q.matrixWorld).invert();const ve=le+ye,We=et+ye,Ue=ne-Re,st=he+(we-Re),At=Ge*et/We*ve,k=Ae*et/We*ve;Q.projectionMatrix.makePerspective(Ue,st,At,k,ve,We)}function H(Q,te){te===null?Q.matrixWorld.copy(Q.matrix):Q.matrixWorld.multiplyMatrices(te.matrixWorld,Q.matrix),Q.matrixWorldInverse.copy(Q.matrixWorld).invert()}this.updateCamera=function(Q){if(r===null)return;E.near=C.near=w.near=Q.near,E.far=C.far=w.far=Q.far,(A!==E.near||$!==E.far)&&(r.updateRenderState({depthNear:E.near,depthFar:E.far}),A=E.near,$=E.far);const te=Q.parent,Te=E.cameras;H(E,te);for(let Pe=0;Pe<Te.length;Pe++)H(Te[Pe],te);E.matrixWorld.decompose(E.position,E.quaternion,E.scale),Q.position.copy(E.position),Q.quaternion.copy(E.quaternion),Q.scale.copy(E.scale),Q.matrix.copy(E.matrix),Q.matrixWorld.copy(E.matrixWorld);const we=Q.children;for(let Pe=0,it=we.length;Pe<it;Pe++)we[Pe].updateMatrixWorld(!0);Te.length===2?V(E,w,C):E.projectionMatrix.copy(w.projectionMatrix)},this.getCamera=function(){return E},this.getFoveation=function(){if(h!==null)return h.fixedFoveation;if(d!==null)return d.fixedFoveation},this.setFoveation=function(Q){h!==null&&(h.fixedFoveation=Q),d!==null&&d.fixedFoveation!==void 0&&(d.fixedFoveation=Q)};let j=null;function ae(Q,te){if(c=te.getViewerPose(o),f=te,c!==null){const we=c.views;d!==null&&(e.setRenderTargetFramebuffer(g,d.framebuffer),e.setRenderTarget(g));let Pe=!1;we.length!==E.cameras.length&&(E.cameras.length=0,Pe=!0);for(let it=0;it<we.length;it++){const le=we[it];let et=null;if(d!==null)et=d.getViewport(le);else{const Ae=u.getViewSubImage(h,le);et=Ae.viewport,it===0&&(e.setRenderTargetTextures(g,Ae.colorTexture,h.ignoreDepthValues?void 0:Ae.depthStencilTexture),e.setRenderTarget(g))}const Ge=M[it];Ge.matrix.fromArray(le.transform.matrix),Ge.projectionMatrix.fromArray(le.projectionMatrix),Ge.viewport.set(et.x,et.y,et.width,et.height),it===0&&E.matrix.copy(Ge.matrix),Pe===!0&&E.cameras.push(Ge)}}const Te=r.inputSources;for(let we=0;we<x.length;we++){const Pe=x[we],it=Te[we];Pe.update(it,te,o)}j&&j(Q,te),f=null}const fe=new kx;fe.setAnimationLoop(ae),this.setAnimationLoop=function(Q){j=Q},this.dispose=function(){}}}function pG(n){function e(g,x){g.fogColor.value.copy(x.color),x.isFog?(g.fogNear.value=x.near,g.fogFar.value=x.far):x.isFogExp2&&(g.fogDensity.value=x.density)}function t(g,x,b,w,C){x.isMeshBasicMaterial?s(g,x):x.isMeshLambertMaterial?(s(g,x),l(g,x)):x.isMeshToonMaterial?(s(g,x),u(g,x)):x.isMeshPhongMaterial?(s(g,x),c(g,x)):x.isMeshStandardMaterial?(s(g,x),x.isMeshPhysicalMaterial?d(g,x,C):h(g,x)):x.isMeshMatcapMaterial?(s(g,x),p(g,x)):x.isMeshDepthMaterial?(s(g,x),f(g,x)):x.isMeshDistanceMaterial?(s(g,x),m(g,x)):x.isMeshNormalMaterial?(s(g,x),y(g,x)):x.isLineBasicMaterial?(r(g,x),x.isLineDashedMaterial&&i(g,x)):x.isPointsMaterial?o(g,x,b,w):x.isSpriteMaterial?a(g,x):x.isShadowMaterial?(g.color.value.copy(x.color),g.opacity.value=x.opacity):x.isShaderMaterial&&(x.uniformsNeedUpdate=!1)}function s(g,x){g.opacity.value=x.opacity,x.color&&g.diffuse.value.copy(x.color),x.emissive&&g.emissive.value.copy(x.emissive).multiplyScalar(x.emissiveIntensity),x.map&&(g.map.value=x.map),x.alphaMap&&(g.alphaMap.value=x.alphaMap),x.specularMap&&(g.specularMap.value=x.specularMap),x.alphaTest>0&&(g.alphaTest.value=x.alphaTest);const b=n.get(x).envMap;b&&(g.envMap.value=b,g.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,g.reflectivity.value=x.reflectivity,g.ior.value=x.ior,g.refractionRatio.value=x.refractionRatio),x.lightMap&&(g.lightMap.value=x.lightMap,g.lightMapIntensity.value=x.lightMapIntensity),x.aoMap&&(g.aoMap.value=x.aoMap,g.aoMapIntensity.value=x.aoMapIntensity);let w;x.map?w=x.map:x.specularMap?w=x.specularMap:x.displacementMap?w=x.displacementMap:x.normalMap?w=x.normalMap:x.bumpMap?w=x.bumpMap:x.roughnessMap?w=x.roughnessMap:x.metalnessMap?w=x.metalnessMap:x.alphaMap?w=x.alphaMap:x.emissiveMap?w=x.emissiveMap:x.clearcoatMap?w=x.clearcoatMap:x.clearcoatNormalMap?w=x.clearcoatNormalMap:x.clearcoatRoughnessMap?w=x.clearcoatRoughnessMap:x.specularIntensityMap?w=x.specularIntensityMap:x.specularColorMap?w=x.specularColorMap:x.transmissionMap?w=x.transmissionMap:x.thicknessMap?w=x.thicknessMap:x.sheenColorMap?w=x.sheenColorMap:x.sheenRoughnessMap&&(w=x.sheenRoughnessMap),w!==void 0&&(w.isWebGLRenderTarget&&(w=w.texture),w.matrixAutoUpdate===!0&&w.updateMatrix(),g.uvTransform.value.copy(w.matrix));let C;x.aoMap?C=x.aoMap:x.lightMap&&(C=x.lightMap),C!==void 0&&(C.isWebGLRenderTarget&&(C=C.texture),C.matrixAutoUpdate===!0&&C.updateMatrix(),g.uv2Transform.value.copy(C.matrix))}function r(g,x){g.diffuse.value.copy(x.color),g.opacity.value=x.opacity}function i(g,x){g.dashSize.value=x.dashSize,g.totalSize.value=x.dashSize+x.gapSize,g.scale.value=x.scale}function o(g,x,b,w){g.diffuse.value.copy(x.color),g.opacity.value=x.opacity,g.size.value=x.size*b,g.scale.value=w*.5,x.map&&(g.map.value=x.map),x.alphaMap&&(g.alphaMap.value=x.alphaMap),x.alphaTest>0&&(g.alphaTest.value=x.alphaTest);let C;x.map?C=x.map:x.alphaMap&&(C=x.alphaMap),C!==void 0&&(C.matrixAutoUpdate===!0&&C.updateMatrix(),g.uvTransform.value.copy(C.matrix))}function a(g,x){g.diffuse.value.copy(x.color),g.opacity.value=x.opacity,g.rotation.value=x.rotation,x.map&&(g.map.value=x.map),x.alphaMap&&(g.alphaMap.value=x.alphaMap),x.alphaTest>0&&(g.alphaTest.value=x.alphaTest);let b;x.map?b=x.map:x.alphaMap&&(b=x.alphaMap),b!==void 0&&(b.matrixAutoUpdate===!0&&b.updateMatrix(),g.uvTransform.value.copy(b.matrix))}function l(g,x){x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap)}function c(g,x){g.specular.value.copy(x.specular),g.shininess.value=Math.max(x.shininess,1e-4),x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===un&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===un&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function u(g,x){x.gradientMap&&(g.gradientMap.value=x.gradientMap),x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===un&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===un&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function h(g,x){g.roughness.value=x.roughness,g.metalness.value=x.metalness,x.roughnessMap&&(g.roughnessMap.value=x.roughnessMap),x.metalnessMap&&(g.metalnessMap.value=x.metalnessMap),x.emissiveMap&&(g.emissiveMap.value=x.emissiveMap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===un&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===un&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias),n.get(x).envMap&&(g.envMapIntensity.value=x.envMapIntensity)}function d(g,x,b){h(g,x),g.ior.value=x.ior,x.sheen>0&&(g.sheenColor.value.copy(x.sheenColor).multiplyScalar(x.sheen),g.sheenRoughness.value=x.sheenRoughness,x.sheenColorMap&&(g.sheenColorMap.value=x.sheenColorMap),x.sheenRoughnessMap&&(g.sheenRoughnessMap.value=x.sheenRoughnessMap)),x.clearcoat>0&&(g.clearcoat.value=x.clearcoat,g.clearcoatRoughness.value=x.clearcoatRoughness,x.clearcoatMap&&(g.clearcoatMap.value=x.clearcoatMap),x.clearcoatRoughnessMap&&(g.clearcoatRoughnessMap.value=x.clearcoatRoughnessMap),x.clearcoatNormalMap&&(g.clearcoatNormalScale.value.copy(x.clearcoatNormalScale),g.clearcoatNormalMap.value=x.clearcoatNormalMap,x.side===un&&g.clearcoatNormalScale.value.negate())),x.transmission>0&&(g.transmission.value=x.transmission,g.transmissionSamplerMap.value=b.texture,g.transmissionSamplerSize.value.set(b.width,b.height),x.transmissionMap&&(g.transmissionMap.value=x.transmissionMap),g.thickness.value=x.thickness,x.thicknessMap&&(g.thicknessMap.value=x.thicknessMap),g.attenuationDistance.value=x.attenuationDistance,g.attenuationColor.value.copy(x.attenuationColor)),g.specularIntensity.value=x.specularIntensity,g.specularColor.value.copy(x.specularColor),x.specularIntensityMap&&(g.specularIntensityMap.value=x.specularIntensityMap),x.specularColorMap&&(g.specularColorMap.value=x.specularColorMap)}function p(g,x){x.matcap&&(g.matcap.value=x.matcap),x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===un&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===un&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function f(g,x){x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}function m(g,x){x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias),g.referencePosition.value.copy(x.referencePosition),g.nearDistance.value=x.nearDistance,g.farDistance.value=x.farDistance}function y(g,x){x.bumpMap&&(g.bumpMap.value=x.bumpMap,g.bumpScale.value=x.bumpScale,x.side===un&&(g.bumpScale.value*=-1)),x.normalMap&&(g.normalMap.value=x.normalMap,g.normalScale.value.copy(x.normalScale),x.side===un&&g.normalScale.value.negate()),x.displacementMap&&(g.displacementMap.value=x.displacementMap,g.displacementScale.value=x.displacementScale,g.displacementBias.value=x.displacementBias)}return{refreshFogUniforms:e,refreshMaterialUniforms:t}}function fG(){const n=Zc("canvas");return n.style.display="block",n}function Lt(n={}){const e=n.canvas!==void 0?n.canvas:fG(),t=n.context!==void 0?n.context:null,s=n.alpha!==void 0?n.alpha:!1,r=n.depth!==void 0?n.depth:!0,i=n.stencil!==void 0?n.stencil:!0,o=n.antialias!==void 0?n.antialias:!1,a=n.premultipliedAlpha!==void 0?n.premultipliedAlpha:!0,l=n.preserveDrawingBuffer!==void 0?n.preserveDrawingBuffer:!1,c=n.powerPreference!==void 0?n.powerPreference:"default",u=n.failIfMajorPerformanceCaveat!==void 0?n.failIfMajorPerformanceCaveat:!1;let h=null,d=null;const p=[],f=[];this.domElement=e,this.debug={checkShaderErrors:!0},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this.gammaFactor=2,this.outputEncoding=Jn,this.physicallyCorrectLights=!1,this.toneMapping=Hi,this.toneMappingExposure=1;const m=this;let y=!1,g=0,x=0,b=null,w=-1,C=null;const M=new $t,E=new $t;let A=null,$=e.width,B=e.height,R=1,K=null,F=null;const z=new $t(0,0,$,B),V=new $t(0,0,$,B);let H=!1;const j=[],ae=new gu;let fe=!1,Q=!1,te=null;const Te=new ze,we=new L,Pe={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function it(){return b===null?R:1}let le=t;function et(I,Y){for(let Z=0;Z<I.length;Z++){const J=I[Z],ie=e.getContext(J,Y);if(ie!==null)return ie}return null}try{const I={alpha:s,depth:r,stencil:i,antialias:o,premultipliedAlpha:a,preserveDrawingBuffer:l,powerPreference:c,failIfMajorPerformanceCaveat:u};if("setAttribute"in e&&e.setAttribute("data-engine",`three.js r${Fd}`),e.addEventListener("webglcontextlost",Oe,!1),e.addEventListener("webglcontextrestored",qe,!1),le===null){const Y=["webgl2","webgl","experimental-webgl"];if(m.isWebGL1Renderer===!0&&Y.shift(),le=et(Y,I),le===null)throw et(Y)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}le.getShaderPrecisionFormat===void 0&&(le.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(I){throw console.error("THREE.WebGLRenderer: "+I.message),I}let Ge,Ae,Fe,nt,ne,he,ye,Re,ve,We,Ue,st,At,k,N,ce,oe,ke,Ie,U,me,ue,Ee;function _e(){Ge=new FU(le),Ae=new RU(le,Ge,n),Ge.init(Ae),ue=new uG(le,Ge,Ae),Fe=new lG(le,Ge,Ae),j[0]=1029,nt=new zU(le),ne=new ZV,he=new cG(le,Ge,Fe,ne,Ae,ue,nt),ye=new NU(m),Re=new $U(m),ve=new QO(le,Ae),Ee=new MU(le,Ge,ve,Ae),We=new OU(le,ve,nt,Ee),Ue=new WU(le,We,ve,nt),Ie=new GU(le,Ae,he),ce=new IU(ne),st=new YV(m,ye,Re,Ge,Ae,Ee,ce),At=new pG(ne),k=new QV(ne),N=new iG(Ge,Ae),ke=new CU(m,ye,Fe,Ue,a),oe=new xy(m,Ue,Ae),U=new AU(le,Ge,nt,Ae),me=new BU(le,Ge,nt,Ae),nt.programs=st.programs,m.capabilities=Ae,m.extensions=Ge,m.properties=ne,m.renderLists=k,m.shadowMap=oe,m.state=Fe,m.info=nt}_e();const $e=new dG(m,le);this.xr=$e,this.getContext=function(){return le},this.getContextAttributes=function(){return le.getContextAttributes()},this.forceContextLoss=function(){const I=Ge.get("WEBGL_lose_context");I&&I.loseContext()},this.forceContextRestore=function(){const I=Ge.get("WEBGL_lose_context");I&&I.restoreContext()},this.getPixelRatio=function(){return R},this.setPixelRatio=function(I){I!==void 0&&(R=I,this.setSize($,B,!1))},this.getSize=function(I){return I.set($,B)},this.setSize=function(I,Y,Z){if($e.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}$=I,B=Y,e.width=Math.floor(I*R),e.height=Math.floor(Y*R),Z!==!1&&(e.style.width=I+"px",e.style.height=Y+"px"),this.setViewport(0,0,I,Y)},this.getDrawingBufferSize=function(I){return I.set($*R,B*R).floor()},this.setDrawingBufferSize=function(I,Y,Z){$=I,B=Y,R=Z,e.width=Math.floor(I*Z),e.height=Math.floor(Y*Z),this.setViewport(0,0,I,Y)},this.getCurrentViewport=function(I){return I.copy(M)},this.getViewport=function(I){return I.copy(z)},this.setViewport=function(I,Y,Z,J){I.isVector4?z.set(I.x,I.y,I.z,I.w):z.set(I,Y,Z,J),Fe.viewport(M.copy(z).multiplyScalar(R).floor())},this.getScissor=function(I){return I.copy(V)},this.setScissor=function(I,Y,Z,J){I.isVector4?V.set(I.x,I.y,I.z,I.w):V.set(I,Y,Z,J),Fe.scissor(E.copy(V).multiplyScalar(R).floor())},this.getScissorTest=function(){return H},this.setScissorTest=function(I){Fe.setScissorTest(H=I)},this.setOpaqueSort=function(I){K=I},this.setTransparentSort=function(I){F=I},this.getClearColor=function(I){return I.copy(ke.getClearColor())},this.setClearColor=function(){ke.setClearColor.apply(ke,arguments)},this.getClearAlpha=function(){return ke.getClearAlpha()},this.setClearAlpha=function(){ke.setClearAlpha.apply(ke,arguments)},this.clear=function(I,Y,Z){let J=0;(I===void 0||I)&&(J|=16384),(Y===void 0||Y)&&(J|=256),(Z===void 0||Z)&&(J|=1024),le.clear(J)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){e.removeEventListener("webglcontextlost",Oe,!1),e.removeEventListener("webglcontextrestored",qe,!1),k.dispose(),N.dispose(),ne.dispose(),ye.dispose(),Re.dispose(),Ue.dispose(),Ee.dispose(),$e.dispose(),$e.removeEventListener("sessionstart",yi),$e.removeEventListener("sessionend",Pa),te&&(te.dispose(),te=null),Fn.stop()};function Oe(I){I.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),y=!0}function qe(){console.log("THREE.WebGLRenderer: Context Restored."),y=!1;const I=nt.autoReset,Y=oe.enabled,Z=oe.autoUpdate,J=oe.needsUpdate,ie=oe.type;_e(),nt.autoReset=I,oe.enabled=Y,oe.autoUpdate=Z,oe.needsUpdate=J,oe.type=ie}function Ht(I){const Y=I.target;Y.removeEventListener("dispose",Ht),Xe(Y)}function Xe(I){Cn(I),ne.remove(I)}function Cn(I){const Y=ne.get(I).programs;Y!==void 0&&Y.forEach(function(Z){st.releaseProgram(Z)})}this.renderBufferDirect=function(I,Y,Z,J,ie,je){Y===null&&(Y=Pe);const He=ie.isMesh&&ie.matrixWorld.determinant()<0,Ze=Da(I,Y,Z,J,ie);Fe.setMaterial(J,He);let Ke=Z.index;const mt=Z.attributes.position;if(Ke===null){if(mt===void 0||mt.count===0)return}else if(Ke.count===0)return;let ot=1;J.wireframe===!0&&(Ke=We.getWireframeAttribute(Z),ot=2),Ee.setup(ie,J,Ze,Z,Ke);let gt,Ot=U;Ke!==null&&(gt=ve.get(Ke),Ot=me,Ot.setIndex(gt));const On=Ke!==null?Ke.count:mt.count,St=Z.drawRange.start*ot,vi=Z.drawRange.count*ot,Rt=je!==null?je.start*ot:0,fr=je!==null?je.count*ot:1/0,Us=Math.max(St,Rt),mr=Math.min(On,St+vi,Rt+fr)-1,Ms=Math.max(0,mr-Us+1);if(Ms!==0){if(ie.isMesh)J.wireframe===!0?(Fe.setLineWidth(J.wireframeLinewidth*it()),Ot.setMode(1)):Ot.setMode(4);else if(ie.isLine){let Bt=J.linewidth;Bt===void 0&&(Bt=1),Fe.setLineWidth(Bt*it()),ie.isLineSegments?Ot.setMode(1):ie.isLineLoop?Ot.setMode(2):Ot.setMode(3)}else ie.isPoints?Ot.setMode(0):ie.isSprite&&Ot.setMode(4);if(ie.isInstancedMesh)Ot.renderInstances(Us,Ms,ie.count);else if(Z.isInstancedBufferGeometry){const Bt=Math.min(Z.instanceCount,Z._maxInstanceCount);Ot.renderInstances(Us,Ms,Bt)}else Ot.render(Us,Ms)}},this.compile=function(I,Y){d=N.get(I),d.init(),f.push(d),I.traverseVisible(function(Z){Z.isLight&&Z.layers.test(Y.layers)&&(d.pushLight(Z),Z.castShadow&&d.pushShadow(Z))}),d.setupLights(m.physicallyCorrectLights),I.traverse(function(Z){const J=Z.material;if(J)if(Array.isArray(J))for(let ie=0;ie<J.length;ie++){const je=J[ie];ao(je,I,Z)}else ao(J,I,Z)}),f.pop(),d=null};let Hn=null;function Ft(I){Hn&&Hn(I)}function yi(){Fn.stop()}function Pa(){Fn.start()}const Fn=new kx;Fn.setAnimationLoop(Ft),typeof window!="undefined"&&Fn.setContext(window),this.setAnimationLoop=function(I){Hn=I,$e.setAnimationLoop(I),I===null?Fn.stop():Fn.start()},$e.addEventListener("sessionstart",yi),$e.addEventListener("sessionend",Pa),this.render=function(I,Y){if(Y!==void 0&&Y.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(y===!0)return;I.autoUpdate===!0&&I.updateMatrixWorld(),Y.parent===null&&Y.updateMatrixWorld(),$e.enabled===!0&&$e.isPresenting===!0&&($e.cameraAutoUpdate===!0&&$e.updateCamera(Y),Y=$e.getCamera()),I.isScene===!0&&I.onBeforeRender(m,I,Y,b),d=N.get(I,f.length),d.init(),f.push(d),Te.multiplyMatrices(Y.projectionMatrix,Y.matrixWorldInverse),ae.setFromProjectionMatrix(Te),Q=this.localClippingEnabled,fe=ce.init(this.clippingPlanes,Q,Y),h=k.get(I,p.length),h.init(),p.push(h),es(I,Y,0,m.sortObjects),h.finish(),m.sortObjects===!0&&h.sort(K,F),fe===!0&&ce.beginShadows();const Z=d.state.shadowsArray;if(oe.render(Z,I,Y),fe===!0&&ce.endShadows(),this.info.autoReset===!0&&this.info.reset(),ke.render(h,I),d.setupLights(m.physicallyCorrectLights),Y.isArrayCamera){const J=Y.cameras;for(let ie=0,je=J.length;ie<je;ie++){const He=J[ie];lt(h,I,He,He.viewport)}}else lt(h,I,Y);b!==null&&(he.updateMultisampleRenderTarget(b),he.updateRenderTargetMipmap(b)),I.isScene===!0&&I.onAfterRender(m,I,Y),Fe.buffers.depth.setTest(!0),Fe.buffers.depth.setMask(!0),Fe.buffers.color.setMask(!0),Fe.setPolygonOffset(!1),Ee.resetDefaultState(),w=-1,C=null,f.pop(),f.length>0?d=f[f.length-1]:d=null,p.pop(),p.length>0?h=p[p.length-1]:h=null};function es(I,Y,Z,J){if(I.visible===!1)return;if(I.layers.test(Y.layers)){if(I.isGroup)Z=I.renderOrder;else if(I.isLOD)I.autoUpdate===!0&&I.update(Y);else if(I.isLight)d.pushLight(I),I.castShadow&&d.pushShadow(I);else if(I.isSprite){if(!I.frustumCulled||ae.intersectsSprite(I)){J&&we.setFromMatrixPosition(I.matrixWorld).applyMatrix4(Te);const He=Ue.update(I),Ze=I.material;Ze.visible&&h.push(I,He,Ze,Z,we.z,null)}}else if((I.isMesh||I.isLine||I.isPoints)&&(I.isSkinnedMesh&&I.skeleton.frame!==nt.render.frame&&(I.skeleton.update(),I.skeleton.frame=nt.render.frame),!I.frustumCulled||ae.intersectsObject(I))){J&&we.setFromMatrixPosition(I.matrixWorld).applyMatrix4(Te);const He=Ue.update(I),Ze=I.material;if(Array.isArray(Ze)){const Ke=He.groups;for(let mt=0,ot=Ke.length;mt<ot;mt++){const gt=Ke[mt],Ot=Ze[gt.materialIndex];Ot&&Ot.visible&&h.push(I,He,Ot,Z,we.z,gt)}}else Ze.visible&&h.push(I,He,Ze,Z,we.z,null)}}const je=I.children;for(let He=0,Ze=je.length;He<Ze;He++)es(je[He],Y,Z,J)}function lt(I,Y,Z,J){const ie=I.opaque,je=I.transmissive,He=I.transparent;d.setupLightsView(Z),je.length>0&&Kl(ie,Y,Z),J&&Fe.viewport(M.copy(J)),ie.length>0&&dr(ie,Y,Z),je.length>0&&dr(je,Y,Z),He.length>0&&dr(He,Y,Z)}function Kl(I,Y,Z){if(te===null){const He=o===!0&&Ae.isWebGL2===!0?Jd:Ts;te=new He(1024,1024,{generateMipmaps:!0,type:ue.convert(Xo)!==null?Xo:Qr,minFilter:Ho,magFilter:hn,wrapS:Yn,wrapT:Yn,useRenderToTexture:Ge.has("WEBGL_multisampled_render_to_texture")})}const J=m.getRenderTarget();m.setRenderTarget(te),m.clear();const ie=m.toneMapping;m.toneMapping=Hi,dr(I,Y,Z),m.toneMapping=ie,he.updateMultisampleRenderTarget(te),he.updateRenderTargetMipmap(te),m.setRenderTarget(J)}function dr(I,Y,Z){const J=Y.isScene===!0?Y.overrideMaterial:null;for(let ie=0,je=I.length;ie<je;ie++){const He=I[ie],Ze=He.object,Ke=He.geometry,mt=J===null?He.material:J,ot=He.group;Ze.layers.test(Z.layers)&&Yl(Ze,Y,Z,Ke,mt,ot)}}function Yl(I,Y,Z,J,ie,je){I.onBeforeRender(m,Y,Z,J,ie,je),I.modelViewMatrix.multiplyMatrices(Z.matrixWorldInverse,I.matrixWorld),I.normalMatrix.getNormalMatrix(I.modelViewMatrix),ie.onBeforeRender(m,Y,Z,J,I,je),ie.transparent===!0&&ie.side===Wi?(ie.side=un,ie.needsUpdate=!0,m.renderBufferDirect(Z,Y,J,ie,I,je),ie.side=Vo,ie.needsUpdate=!0,m.renderBufferDirect(Z,Y,J,ie,I,je),ie.side=Wi):m.renderBufferDirect(Z,Y,J,ie,I,je),I.onAfterRender(m,Y,Z,J,ie,je)}function ao(I,Y,Z){Y.isScene!==!0&&(Y=Pe);const J=ne.get(I),ie=d.state.lights,je=d.state.shadowsArray,He=ie.state.version,Ze=st.getParameters(I,ie.state,je,Y,Z),Ke=st.getProgramCacheKey(Ze);let mt=J.programs;J.environment=I.isMeshStandardMaterial?Y.environment:null,J.fog=Y.fog,J.envMap=(I.isMeshStandardMaterial?Re:ye).get(I.envMap||J.environment),mt===void 0&&(I.addEventListener("dispose",Ht),mt=new Map,J.programs=mt);let ot=mt.get(Ke);if(ot!==void 0){if(J.currentProgram===ot&&J.lightsStateVersion===He)return Bs(I,Ze),ot}else Ze.uniforms=st.getUniforms(I),I.onBuild(Z,Ze,m),I.onBeforeCompile(Ze,m),ot=st.acquireProgram(Ze,Ke),mt.set(Ke,ot),J.uniforms=Ze.uniforms;const gt=J.uniforms;(!I.isShaderMaterial&&!I.isRawShaderMaterial||I.clipping===!0)&&(gt.clippingPlanes=ce.uniform),Bs(I,Ze),J.needsLights=pr(I),J.lightsStateVersion=He,J.needsLights&&(gt.ambientLightColor.value=ie.state.ambient,gt.lightProbe.value=ie.state.probe,gt.directionalLights.value=ie.state.directional,gt.directionalLightShadows.value=ie.state.directionalShadow,gt.spotLights.value=ie.state.spot,gt.spotLightShadows.value=ie.state.spotShadow,gt.rectAreaLights.value=ie.state.rectArea,gt.ltc_1.value=ie.state.rectAreaLTC1,gt.ltc_2.value=ie.state.rectAreaLTC2,gt.pointLights.value=ie.state.point,gt.pointLightShadows.value=ie.state.pointShadow,gt.hemisphereLights.value=ie.state.hemi,gt.directionalShadowMap.value=ie.state.directionalShadowMap,gt.directionalShadowMatrix.value=ie.state.directionalShadowMatrix,gt.spotShadowMap.value=ie.state.spotShadowMap,gt.spotShadowMatrix.value=ie.state.spotShadowMatrix,gt.pointShadowMap.value=ie.state.pointShadowMap,gt.pointShadowMatrix.value=ie.state.pointShadowMatrix);const Ot=ot.getUniforms(),On=ui.seqWithValue(Ot.seq,gt);return J.currentProgram=ot,J.uniformsList=On,ot}function Bs(I,Y){const Z=ne.get(I);Z.outputEncoding=Y.outputEncoding,Z.instancing=Y.instancing,Z.skinning=Y.skinning,Z.morphTargets=Y.morphTargets,Z.morphNormals=Y.morphNormals,Z.morphTargetsCount=Y.morphTargetsCount,Z.numClippingPlanes=Y.numClippingPlanes,Z.numIntersection=Y.numClipIntersection,Z.vertexAlphas=Y.vertexAlphas,Z.vertexTangents=Y.vertexTangents}function Da(I,Y,Z,J,ie){Y.isScene!==!0&&(Y=Pe),he.resetTextureUnits();const je=Y.fog,He=J.isMeshStandardMaterial?Y.environment:null,Ze=b===null?m.outputEncoding:b.texture.encoding,Ke=(J.isMeshStandardMaterial?Re:ye).get(J.envMap||He),mt=J.vertexColors===!0&&!!Z.attributes.color&&Z.attributes.color.itemSize===4,ot=!!J.normalMap&&!!Z.attributes.tangent,gt=!!Z.morphAttributes.position,Ot=!!Z.morphAttributes.normal,On=Z.morphAttributes.position?Z.morphAttributes.position.length:0,St=ne.get(J),vi=d.state.lights;if(fe===!0&&(Q===!0||I!==C)){const ts=I===C&&J.id===w;ce.setState(J,I,ts)}let Rt=!1;J.version===St.__version?(St.needsLights&&St.lightsStateVersion!==vi.state.version||St.outputEncoding!==Ze||ie.isInstancedMesh&&St.instancing===!1||!ie.isInstancedMesh&&St.instancing===!0||ie.isSkinnedMesh&&St.skinning===!1||!ie.isSkinnedMesh&&St.skinning===!0||St.envMap!==Ke||J.fog&&St.fog!==je||St.numClippingPlanes!==void 0&&(St.numClippingPlanes!==ce.numPlanes||St.numIntersection!==ce.numIntersection)||St.vertexAlphas!==mt||St.vertexTangents!==ot||St.morphTargets!==gt||St.morphNormals!==Ot||Ae.isWebGL2===!0&&St.morphTargetsCount!==On)&&(Rt=!0):(Rt=!0,St.__version=J.version);let fr=St.currentProgram;Rt===!0&&(fr=ao(J,Y,ie));let Us=!1,mr=!1,Ms=!1;const Bt=fr.getUniforms(),Fr=St.uniforms;if(Fe.useProgram(fr.program)&&(Us=!0,mr=!0,Ms=!0),J.id!==w&&(w=J.id,mr=!0),Us||C!==I){if(Bt.setValue(le,"projectionMatrix",I.projectionMatrix),Ae.logarithmicDepthBuffer&&Bt.setValue(le,"logDepthBufFC",2/(Math.log(I.far+1)/Math.LN2)),C!==I&&(C=I,mr=!0,Ms=!0),J.isShaderMaterial||J.isMeshPhongMaterial||J.isMeshToonMaterial||J.isMeshStandardMaterial||J.envMap){const ts=Bt.map.cameraPosition;ts!==void 0&&ts.setValue(le,we.setFromMatrixPosition(I.matrixWorld))}(J.isMeshPhongMaterial||J.isMeshToonMaterial||J.isMeshLambertMaterial||J.isMeshBasicMaterial||J.isMeshStandardMaterial||J.isShaderMaterial)&&Bt.setValue(le,"isOrthographic",I.isOrthographicCamera===!0),(J.isMeshPhongMaterial||J.isMeshToonMaterial||J.isMeshLambertMaterial||J.isMeshBasicMaterial||J.isMeshStandardMaterial||J.isShaderMaterial||J.isShadowMaterial||ie.isSkinnedMesh)&&Bt.setValue(le,"viewMatrix",I.matrixWorldInverse)}if(ie.isSkinnedMesh){Bt.setOptional(le,ie,"bindMatrix"),Bt.setOptional(le,ie,"bindMatrixInverse");const ts=ie.skeleton;ts&&(Ae.floatVertexTextures?(ts.boneTexture===null&&ts.computeBoneTexture(),Bt.setValue(le,"boneTexture",ts.boneTexture,he),Bt.setValue(le,"boneTextureSize",ts.boneTextureSize)):Bt.setOptional(le,ts,"boneMatrices"))}return!!Z&&(Z.morphAttributes.position!==void 0||Z.morphAttributes.normal!==void 0)&&Ie.update(ie,Z,J,fr),(mr||St.receiveShadow!==ie.receiveShadow)&&(St.receiveShadow=ie.receiveShadow,Bt.setValue(le,"receiveShadow",ie.receiveShadow)),mr&&(Bt.setValue(le,"toneMappingExposure",m.toneMappingExposure),St.needsLights&&zs(Fr,Ms),je&&J.fog&&At.refreshFogUniforms(Fr,je),At.refreshMaterialUniforms(Fr,J,R,B,te),ui.upload(le,St.uniformsList,Fr,he)),J.isShaderMaterial&&J.uniformsNeedUpdate===!0&&(ui.upload(le,St.uniformsList,Fr,he),J.uniformsNeedUpdate=!1),J.isSpriteMaterial&&Bt.setValue(le,"center",ie.center),Bt.setValue(le,"modelViewMatrix",ie.modelViewMatrix),Bt.setValue(le,"normalMatrix",ie.normalMatrix),Bt.setValue(le,"modelMatrix",ie.matrixWorld),fr}function zs(I,Y){I.ambientLightColor.needsUpdate=Y,I.lightProbe.needsUpdate=Y,I.directionalLights.needsUpdate=Y,I.directionalLightShadows.needsUpdate=Y,I.pointLights.needsUpdate=Y,I.pointLightShadows.needsUpdate=Y,I.spotLights.needsUpdate=Y,I.spotLightShadows.needsUpdate=Y,I.rectAreaLights.needsUpdate=Y,I.hemisphereLights.needsUpdate=Y}function pr(I){return I.isMeshLambertMaterial||I.isMeshToonMaterial||I.isMeshPhongMaterial||I.isMeshStandardMaterial||I.isShadowMaterial||I.isShaderMaterial&&I.lights===!0}this.getActiveCubeFace=function(){return g},this.getActiveMipmapLevel=function(){return x},this.getRenderTarget=function(){return b},this.setRenderTargetTextures=function(I,Y,Z){ne.get(I.texture).__webglTexture=Y,ne.get(I.depthTexture).__webglTexture=Z;const J=ne.get(I);J.__hasExternalTextures=!0,J.__hasExternalTextures&&(J.__autoAllocateDepthBuffer=Z===void 0,J.__autoAllocateDepthBuffer||I.useRenderToTexture&&(console.warn("render-to-texture extension was disabled because an external texture was provided"),I.useRenderToTexture=!1,I.useRenderbuffer=!0))},this.setRenderTargetFramebuffer=function(I,Y){const Z=ne.get(I);Z.__webglFramebuffer=Y,Z.__useDefaultFramebuffer=Y===void 0},this.setRenderTarget=function(I,Y=0,Z=0){b=I,g=Y,x=Z;let J=!0;if(I){const Ke=ne.get(I);Ke.__useDefaultFramebuffer!==void 0?(Fe.bindFramebuffer(36160,null),J=!1):Ke.__webglFramebuffer===void 0?he.setupRenderTarget(I):Ke.__hasExternalTextures&&he.rebindTextures(I,ne.get(I.texture).__webglTexture,ne.get(I.depthTexture).__webglTexture)}let ie=null,je=!1,He=!1;if(I){const Ke=I.texture;(Ke.isDataTexture3D||Ke.isDataTexture2DArray)&&(He=!0);const mt=ne.get(I).__webglFramebuffer;I.isWebGLCubeRenderTarget?(ie=mt[Y],je=!0):I.useRenderbuffer?ie=ne.get(I).__webglMultisampledFramebuffer:ie=mt,M.copy(I.viewport),E.copy(I.scissor),A=I.scissorTest}else M.copy(z).multiplyScalar(R).floor(),E.copy(V).multiplyScalar(R).floor(),A=H;if(Fe.bindFramebuffer(36160,ie)&&Ae.drawBuffers&&J){let Ke=!1;if(I)if(I.isWebGLMultipleRenderTargets){const mt=I.texture;if(j.length!==mt.length||j[0]!==36064){for(let ot=0,gt=mt.length;ot<gt;ot++)j[ot]=36064+ot;j.length=mt.length,Ke=!0}}else(j.length!==1||j[0]!==36064)&&(j[0]=36064,j.length=1,Ke=!0);else(j.length!==1||j[0]!==1029)&&(j[0]=1029,j.length=1,Ke=!0);Ke&&(Ae.isWebGL2?le.drawBuffers(j):Ge.get("WEBGL_draw_buffers").drawBuffersWEBGL(j))}if(Fe.viewport(M),Fe.scissor(E),Fe.setScissorTest(A),je){const Ke=ne.get(I.texture);le.framebufferTexture2D(36160,36064,34069+Y,Ke.__webglTexture,Z)}else if(He){const Ke=ne.get(I.texture),mt=Y||0;le.framebufferTextureLayer(36160,36064,Ke.__webglTexture,Z||0,mt)}w=-1},this.readRenderTargetPixels=function(I,Y,Z,J,ie,je,He){if(!(I&&I.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ze=ne.get(I).__webglFramebuffer;if(I.isWebGLCubeRenderTarget&&He!==void 0&&(Ze=Ze[He]),Ze){Fe.bindFramebuffer(36160,Ze);try{const Ke=I.texture,mt=Ke.format,ot=Ke.type;if(mt!==Ln&&ue.convert(mt)!==le.getParameter(35739)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const gt=ot===Xo&&(Ge.has("EXT_color_buffer_half_float")||Ae.isWebGL2&&Ge.has("EXT_color_buffer_float"));if(ot!==Qr&&ue.convert(ot)!==le.getParameter(35738)&&!(ot===Er&&(Ae.isWebGL2||Ge.has("OES_texture_float")||Ge.has("WEBGL_color_buffer_float")))&&!gt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}le.checkFramebufferStatus(36160)===36053?Y>=0&&Y<=I.width-J&&Z>=0&&Z<=I.height-ie&&le.readPixels(Y,Z,J,ie,ue.convert(mt),ue.convert(ot),je):console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.")}finally{const Ke=b!==null?ne.get(b).__webglFramebuffer:null;Fe.bindFramebuffer(36160,Ke)}}},this.copyFramebufferToTexture=function(I,Y,Z=0){const J=Math.pow(2,-Z),ie=Math.floor(Y.image.width*J),je=Math.floor(Y.image.height*J);let He=ue.convert(Y.format);Ae.isWebGL2&&(He===6407&&(He=32849),He===6408&&(He=32856)),he.setTexture2D(Y,0),le.copyTexImage2D(3553,Z,He,I.x,I.y,ie,je,0),Fe.unbindTexture()},this.copyTextureToTexture=function(I,Y,Z,J=0){const ie=Y.image.width,je=Y.image.height,He=ue.convert(Z.format),Ze=ue.convert(Z.type);he.setTexture2D(Z,0),le.pixelStorei(37440,Z.flipY),le.pixelStorei(37441,Z.premultiplyAlpha),le.pixelStorei(3317,Z.unpackAlignment),Y.isDataTexture?le.texSubImage2D(3553,J,I.x,I.y,ie,je,He,Ze,Y.image.data):Y.isCompressedTexture?le.compressedTexSubImage2D(3553,J,I.x,I.y,Y.mipmaps[0].width,Y.mipmaps[0].height,He,Y.mipmaps[0].data):le.texSubImage2D(3553,J,I.x,I.y,He,Ze,Y.image),J===0&&Z.generateMipmaps&&le.generateMipmap(3553),Fe.unbindTexture()},this.copyTextureToTexture3D=function(I,Y,Z,J,ie=0){if(m.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const je=I.max.x-I.min.x+1,He=I.max.y-I.min.y+1,Ze=I.max.z-I.min.z+1,Ke=ue.convert(J.format),mt=ue.convert(J.type);let ot;if(J.isDataTexture3D)he.setTexture3D(J,0),ot=32879;else if(J.isDataTexture2DArray)he.setTexture2DArray(J,0),ot=35866;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}le.pixelStorei(37440,J.flipY),le.pixelStorei(37441,J.premultiplyAlpha),le.pixelStorei(3317,J.unpackAlignment);const gt=le.getParameter(3314),Ot=le.getParameter(32878),On=le.getParameter(3316),St=le.getParameter(3315),vi=le.getParameter(32877),Rt=Z.isCompressedTexture?Z.mipmaps[0]:Z.image;le.pixelStorei(3314,Rt.width),le.pixelStorei(32878,Rt.height),le.pixelStorei(3316,I.min.x),le.pixelStorei(3315,I.min.y),le.pixelStorei(32877,I.min.z),Z.isDataTexture||Z.isDataTexture3D?le.texSubImage3D(ot,ie,Y.x,Y.y,Y.z,je,He,Ze,Ke,mt,Rt.data):Z.isCompressedTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),le.compressedTexSubImage3D(ot,ie,Y.x,Y.y,Y.z,je,He,Ze,Ke,Rt.data)):le.texSubImage3D(ot,ie,Y.x,Y.y,Y.z,je,He,Ze,Ke,mt,Rt),le.pixelStorei(3314,gt),le.pixelStorei(32878,Ot),le.pixelStorei(3316,On),le.pixelStorei(3315,St),le.pixelStorei(32877,vi),ie===0&&J.generateMipmaps&&le.generateMipmap(ot),Fe.unbindTexture()},this.initTexture=function(I){he.setTexture2D(I,0),Fe.unbindTexture()},this.resetState=function(){g=0,x=0,b=null,Fe.reset(),Ee.reset()},typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}Lt.prototype.isWebGLRenderer=!0;class mG extends Lt{}mG.prototype.isWebGL1Renderer=!0;class wu extends Ye{constructor(){super();this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.overrideMaterial=null,this.autoUpdate=!0,typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.autoUpdate=e.autoUpdate,this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),t}}wu.prototype.isScene=!0;class ba{constructor(e,t){this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=yl,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Ss()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let r=0,i=this.stride;r<i;r++)this.array[e+r]=t.array[s+r];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ss()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ss()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.prototype.slice.call(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}ba.prototype.isInterleavedBuffer=!0;const nn=new L;class wa{constructor(e,t,s,r=!1){this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=r===!0}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)nn.x=this.getX(t),nn.y=this.getY(t),nn.z=this.getZ(t),nn.applyMatrix4(e),this.setXYZ(t,nn.x,nn.y,nn.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)nn.x=this.getX(t),nn.y=this.getY(t),nn.z=this.getZ(t),nn.applyNormalMatrix(e),this.setXYZ(t,nn.x,nn.y,nn.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)nn.x=this.getX(t),nn.y=this.getY(t),nn.z=this.getZ(t),nn.transformDirection(e),this.setXYZ(t,nn.x,nn.y,nn.z);return this}setX(e,t){return this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){return this.data.array[e*this.data.stride+this.offset]}getY(e){return this.data.array[e*this.data.stride+this.offset+1]}getZ(e){return this.data.array[e*this.data.stride+this.offset+2]}getW(e){return this.data.array[e*this.data.stride+this.offset+3]}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,r){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=r,this}setXYZW(e,t,s,r,i){return e=e*this.data.stride+this.offset,this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=r,this.data.array[e+3]=i,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const r=s*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[r+i])}return new en(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new wa(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const r=s*this.data.stride+this.offset;for(let i=0;i<this.itemSize;i++)t.push(this.data.array[r+i])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}wa.prototype.isInterleavedBufferAttribute=!0;class vy extends pn{constructor(e){super();this.type="SpriteMaterial",this.color=new Le(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this}}vy.prototype.isSpriteMaterial=!0;let _a;const Il=new L,Sa=new L,Ta=new L,Ea=new pe,Nl=new pe,by=new ze,_u=new L,Ll=new L,Su=new L,wy=new pe,Lp=new pe,_y=new pe;class gG extends Ye{constructor(e){super();if(this.type="Sprite",_a===void 0){_a=new Wt;const t=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),s=new ba(t,5);_a.setIndex([0,1,2,0,2,3]),_a.setAttribute("position",new wa(s,3,0,!1)),_a.setAttribute("uv",new wa(s,2,3,!1))}this.geometry=_a,this.material=e!==void 0?e:new vy,this.center=new pe(.5,.5)}raycast(e,t){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Sa.setFromMatrixScale(this.matrixWorld),by.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Ta.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Sa.multiplyScalar(-Ta.z);const s=this.material.rotation;let r,i;s!==0&&(i=Math.cos(s),r=Math.sin(s));const o=this.center;Tu(_u.set(-.5,-.5,0),Ta,o,Sa,r,i),Tu(Ll.set(.5,-.5,0),Ta,o,Sa,r,i),Tu(Su.set(.5,.5,0),Ta,o,Sa,r,i),wy.set(0,0),Lp.set(1,0),_y.set(1,1);let a=e.ray.intersectTriangle(_u,Ll,Su,!1,Il);if(a===null&&(Tu(Ll.set(-.5,.5,0),Ta,o,Sa,r,i),Lp.set(0,1),a=e.ray.intersectTriangle(_u,Su,Ll,!1,Il),a===null))return;const l=e.ray.origin.distanceTo(Il);l<e.near||l>e.far||t.push({distance:l,point:Il.clone(),uv:on.getUV(Il,_u,Ll,Su,wy,Lp,_y,new pe),face:null,object:this})}copy(e){return super.copy(e),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}gG.prototype.isSprite=!0;function Tu(n,e,t,s,r,i){Ea.subVectors(n,t).addScalar(.5).multiply(s),r!==void 0?(Nl.x=i*Ea.x-r*Ea.y,Nl.y=r*Ea.x+i*Ea.y):Nl.copy(Ea),n.copy(e),n.x+=Nl.x,n.y+=Nl.y,n.applyMatrix4(by)}const Sy=new L,Ty=new $t,Ey=new $t,xG=new L,Cy=new ze;class Pp extends fn{constructor(e,t){super(e,t);this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new ze,this.bindMatrixInverse=new ze}copy(e){return super.copy(e),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,this}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new $t,t=this.geometry.attributes.skinWeight;for(let s=0,r=t.count;s<r;s++){e.x=t.getX(s),e.y=t.getY(s),e.z=t.getZ(s),e.w=t.getW(s);const i=1/e.manhattanLength();i!==1/0?e.multiplyScalar(i):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode==="attached"?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode==="detached"?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(e,t){const s=this.skeleton,r=this.geometry;Ty.fromBufferAttribute(r.attributes.skinIndex,e),Ey.fromBufferAttribute(r.attributes.skinWeight,e),Sy.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let i=0;i<4;i++){const o=Ey.getComponent(i);if(o!==0){const a=Ty.getComponent(i);Cy.multiplyMatrices(s.bones[a].matrixWorld,s.boneInverses[a]),t.addScaledVector(xG.copy(Sy).applyMatrix4(Cy),o)}}return t.applyMatrix4(this.bindMatrixInverse)}}Pp.prototype.isSkinnedMesh=!0;class Dp extends Ye{constructor(){super();this.type="Bone"}}Dp.prototype.isBone=!0;class My extends dn{constructor(e=null,t=1,s=1,r,i,o,a,l,c=hn,u=hn,h,d){super(null,o,a,l,c,u,r,i,h,d);this.image={data:e,width:t,height:s},this.magFilter=c,this.minFilter=u,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.needsUpdate=!0}}My.prototype.isDataTexture=!0;const Ay=new ze,yG=new ze;class kp{constructor(e=[],t=[]){this.uuid=Ss(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.frame=-1,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,r=this.bones.length;s<r;s++)this.boneInverses.push(new ze)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new ze;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,r=this.boneTexture;for(let i=0,o=e.length;i<o;i++){const a=e[i]?e[i].matrixWorld:yG;Ay.multiplyMatrices(a,t[i]),Ay.toArray(s,i*16)}r!==null&&(r.needsUpdate=!0)}clone(){return new kp(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=gx(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new My(t,e,e,Ln,Er);return this.boneMatrices=t,this.boneTexture=s,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const r=this.bones[t];if(r.name===e)return r}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,r=e.bones.length;s<r;s++){const i=e.bones[s];let o=t[i];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",i),o=new Dp),this.bones.push(o),this.boneInverses.push(new ze().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let r=0,i=t.length;r<i;r++){const o=t[r];e.bones.push(o.uuid);const a=s[r];e.boneInverses.push(a.toArray())}return e}}class $p extends en{constructor(e,t,s,r=1){typeof s=="number"&&(r=s,s=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument."));super(e,t,s);this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}$p.prototype.isInstancedBufferAttribute=!0;const Ry=new ze,Iy=new ze,Eu=[],Pl=new fn;class vG extends fn{constructor(e,t,s){super(e,t);this.instanceMatrix=new $p(new Float32Array(s*16),16),this.instanceColor=null,this.count=s,this.frustumCulled=!1}copy(e){return super.copy(e),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const s=this.matrixWorld,r=this.count;if(Pl.geometry=this.geometry,Pl.material=this.material,Pl.material!==void 0)for(let i=0;i<r;i++){this.getMatrixAt(i,Ry),Iy.multiplyMatrices(s,Ry),Pl.matrixWorld=Iy,Pl.raycast(e,Eu);for(let o=0,a=Eu.length;o<a;o++){const l=Eu[o];l.instanceId=i,l.object=this,t.push(l)}Eu.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new $p(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}vG.prototype.isInstancedMesh=!0;class Ca extends pn{constructor(e){super();this.type="LineBasicMaterial",this.color=new Le(16777215),this.linewidth=1,this.linecap="round",this.linejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this}}Ca.prototype.isLineBasicMaterial=!0;const Ny=new L,Ly=new L,Py=new ze,Fp=new sa,Cu=new Zi;class Mu extends Ye{constructor(e=new Wt,t=new Ca){super();this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,s=[0];for(let r=1,i=t.count;r<i;r++)Ny.fromBufferAttribute(t,r-1),Ly.fromBufferAttribute(t,r),s[r]=s[r-1],s[r]+=Ny.distanceTo(Ly);e.setAttribute("lineDistance",new tn(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}raycast(e,t){const s=this.geometry,r=this.matrixWorld,i=e.params.Line.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),Cu.copy(s.boundingSphere),Cu.applyMatrix4(r),Cu.radius+=i,e.ray.intersectsSphere(Cu)===!1)return;Py.copy(r).invert(),Fp.copy(e.ray).applyMatrix4(Py);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new L,u=new L,h=new L,d=new L,p=this.isLineSegments?2:1;if(s.isBufferGeometry){const f=s.index,y=s.attributes.position;if(f!==null){const g=Math.max(0,o.start),x=Math.min(f.count,o.start+o.count);for(let b=g,w=x-1;b<w;b+=p){const C=f.getX(b),M=f.getX(b+1);if(c.fromBufferAttribute(y,C),u.fromBufferAttribute(y,M),Fp.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const A=e.ray.origin.distanceTo(d);A<e.near||A>e.far||t.push({distance:A,point:h.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}else{const g=Math.max(0,o.start),x=Math.min(y.count,o.start+o.count);for(let b=g,w=x-1;b<w;b+=p){if(c.fromBufferAttribute(y,b),u.fromBufferAttribute(y,b+1),Fp.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const M=e.ray.origin.distanceTo(d);M<e.near||M>e.far||t.push({distance:M,point:h.clone().applyMatrix4(this.matrixWorld),index:b,face:null,faceIndex:null,object:this})}}}else s.isGeometry&&console.error("THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Mu.prototype.isLine=!0;const Dy=new L,ky=new L;class Au extends Mu{constructor(e,t){super(e,t);this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.isBufferGeometry)if(e.index===null){const t=e.attributes.position,s=[];for(let r=0,i=t.count;r<i;r+=2)Dy.fromBufferAttribute(t,r),ky.fromBufferAttribute(t,r+1),s[r]=r===0?0:s[r-1],s[r+1]=s[r]+Dy.distanceTo(ky);e.setAttribute("lineDistance",new tn(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");else e.isGeometry&&console.error("THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.");return this}}Au.prototype.isLineSegments=!0;class $y extends Mu{constructor(e,t){super(e,t);this.type="LineLoop"}}$y.prototype.isLineLoop=!0;class Op extends pn{constructor(e){super();this.type="PointsMaterial",this.color=new Le(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this}}Op.prototype.isPointsMaterial=!0;const Fy=new ze,Bp=new sa,Ru=new Zi,Iu=new L;class Oy extends Ye{constructor(e=new Wt,t=new Op){super();this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e){return super.copy(e),this.material=e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,r=this.matrixWorld,i=e.params.Points.threshold,o=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),Ru.copy(s.boundingSphere),Ru.applyMatrix4(r),Ru.radius+=i,e.ray.intersectsSphere(Ru)===!1)return;Fy.copy(r).invert(),Bp.copy(e.ray).applyMatrix4(Fy);const a=i/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a;if(s.isBufferGeometry){const c=s.index,h=s.attributes.position;if(c!==null){const d=Math.max(0,o.start),p=Math.min(c.count,o.start+o.count);for(let f=d,m=p;f<m;f++){const y=c.getX(f);Iu.fromBufferAttribute(h,y),By(Iu,y,l,r,e,t,this)}}else{const d=Math.max(0,o.start),p=Math.min(h.count,o.start+o.count);for(let f=d,m=p;f<m;f++)Iu.fromBufferAttribute(h,f),By(Iu,f,l,r,e,t,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const e=this.geometry;if(e.isBufferGeometry){const t=e.morphAttributes,s=Object.keys(t);if(s.length>0){const r=t[s[0]];if(r!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let i=0,o=r.length;i<o;i++){const a=r[i].name||String(i);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=i}}}}else{const t=e.morphTargets;t!==void 0&&t.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}Oy.prototype.isPoints=!0;function By(n,e,t,s,r,i,o){const a=Bp.distanceSqToPoint(n);if(a<t){const l=new L;Bp.closestPointToPoint(n,l),l.applyMatrix4(s);const c=r.ray.origin.distanceTo(l);if(c<r.near||c>r.far)return;i.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class zy extends dn{constructor(e,t,s,r,i,o,a,l,c){super(e,t,s,r,i,o,a,l,c);this.format=a!==void 0?a:ei,this.minFilter=o!==void 0?o:Zn,this.magFilter=i!==void 0?i:Zn,this.generateMipmaps=!1;const u=this;function h(){u.needsUpdate=!0,e.requestVideoFrameCallback(h)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(h)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}zy.prototype.isVideoTexture=!0;class bG extends dn{constructor(e,t,s,r,i,o,a,l,c,u,h,d){super(null,o,a,l,c,u,r,i,h,d);this.image={width:t,height:s},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}bG.prototype.isCompressedTexture=!0;class wG extends dn{constructor(e,t,s,r,i,o,a,l,c){super(e,t,s,r,i,o,a,l,c);this.needsUpdate=!0}}wG.prototype.isCanvasTexture=!0;new L;new L;new L;new on;class Cs{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,t){const s=this.getUtoTmapping(e);return this.getPoint(s,t)}getPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return t}getSpacedPoints(e=5){const t=[];for(let s=0;s<=e;s++)t.push(this.getPointAt(s/e));return t}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const t=[];let s,r=this.getPoint(0),i=0;t.push(0);for(let o=1;o<=e;o++)s=this.getPoint(o/e),i+=s.distanceTo(r),t.push(i),r=s;return this.cacheArcLengths=t,t}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,t){const s=this.getLengths();let r=0;const i=s.length;let o;t?o=t:o=e*s[i-1];let a=0,l=i-1,c;for(;a<=l;)if(r=Math.floor(a+(l-a)/2),c=s[r]-o,c<0)a=r+1;else if(c>0)l=r-1;else{l=r;break}if(r=l,s[r]===o)return r/(i-1);const u=s[r],d=s[r+1]-u,p=(o-u)/d;return(r+p)/(i-1)}getTangent(e,t){const s=1e-4;let r=e-s,i=e+s;r<0&&(r=0),i>1&&(i=1);const o=this.getPoint(r),a=this.getPoint(i),l=t||(o.isVector2?new pe:new L);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,t){const s=this.getUtoTmapping(e);return this.getTangent(s,t)}computeFrenetFrames(e,t){const s=new L,r=[],i=[],o=[],a=new L,l=new ze;for(let p=0;p<=e;p++){const f=p/e;r[p]=this.getTangentAt(f,new L)}i[0]=new L,o[0]=new L;let c=Number.MAX_VALUE;const u=Math.abs(r[0].x),h=Math.abs(r[0].y),d=Math.abs(r[0].z);u<=c&&(c=u,s.set(1,0,0)),h<=c&&(c=h,s.set(0,1,0)),d<=c&&s.set(0,0,1),a.crossVectors(r[0],s).normalize(),i[0].crossVectors(r[0],a),o[0].crossVectors(r[0],i[0]);for(let p=1;p<=e;p++){if(i[p]=i[p-1].clone(),o[p]=o[p-1].clone(),a.crossVectors(r[p-1],r[p]),a.length()>Number.EPSILON){a.normalize();const f=Math.acos(Qn(r[p-1].dot(r[p]),-1,1));i[p].applyMatrix4(l.makeRotationAxis(a,f))}o[p].crossVectors(r[p],i[p])}if(t===!0){let p=Math.acos(Qn(i[0].dot(i[e]),-1,1));p/=e,r[0].dot(a.crossVectors(i[0],i[e]))>0&&(p=-p);for(let f=1;f<=e;f++)i[f].applyMatrix4(l.makeRotationAxis(r[f],p*f)),o[f].crossVectors(r[f],i[f])}return{tangents:r,normals:i,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class Nu extends Cs{constructor(e=0,t=0,s=1,r=1,i=0,o=Math.PI*2,a=!1,l=0){super();this.type="EllipseCurve",this.aX=e,this.aY=t,this.xRadius=s,this.yRadius=r,this.aStartAngle=i,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,t){const s=t||new pe,r=Math.PI*2;let i=this.aEndAngle-this.aStartAngle;const o=Math.abs(i)<Number.EPSILON;for(;i<0;)i+=r;for(;i>r;)i-=r;i<Number.EPSILON&&(o?i=0:i=r),this.aClockwise===!0&&!o&&(i===r?i=-r:i=i-r);const a=this.aStartAngle+e*i;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),h=Math.sin(this.aRotation),d=l-this.aX,p=c-this.aY;l=d*u-p*h+this.aX,c=d*h+p*u+this.aY}return s.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}Nu.prototype.isEllipseCurve=!0;class Uy extends Nu{constructor(e,t,s,r,i,o){super(e,t,s,s,r,i,o);this.type="ArcCurve"}}Uy.prototype.isArcCurve=!0;function zp(){let n=0,e=0,t=0,s=0;function r(i,o,a,l){n=i,e=a,t=-3*i+3*o-2*a-l,s=2*i-2*o+a+l}return{initCatmullRom:function(i,o,a,l,c){r(o,a,c*(a-i),c*(l-o))},initNonuniformCatmullRom:function(i,o,a,l,c,u,h){let d=(o-i)/c-(a-i)/(c+u)+(a-o)/u,p=(a-o)/u-(l-o)/(u+h)+(l-a)/h;d*=u,p*=u,r(o,a,d,p)},calc:function(i){const o=i*i,a=o*i;return n+e*i+t*o+s*a}}}const Lu=new L,Up=new zp,Vp=new zp,Gp=new zp;class Vy extends Cs{constructor(e=[],t=!1,s="centripetal",r=.5){super();this.type="CatmullRomCurve3",this.points=e,this.closed=t,this.curveType=s,this.tension=r}getPoint(e,t=new L){const s=t,r=this.points,i=r.length,o=(i-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/i)+1)*i:l===0&&a===i-1&&(a=i-2,l=1);let c,u;this.closed||a>0?c=r[(a-1)%i]:(Lu.subVectors(r[0],r[1]).add(r[0]),c=Lu);const h=r[a%i],d=r[(a+1)%i];if(this.closed||a+2<i?u=r[(a+2)%i]:(Lu.subVectors(r[i-1],r[i-2]).add(r[i-1]),u=Lu),this.curveType==="centripetal"||this.curveType==="chordal"){const p=this.curveType==="chordal"?.5:.25;let f=Math.pow(c.distanceToSquared(h),p),m=Math.pow(h.distanceToSquared(d),p),y=Math.pow(d.distanceToSquared(u),p);m<1e-4&&(m=1),f<1e-4&&(f=m),y<1e-4&&(y=m),Up.initNonuniformCatmullRom(c.x,h.x,d.x,u.x,f,m,y),Vp.initNonuniformCatmullRom(c.y,h.y,d.y,u.y,f,m,y),Gp.initNonuniformCatmullRom(c.z,h.z,d.z,u.z,f,m,y)}else this.curveType==="catmullrom"&&(Up.initCatmullRom(c.x,h.x,d.x,u.x,this.tension),Vp.initCatmullRom(c.y,h.y,d.y,u.y,this.tension),Gp.initCatmullRom(c.z,h.z,d.z,u.z,this.tension));return s.set(Up.calc(l),Vp.calc(l),Gp.calc(l)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(r.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const r=this.points[t];e.points.push(r.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(new L().fromArray(r))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}Vy.prototype.isCatmullRomCurve3=!0;function Gy(n,e,t,s,r){const i=(s-e)*.5,o=(r-t)*.5,a=n*n,l=n*a;return(2*t-2*s+i+o)*l+(-3*t+3*s-2*i-o)*a+i*n+t}function _G(n,e){const t=1-n;return t*t*e}function SG(n,e){return 2*(1-n)*n*e}function TG(n,e){return n*n*e}function Dl(n,e,t,s){return _G(n,e)+SG(n,t)+TG(n,s)}function EG(n,e){const t=1-n;return t*t*t*e}function CG(n,e){const t=1-n;return 3*t*t*n*e}function MG(n,e){return 3*(1-n)*n*n*e}function AG(n,e){return n*n*n*e}function kl(n,e,t,s,r){return EG(n,e)+CG(n,t)+MG(n,s)+AG(n,r)}class Wp extends Cs{constructor(e=new pe,t=new pe,s=new pe,r=new pe){super();this.type="CubicBezierCurve",this.v0=e,this.v1=t,this.v2=s,this.v3=r}getPoint(e,t=new pe){const s=t,r=this.v0,i=this.v1,o=this.v2,a=this.v3;return s.set(kl(e,r.x,i.x,o.x,a.x),kl(e,r.y,i.y,o.y,a.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Wp.prototype.isCubicBezierCurve=!0;class Wy extends Cs{constructor(e=new L,t=new L,s=new L,r=new L){super();this.type="CubicBezierCurve3",this.v0=e,this.v1=t,this.v2=s,this.v3=r}getPoint(e,t=new L){const s=t,r=this.v0,i=this.v1,o=this.v2,a=this.v3;return s.set(kl(e,r.x,i.x,o.x,a.x),kl(e,r.y,i.y,o.y,a.y),kl(e,r.z,i.z,o.z,a.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}Wy.prototype.isCubicBezierCurve3=!0;class Pu extends Cs{constructor(e=new pe,t=new pe){super();this.type="LineCurve",this.v1=e,this.v2=t}getPoint(e,t=new pe){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}getTangent(e,t){const s=t||new pe;return s.copy(this.v2).sub(this.v1).normalize(),s}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Pu.prototype.isLineCurve=!0;class RG extends Cs{constructor(e=new L,t=new L){super();this.type="LineCurve3",this.isLineCurve3=!0,this.v1=e,this.v2=t}getPoint(e,t=new L){const s=t;return e===1?s.copy(this.v2):(s.copy(this.v2).sub(this.v1),s.multiplyScalar(e).add(this.v1)),s}getPointAt(e,t){return this.getPoint(e,t)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class Hp extends Cs{constructor(e=new pe,t=new pe,s=new pe){super();this.type="QuadraticBezierCurve",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new pe){const s=t,r=this.v0,i=this.v1,o=this.v2;return s.set(Dl(e,r.x,i.x,o.x),Dl(e,r.y,i.y,o.y)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Hp.prototype.isQuadraticBezierCurve=!0;class Hy extends Cs{constructor(e=new L,t=new L,s=new L){super();this.type="QuadraticBezierCurve3",this.v0=e,this.v1=t,this.v2=s}getPoint(e,t=new L){const s=t,r=this.v0,i=this.v1,o=this.v2;return s.set(Dl(e,r.x,i.x,o.x),Dl(e,r.y,i.y,o.y),Dl(e,r.z,i.z,o.z)),s}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}Hy.prototype.isQuadraticBezierCurve3=!0;class Xp extends Cs{constructor(e=[]){super();this.type="SplineCurve",this.points=e}getPoint(e,t=new pe){const s=t,r=this.points,i=(r.length-1)*e,o=Math.floor(i),a=i-o,l=r[o===0?o:o-1],c=r[o],u=r[o>r.length-2?r.length-1:o+1],h=r[o>r.length-3?r.length-1:o+2];return s.set(Gy(a,l.x,c.x,u.x,h.x),Gy(a,l.y,c.y,u.y,h.y)),s}copy(e){super.copy(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let t=0,s=this.points.length;t<s;t++){const r=this.points[t];e.points.push(r.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let t=0,s=e.points.length;t<s;t++){const r=e.points[t];this.points.push(new pe().fromArray(r))}return this}}Xp.prototype.isSplineCurve=!0;var Xy=Object.freeze({__proto__:null,ArcCurve:Uy,CatmullRomCurve3:Vy,CubicBezierCurve:Wp,CubicBezierCurve3:Wy,EllipseCurve:Nu,LineCurve:Pu,LineCurve3:RG,QuadraticBezierCurve:Hp,QuadraticBezierCurve3:Hy,SplineCurve:Xp});class IG extends Cs{constructor(){super();this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),t=this.curves[this.curves.length-1].getPoint(1);e.equals(t)||this.curves.push(new Pu(t,e))}getPoint(e,t){const s=e*this.getLength(),r=this.getCurveLengths();let i=0;for(;i<r.length;){if(r[i]>=s){const o=r[i]-s,a=this.curves[i],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,t)}i++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let t=0;for(let s=0,r=this.curves.length;s<r;s++)t+=this.curves[s].getLength(),e.push(t);return this.cacheLengths=e,e}getSpacedPoints(e=40){const t=[];for(let s=0;s<=e;s++)t.push(this.getPoint(s/e));return this.autoClose&&t.push(t[0]),t}getPoints(e=12){const t=[];let s;for(let r=0,i=this.curves;r<i.length;r++){const o=i[r],a=o&&o.isEllipseCurve?e*2:o&&(o.isLineCurve||o.isLineCurve3)?1:o&&o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const u=l[c];s&&s.equals(u)||(t.push(u),s=u)}}return this.autoClose&&t.length>1&&!t[t.length-1].equals(t[0])&&t.push(t[0]),t}copy(e){super.copy(e),this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const r=e.curves[t];this.curves.push(r.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let t=0,s=this.curves.length;t<s;t++){const r=this.curves[t];e.curves.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let t=0,s=e.curves.length;t<s;t++){const r=e.curves[t];this.curves.push(new Xy[r.type]().fromJSON(r))}return this}}class jp extends IG{constructor(e){super();this.type="Path",this.currentPoint=new pe,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let t=1,s=e.length;t<s;t++)this.lineTo(e[t].x,e[t].y);return this}moveTo(e,t){return this.currentPoint.set(e,t),this}lineTo(e,t){const s=new Pu(this.currentPoint.clone(),new pe(e,t));return this.curves.push(s),this.currentPoint.set(e,t),this}quadraticCurveTo(e,t,s,r){const i=new Hp(this.currentPoint.clone(),new pe(e,t),new pe(s,r));return this.curves.push(i),this.currentPoint.set(s,r),this}bezierCurveTo(e,t,s,r,i,o){const a=new Wp(this.currentPoint.clone(),new pe(e,t),new pe(s,r),new pe(i,o));return this.curves.push(a),this.currentPoint.set(i,o),this}splineThru(e){const t=[this.currentPoint.clone()].concat(e),s=new Xp(t);return this.curves.push(s),this.currentPoint.copy(e[e.length-1]),this}arc(e,t,s,r,i,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,t+l,s,r,i,o),this}absarc(e,t,s,r,i,o){return this.absellipse(e,t,s,s,r,i,o),this}ellipse(e,t,s,r,i,o,a,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,t+u,s,r,i,o,a,l),this}absellipse(e,t,s,r,i,o,a,l){const c=new Nu(e,t,s,r,i,o,a,l);if(this.curves.length>0){const h=c.getPoint(0);h.equals(this.currentPoint)||this.lineTo(h.x,h.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class $l extends jp{constructor(e){super(e);this.uuid=Ss(),this.type="Shape",this.holes=[]}getPointsHoles(e){const t=[];for(let s=0,r=this.holes.length;s<r;s++)t[s]=this.holes[s].getPoints(e);return t}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const r=e.holes[t];this.holes.push(r.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let t=0,s=this.holes.length;t<s;t++){const r=this.holes[t];e.holes.push(r.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let t=0,s=e.holes.length;t<s;t++){const r=e.holes[t];this.holes.push(new jp().fromJSON(r))}return this}}const NG={triangulate:function(n,e,t=2){const s=e&&e.length,r=s?e[0]*t:n.length;let i=jy(n,0,r,t,!0);const o=[];if(!i||i.next===i.prev)return o;let a,l,c,u,h,d,p;if(s&&(i=$G(n,e,i,t)),n.length>80*t){a=c=n[0],l=u=n[1];for(let f=t;f<r;f+=t)h=n[f],d=n[f+1],h<a&&(a=h),d<l&&(l=d),h>c&&(c=h),d>u&&(u=d);p=Math.max(c-a,u-l),p=p!==0?1/p:0}return Fl(i,o,t,a,l,p),o}};function jy(n,e,t,s,r){let i,o;if(r===jG(n,e,t,s)>0)for(i=e;i<t;i+=s)o=Yy(i,n[i],n[i+1],o);else for(i=t-s;i>=e;i-=s)o=Yy(i,n[i],n[i+1],o);return o&&Du(o,o.next)&&(Bl(o),o=o.next),o}function di(n,e){if(!n)return n;e||(e=n);let t=n,s;do if(s=!1,!t.steiner&&(Du(t,t.next)||Yt(t.prev,t,t.next)===0)){if(Bl(t),t=e=t.prev,t===t.next)break;s=!0}else t=t.next;while(s||t!==e);return e}function Fl(n,e,t,s,r,i,o){if(!n)return;!o&&i&&UG(n,s,r,i);let a=n,l,c;for(;n.prev!==n.next;){if(l=n.prev,c=n.next,i?PG(n,s,r,i):LG(n)){e.push(l.i/t),e.push(n.i/t),e.push(c.i/t),Bl(n),n=c.next,a=c.next;continue}if(n=c,n===a){o?o===1?(n=DG(di(n),e,t),Fl(n,e,t,s,r,i,2)):o===2&&kG(n,e,t,s,r,i):Fl(di(n),e,t,s,r,i,1);break}}}function LG(n){const e=n.prev,t=n,s=n.next;if(Yt(e,t,s)>=0)return!1;let r=n.next.next;for(;r!==n.prev;){if(Ma(e.x,e.y,t.x,t.y,s.x,s.y,r.x,r.y)&&Yt(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function PG(n,e,t,s){const r=n.prev,i=n,o=n.next;if(Yt(r,i,o)>=0)return!1;const a=r.x<i.x?r.x<o.x?r.x:o.x:i.x<o.x?i.x:o.x,l=r.y<i.y?r.y<o.y?r.y:o.y:i.y<o.y?i.y:o.y,c=r.x>i.x?r.x>o.x?r.x:o.x:i.x>o.x?i.x:o.x,u=r.y>i.y?r.y>o.y?r.y:o.y:i.y>o.y?i.y:o.y,h=qp(a,l,e,t,s),d=qp(c,u,e,t,s);let p=n.prevZ,f=n.nextZ;for(;p&&p.z>=h&&f&&f.z<=d;){if(p!==n.prev&&p!==n.next&&Ma(r.x,r.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Yt(p.prev,p,p.next)>=0||(p=p.prevZ,f!==n.prev&&f!==n.next&&Ma(r.x,r.y,i.x,i.y,o.x,o.y,f.x,f.y)&&Yt(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;p&&p.z>=h;){if(p!==n.prev&&p!==n.next&&Ma(r.x,r.y,i.x,i.y,o.x,o.y,p.x,p.y)&&Yt(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;f&&f.z<=d;){if(f!==n.prev&&f!==n.next&&Ma(r.x,r.y,i.x,i.y,o.x,o.y,f.x,f.y)&&Yt(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function DG(n,e,t){let s=n;do{const r=s.prev,i=s.next.next;!Du(r,i)&&qy(r,s,s.next,i)&&Ol(r,i)&&Ol(i,r)&&(e.push(r.i/t),e.push(s.i/t),e.push(i.i/t),Bl(s),Bl(s.next),s=n=i),s=s.next}while(s!==n);return di(s)}function kG(n,e,t,s,r,i){let o=n;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&WG(o,a)){let l=Ky(o,a);o=di(o,o.next),l=di(l,l.next),Fl(o,e,t,s,r,i),Fl(l,e,t,s,r,i);return}a=a.next}o=o.next}while(o!==n)}function $G(n,e,t,s){const r=[];let i,o,a,l,c;for(i=0,o=e.length;i<o;i++)a=e[i]*s,l=i<o-1?e[i+1]*s:n.length,c=jy(n,a,l,s,!1),c===c.next&&(c.steiner=!0),r.push(GG(c));for(r.sort(FG),i=0;i<r.length;i++)OG(r[i],t),t=di(t,t.next);return t}function FG(n,e){return n.x-e.x}function OG(n,e){if(e=BG(n,e),e){const t=Ky(e,n);di(e,e.next),di(t,t.next)}}function BG(n,e){let t=e;const s=n.x,r=n.y;let i=-1/0,o;do{if(r<=t.y&&r>=t.next.y&&t.next.y!==t.y){const d=t.x+(r-t.y)*(t.next.x-t.x)/(t.next.y-t.y);if(d<=s&&d>i){if(i=d,d===s){if(r===t.y)return t;if(r===t.next.y)return t.next}o=t.x<t.next.x?t:t.next}}t=t.next}while(t!==e);if(!o)return null;if(s===i)return o;const a=o,l=o.x,c=o.y;let u=1/0,h;t=o;do s>=t.x&&t.x>=l&&s!==t.x&&Ma(r<c?s:i,r,l,c,r<c?i:s,r,t.x,t.y)&&(h=Math.abs(r-t.y)/(s-t.x),Ol(t,n)&&(h<u||h===u&&(t.x>o.x||t.x===o.x&&zG(o,t)))&&(o=t,u=h)),t=t.next;while(t!==a);return o}function zG(n,e){return Yt(n.prev,n,e.prev)<0&&Yt(e.next,n,n.next)<0}function UG(n,e,t,s){let r=n;do r.z===null&&(r.z=qp(r.x,r.y,e,t,s)),r.prevZ=r.prev,r.nextZ=r.next,r=r.next;while(r!==n);r.prevZ.nextZ=null,r.prevZ=null,VG(r)}function VG(n){let e,t,s,r,i,o,a,l,c=1;do{for(t=n,n=null,i=null,o=0;t;){for(o++,s=t,a=0,e=0;e<c&&(a++,s=s.nextZ,!!s);e++);for(l=c;a>0||l>0&&s;)a!==0&&(l===0||!s||t.z<=s.z)?(r=t,t=t.nextZ,a--):(r=s,s=s.nextZ,l--),i?i.nextZ=r:n=r,r.prevZ=i,i=r;t=s}i.nextZ=null,c*=2}while(o>1);return n}function qp(n,e,t,s,r){return n=32767*(n-t)*r,e=32767*(e-s)*r,n=(n|n<<8)&16711935,n=(n|n<<4)&252645135,n=(n|n<<2)&858993459,n=(n|n<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,n|e<<1}function GG(n){let e=n,t=n;do(e.x<t.x||e.x===t.x&&e.y<t.y)&&(t=e),e=e.next;while(e!==n);return t}function Ma(n,e,t,s,r,i,o,a){return(r-o)*(e-a)-(n-o)*(i-a)>=0&&(n-o)*(s-a)-(t-o)*(e-a)>=0&&(t-o)*(i-a)-(r-o)*(s-a)>=0}function WG(n,e){return n.next.i!==e.i&&n.prev.i!==e.i&&!HG(n,e)&&(Ol(n,e)&&Ol(e,n)&&XG(n,e)&&(Yt(n.prev,n,e.prev)||Yt(n,e.prev,e))||Du(n,e)&&Yt(n.prev,n,n.next)>0&&Yt(e.prev,e,e.next)>0)}function Yt(n,e,t){return(e.y-n.y)*(t.x-e.x)-(e.x-n.x)*(t.y-e.y)}function Du(n,e){return n.x===e.x&&n.y===e.y}function qy(n,e,t,s){const r=$u(Yt(n,e,t)),i=$u(Yt(n,e,s)),o=$u(Yt(t,s,n)),a=$u(Yt(t,s,e));return!!(r!==i&&o!==a||r===0&&ku(n,t,e)||i===0&&ku(n,s,e)||o===0&&ku(t,n,s)||a===0&&ku(t,e,s))}function ku(n,e,t){return e.x<=Math.max(n.x,t.x)&&e.x>=Math.min(n.x,t.x)&&e.y<=Math.max(n.y,t.y)&&e.y>=Math.min(n.y,t.y)}function $u(n){return n>0?1:n<0?-1:0}function HG(n,e){let t=n;do{if(t.i!==n.i&&t.next.i!==n.i&&t.i!==e.i&&t.next.i!==e.i&&qy(t,t.next,n,e))return!0;t=t.next}while(t!==n);return!1}function Ol(n,e){return Yt(n.prev,n,n.next)<0?Yt(n,e,n.next)>=0&&Yt(n,n.prev,e)>=0:Yt(n,e,n.prev)<0||Yt(n,n.next,e)<0}function XG(n,e){let t=n,s=!1;const r=(n.x+e.x)/2,i=(n.y+e.y)/2;do t.y>i!=t.next.y>i&&t.next.y!==t.y&&r<(t.next.x-t.x)*(i-t.y)/(t.next.y-t.y)+t.x&&(s=!s),t=t.next;while(t!==n);return s}function Ky(n,e){const t=new Kp(n.i,n.x,n.y),s=new Kp(e.i,e.x,e.y),r=n.next,i=e.prev;return n.next=e,e.prev=n,t.next=r,r.prev=t,s.next=t,t.prev=s,i.next=s,s.prev=i,s}function Yy(n,e,t,s){const r=new Kp(n,e,t);return s?(r.next=s.next,r.prev=s,s.next.prev=r,s.next=r):(r.prev=r,r.next=r),r}function Bl(n){n.next.prev=n.prev,n.prev.next=n.next,n.prevZ&&(n.prevZ.nextZ=n.nextZ),n.nextZ&&(n.nextZ.prevZ=n.prevZ)}function Kp(n,e,t){this.i=n,this.x=e,this.y=t,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}function jG(n,e,t,s){let r=0;for(let i=e,o=t-s;i<t;i+=s)r+=(n[o]-n[i])*(n[i+1]+n[o+1]),o=i;return r}class pi{static area(e){const t=e.length;let s=0;for(let r=t-1,i=0;i<t;r=i++)s+=e[r].x*e[i].y-e[i].x*e[r].y;return s*.5}static isClockWise(e){return pi.area(e)<0}static triangulateShape(e,t){const s=[],r=[],i=[];Zy(e),Jy(s,e);let o=e.length;t.forEach(Zy);for(let l=0;l<t.length;l++)r.push(o),o+=t[l].length,Jy(s,t[l]);const a=NG.triangulate(s,r);for(let l=0;l<a.length;l+=3)i.push(a.slice(l,l+3));return i}}function Zy(n){const e=n.length;e>2&&n[e-1].equals(n[0])&&n.pop()}function Jy(n,e){for(let t=0;t<e.length;t++)n.push(e[t].x),n.push(e[t].y)}class Aa extends Wt{constructor(e=new $l([new pe(.5,.5),new pe(-.5,.5),new pe(-.5,-.5),new pe(.5,-.5)]),t={}){super();this.type="ExtrudeGeometry",this.parameters={shapes:e,options:t},e=Array.isArray(e)?e:[e];const s=this,r=[],i=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new tn(r,3)),this.setAttribute("uv",new tn(i,2)),this.computeVertexNormals();function o(a){const l=[],c=t.curveSegments!==void 0?t.curveSegments:12,u=t.steps!==void 0?t.steps:1;let h=t.depth!==void 0?t.depth:1,d=t.bevelEnabled!==void 0?t.bevelEnabled:!0,p=t.bevelThickness!==void 0?t.bevelThickness:.2,f=t.bevelSize!==void 0?t.bevelSize:p-.1,m=t.bevelOffset!==void 0?t.bevelOffset:0,y=t.bevelSegments!==void 0?t.bevelSegments:3;const g=t.extrudePath,x=t.UVGenerator!==void 0?t.UVGenerator:qG;t.amount!==void 0&&(console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."),h=t.amount);let b,w=!1,C,M,E,A;g&&(b=g.getSpacedPoints(u),w=!0,d=!1,C=g.computeFrenetFrames(u,!1),M=new L,E=new L,A=new L),d||(y=0,p=0,f=0,m=0);const $=a.extractPoints(c);let B=$.shape;const R=$.holes;if(!pi.isClockWise(B)){B=B.reverse();for(let ne=0,he=R.length;ne<he;ne++){const ye=R[ne];pi.isClockWise(ye)&&(R[ne]=ye.reverse())}}const F=pi.triangulateShape(B,R),z=B;for(let ne=0,he=R.length;ne<he;ne++){const ye=R[ne];B=B.concat(ye)}function V(ne,he,ye){return he||console.error("THREE.ExtrudeGeometry: vec does not exist"),he.clone().multiplyScalar(ye).add(ne)}const H=B.length,j=F.length;function ae(ne,he,ye){let Re,ve,We;const Ue=ne.x-he.x,st=ne.y-he.y,At=ye.x-ne.x,k=ye.y-ne.y,N=Ue*Ue+st*st,ce=Ue*k-st*At;if(Math.abs(ce)>Number.EPSILON){const oe=Math.sqrt(N),ke=Math.sqrt(At*At+k*k),Ie=he.x-st/oe,U=he.y+Ue/oe,me=ye.x-k/ke,ue=ye.y+At/ke,Ee=((me-Ie)*k-(ue-U)*At)/(Ue*k-st*At);Re=Ie+Ue*Ee-ne.x,ve=U+st*Ee-ne.y;const _e=Re*Re+ve*ve;if(_e<=2)return new pe(Re,ve);We=Math.sqrt(_e/2)}else{let oe=!1;Ue>Number.EPSILON?At>Number.EPSILON&&(oe=!0):Ue<-Number.EPSILON?At<-Number.EPSILON&&(oe=!0):Math.sign(st)===Math.sign(k)&&(oe=!0),oe?(Re=-st,ve=Ue,We=Math.sqrt(N)):(Re=Ue,ve=st,We=Math.sqrt(N/2))}return new pe(Re/We,ve/We)}const fe=[];for(let ne=0,he=z.length,ye=he-1,Re=ne+1;ne<he;ne++,ye++,Re++)ye===he&&(ye=0),Re===he&&(Re=0),fe[ne]=ae(z[ne],z[ye],z[Re]);const Q=[];let te,Te=fe.concat();for(let ne=0,he=R.length;ne<he;ne++){const ye=R[ne];te=[];for(let Re=0,ve=ye.length,We=ve-1,Ue=Re+1;Re<ve;Re++,We++,Ue++)We===ve&&(We=0),Ue===ve&&(Ue=0),te[Re]=ae(ye[Re],ye[We],ye[Ue]);Q.push(te),Te=Te.concat(te)}for(let ne=0;ne<y;ne++){const he=ne/y,ye=p*Math.cos(he*Math.PI/2),Re=f*Math.sin(he*Math.PI/2)+m;for(let ve=0,We=z.length;ve<We;ve++){const Ue=V(z[ve],fe[ve],Re);et(Ue.x,Ue.y,-ye)}for(let ve=0,We=R.length;ve<We;ve++){const Ue=R[ve];te=Q[ve];for(let st=0,At=Ue.length;st<At;st++){const k=V(Ue[st],te[st],Re);et(k.x,k.y,-ye)}}}const we=f+m;for(let ne=0;ne<H;ne++){const he=d?V(B[ne],Te[ne],we):B[ne];w?(E.copy(C.normals[0]).multiplyScalar(he.x),M.copy(C.binormals[0]).multiplyScalar(he.y),A.copy(b[0]).add(E).add(M),et(A.x,A.y,A.z)):et(he.x,he.y,0)}for(let ne=1;ne<=u;ne++)for(let he=0;he<H;he++){const ye=d?V(B[he],Te[he],we):B[he];w?(E.copy(C.normals[ne]).multiplyScalar(ye.x),M.copy(C.binormals[ne]).multiplyScalar(ye.y),A.copy(b[ne]).add(E).add(M),et(A.x,A.y,A.z)):et(ye.x,ye.y,h/u*ne)}for(let ne=y-1;ne>=0;ne--){const he=ne/y,ye=p*Math.cos(he*Math.PI/2),Re=f*Math.sin(he*Math.PI/2)+m;for(let ve=0,We=z.length;ve<We;ve++){const Ue=V(z[ve],fe[ve],Re);et(Ue.x,Ue.y,h+ye)}for(let ve=0,We=R.length;ve<We;ve++){const Ue=R[ve];te=Q[ve];for(let st=0,At=Ue.length;st<At;st++){const k=V(Ue[st],te[st],Re);w?et(k.x,k.y+b[u-1].y,b[u-1].x+ye):et(k.x,k.y,h+ye)}}}Pe(),it();function Pe(){const ne=r.length/3;if(d){let he=0,ye=H*he;for(let Re=0;Re<j;Re++){const ve=F[Re];Ge(ve[2]+ye,ve[1]+ye,ve[0]+ye)}he=u+y*2,ye=H*he;for(let Re=0;Re<j;Re++){const ve=F[Re];Ge(ve[0]+ye,ve[1]+ye,ve[2]+ye)}}else{for(let he=0;he<j;he++){const ye=F[he];Ge(ye[2],ye[1],ye[0])}for(let he=0;he<j;he++){const ye=F[he];Ge(ye[0]+H*u,ye[1]+H*u,ye[2]+H*u)}}s.addGroup(ne,r.length/3-ne,0)}function it(){const ne=r.length/3;let he=0;le(z,he),he+=z.length;for(let ye=0,Re=R.length;ye<Re;ye++){const ve=R[ye];le(ve,he),he+=ve.length}s.addGroup(ne,r.length/3-ne,1)}function le(ne,he){let ye=ne.length;for(;--ye>=0;){const Re=ye;let ve=ye-1;ve<0&&(ve=ne.length-1);for(let We=0,Ue=u+y*2;We<Ue;We++){const st=H*We,At=H*(We+1),k=he+Re+st,N=he+ve+st,ce=he+ve+At,oe=he+Re+At;Ae(k,N,ce,oe)}}}function et(ne,he,ye){l.push(ne),l.push(he),l.push(ye)}function Ge(ne,he,ye){Fe(ne),Fe(he),Fe(ye);const Re=r.length/3,ve=x.generateTopUV(s,r,Re-3,Re-2,Re-1);nt(ve[0]),nt(ve[1]),nt(ve[2])}function Ae(ne,he,ye,Re){Fe(ne),Fe(he),Fe(Re),Fe(he),Fe(ye),Fe(Re);const ve=r.length/3,We=x.generateSideWallUV(s,r,ve-6,ve-3,ve-2,ve-1);nt(We[0]),nt(We[1]),nt(We[3]),nt(We[1]),nt(We[2]),nt(We[3])}function Fe(ne){r.push(l[ne*3+0]),r.push(l[ne*3+1]),r.push(l[ne*3+2])}function nt(ne){i.push(ne.x),i.push(ne.y)}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes,s=this.parameters.options;return KG(t,s,e)}static fromJSON(e,t){const s=[];for(let i=0,o=e.shapes.length;i<o;i++){const a=t[e.shapes[i]];s.push(a)}const r=e.options.extrudePath;return r!==void 0&&(e.options.extrudePath=new Xy[r.type]().fromJSON(r)),new Aa(s,e.options)}}const qG={generateTopUV:function(n,e,t,s,r){const i=e[t*3],o=e[t*3+1],a=e[s*3],l=e[s*3+1],c=e[r*3],u=e[r*3+1];return[new pe(i,o),new pe(a,l),new pe(c,u)]},generateSideWallUV:function(n,e,t,s,r,i){const o=e[t*3],a=e[t*3+1],l=e[t*3+2],c=e[s*3],u=e[s*3+1],h=e[s*3+2],d=e[r*3],p=e[r*3+1],f=e[r*3+2],m=e[i*3],y=e[i*3+1],g=e[i*3+2];return Math.abs(a-u)<Math.abs(o-c)?[new pe(o,1-l),new pe(c,1-h),new pe(d,1-f),new pe(m,1-g)]:[new pe(a,1-l),new pe(u,1-h),new pe(p,1-f),new pe(y,1-g)]}};function KG(n,e,t){if(t.shapes=[],Array.isArray(n))for(let s=0,r=n.length;s<r;s++){const i=n[s];t.shapes.push(i.uuid)}else t.shapes.push(n.uuid);return e.extrudePath!==void 0&&(t.options.extrudePath=e.extrudePath.toJSON()),t}class Yp extends Wt{constructor(e=new $l([new pe(0,.5),new pe(-.5,-.5),new pe(.5,-.5)]),t=12){super();this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:t};const s=[],r=[],i=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(s),this.setAttribute("position",new tn(r,3)),this.setAttribute("normal",new tn(i,3)),this.setAttribute("uv",new tn(o,2));function c(u){const h=r.length/3,d=u.extractPoints(t);let p=d.shape;const f=d.holes;pi.isClockWise(p)===!1&&(p=p.reverse());for(let y=0,g=f.length;y<g;y++){const x=f[y];pi.isClockWise(x)===!0&&(f[y]=x.reverse())}const m=pi.triangulateShape(p,f);for(let y=0,g=f.length;y<g;y++){const x=f[y];p=p.concat(x)}for(let y=0,g=p.length;y<g;y++){const x=p[y];r.push(x.x,x.y,0),i.push(0,0,1),o.push(x.x,x.y)}for(let y=0,g=m.length;y<g;y++){const x=m[y],b=x[0]+h,w=x[1]+h,C=x[2]+h;s.push(b,w,C),l+=3}}}toJSON(){const e=super.toJSON(),t=this.parameters.shapes;return YG(t,e)}static fromJSON(e,t){const s=[];for(let r=0,i=e.shapes.length;r<i;r++){const o=t[e.shapes[r]];s.push(o)}return new Yp(s,e.curveSegments)}}function YG(n,e){if(e.shapes=[],Array.isArray(n))for(let t=0,s=n.length;t<s;t++){const r=n[t];e.shapes.push(r.uuid)}else e.shapes.push(n.uuid);return e}class ZG extends pn{constructor(e){super();this.type="ShadowMaterial",this.color=new Le(0),this.transparent=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this}}ZG.prototype.isShadowMaterial=!0;class no extends pn{constructor(e){super();this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Le(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ji,this.normalScale=new pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}no.prototype.isMeshStandardMaterial=!0;class so extends no{constructor(e){super();this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new pe(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return Qn(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.sheenColor=new Le(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=0,this.attenuationColor=new Le(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Le(1,1,1),this.specularColorMap=null,this._sheen=0,this._clearcoat=0,this._transmission=0,this.setValues(e)}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}so.prototype.isMeshPhysicalMaterial=!0;class JG extends pn{constructor(e){super();this.type="MeshPhongMaterial",this.color=new Le(16777215),this.specular=new Le(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ji,this.normalScale=new pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this}}JG.prototype.isMeshPhongMaterial=!0;class QG extends pn{constructor(e){super();this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Le(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ji,this.normalScale=new pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}QG.prototype.isMeshToonMaterial=!0;class eW extends pn{constructor(e){super();this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ji,this.normalScale=new pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}eW.prototype.isMeshNormalMaterial=!0;class tW extends pn{constructor(e){super();this.type="MeshLambertMaterial",this.color=new Le(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Le(0),this.emissiveIntensity=1,this.emissiveMap=null,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=Wc,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this}}tW.prototype.isMeshLambertMaterial=!0;class nW extends pn{constructor(e){super();this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Le(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=ji,this.normalScale=new pe(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this}}nW.prototype.isMeshMatcapMaterial=!0;class sW extends Ca{constructor(e){super();this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}sW.prototype.isLineDashedMaterial=!0;const qt={arraySlice:function(n,e,t){return qt.isTypedArray(n)?new n.constructor(n.subarray(e,t!==void 0?t:n.length)):n.slice(e,t)},convertArray:function(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)},isTypedArray:function(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)},getKeyframeOrder:function(n){function e(r,i){return n[r]-n[i]}const t=n.length,s=new Array(t);for(let r=0;r!==t;++r)s[r]=r;return s.sort(e),s},sortedArray:function(n,e,t){const s=n.length,r=new n.constructor(s);for(let i=0,o=0;o!==s;++i){const a=t[i]*e;for(let l=0;l!==e;++l)r[o++]=n[a+l]}return r},flattenJSON:function(n,e,t,s){let r=1,i=n[0];for(;i!==void 0&&i[s]===void 0;)i=n[r++];if(i===void 0)return;let o=i[s];if(o!==void 0)if(Array.isArray(o))do o=i[s],o!==void 0&&(e.push(i.time),t.push.apply(t,o)),i=n[r++];while(i!==void 0);else if(o.toArray!==void 0)do o=i[s],o!==void 0&&(e.push(i.time),o.toArray(t,t.length)),i=n[r++];while(i!==void 0);else do o=i[s],o!==void 0&&(e.push(i.time),t.push(o)),i=n[r++];while(i!==void 0)},subclip:function(n,e,t,s,r=30){const i=n.clone();i.name=e;const o=[];for(let l=0;l<i.tracks.length;++l){const c=i.tracks[l],u=c.getValueSize(),h=[],d=[];for(let p=0;p<c.times.length;++p){const f=c.times[p]*r;if(!(f<t||f>=s)){h.push(c.times[p]);for(let m=0;m<u;++m)d.push(c.values[p*u+m])}}h.length!==0&&(c.times=qt.convertArray(h,c.times.constructor),c.values=qt.convertArray(d,c.values.constructor),o.push(c))}i.tracks=o;let a=1/0;for(let l=0;l<i.tracks.length;++l)a>i.tracks[l].times[0]&&(a=i.tracks[l].times[0]);for(let l=0;l<i.tracks.length;++l)i.tracks[l].shift(-1*a);return i.resetDuration(),i},makeClipAdditive:function(n,e=0,t=n,s=30){s<=0&&(s=30);const r=t.tracks.length,i=e/s;for(let o=0;o<r;++o){const a=t.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=n.tracks.find(function(g){return g.name===a.name&&g.ValueTypeName===l});if(c===void 0)continue;let u=0;const h=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=h/3);let d=0;const p=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(d=p/3);const f=a.times.length-1;let m;if(i<=a.times[0]){const g=u,x=h-u;m=qt.arraySlice(a.values,g,x)}else if(i>=a.times[f]){const g=f*h+u,x=g+h-u;m=qt.arraySlice(a.values,g,x)}else{const g=a.createInterpolant(),x=u,b=h-u;g.evaluate(i),m=qt.arraySlice(g.resultBuffer,x,b)}l==="quaternion"&&new Vn().fromArray(m).normalize().conjugate().toArray(m);const y=c.times.length;for(let g=0;g<y;++g){const x=g*p+d;if(l==="quaternion")Vn.multiplyQuaternionsFlat(c.values,x,m,0,c.values,x);else{const b=p-d*2;for(let w=0;w<b;++w)c.values[x+w]-=m[w]}}}return n.blendMode=ux,n}};class Lr{constructor(e,t,s,r){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=r!==void 0?r:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,r=t[s],i=t[s-1];e:{t:{let o;n:{s:if(!(e<r)){for(let a=s+2;;){if(r===void 0){if(e<i)break s;return s=t.length,this._cachedIndex=s,this.afterEnd_(s-1,e,i)}if(s===a)break;if(i=r,r=t[++s],e<r)break t}o=t.length;break n}if(!(e>=i)){const a=t[1];e<a&&(s=2,i=a);for(let l=s-2;;){if(i===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(s===l)break;if(r=i,i=t[--s-1],e>=i)break t}o=s,s=0;break n}break e}for(;s<o;){const a=s+o>>>1;e<t[a]?o=a:s=a+1}if(r=t[s],i=t[s-1],i===void 0)return this._cachedIndex=0,this.beforeStart_(0,e,r);if(r===void 0)return s=t.length,this._cachedIndex=s,this.afterEnd_(s-1,i,e)}this._cachedIndex=s,this.intervalChanged_(s,i,r)}return this.interpolate_(s,i,e,r)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,r=this.valueSize,i=e*r;for(let o=0;o!==r;++o)t[o]=s[i+o];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}Lr.prototype.beforeStart_=Lr.prototype.copySampleValue_;Lr.prototype.afterEnd_=Lr.prototype.copySampleValue_;class rW extends Lr{constructor(e,t,s,r){super(e,t,s,r);this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Yo,endingEnd:Yo}}intervalChanged_(e,t,s){const r=this.parameterPositions;let i=e-2,o=e+1,a=r[i],l=r[o];if(a===void 0)switch(this.getSettings_().endingStart){case Zo:i=e,a=2*t-s;break;case qc:i=r.length-2,a=t+r[i]-r[i+1];break;default:i=e,a=s}if(l===void 0)switch(this.getSettings_().endingEnd){case Zo:o=e,l=2*s-t;break;case qc:o=1,l=s+r[1]-r[0];break;default:o=e-1,l=t}const c=(s-t)*.5,u=this.valueSize;this._weightPrev=c/(t-a),this._weightNext=c/(l-s),this._offsetPrev=i*u,this._offsetNext=o*u}interpolate_(e,t,s,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(s-t)/(r-t),m=f*f,y=m*f,g=-d*y+2*d*m-d*f,x=(1+d)*y+(-1.5-2*d)*m+(-.5+d)*f+1,b=(-1-p)*y+(1.5+p)*m+.5*f,w=p*y-p*m;for(let C=0;C!==a;++C)i[C]=g*o[u+C]+x*o[c+C]+b*o[l+C]+w*o[h+C];return i}}class Qy extends Lr{constructor(e,t,s,r){super(e,t,s,r)}interpolate_(e,t,s,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=(s-t)/(r-t),h=1-u;for(let d=0;d!==a;++d)i[d]=o[c+d]*h+o[l+d]*u;return i}}class iW extends Lr{constructor(e,t,s,r){super(e,t,s,r)}interpolate_(e){return this.copySampleValue_(e-1)}}class Js{constructor(e,t,s,r){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=qt.convertArray(t,this.TimeBufferType),this.values=qt.convertArray(s,this.ValueBufferType),this.setInterpolation(r||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:qt.convertArray(e.times,Array),values:qt.convertArray(e.values,Array)};const r=e.getInterpolation();r!==e.DefaultInterpolation&&(s.interpolation=r)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new iW(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new Qy(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new rW(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case xl:t=this.InterpolantFactoryMethodDiscrete;break;case Ko:t=this.InterpolantFactoryMethodLinear;break;case Wd:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return xl;case this.InterpolantFactoryMethodLinear:return Ko;case this.InterpolantFactoryMethodSmooth:return Wd}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,r=t.length;s!==r;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,r=t.length;s!==r;++s)t[s]*=e}return this}trim(e,t){const s=this.times,r=s.length;let i=0,o=r-1;for(;i!==r&&s[i]<e;)++i;for(;o!==-1&&s[o]>t;)--o;if(++o,i!==0||o!==r){i>=o&&(o=Math.max(o,1),i=o-1);const a=this.getValueSize();this.times=qt.arraySlice(s,i,o),this.values=qt.arraySlice(this.values,i*a,o*a)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!=0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,r=this.values,i=s.length;i===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==i;a++){const l=s[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(r!==void 0&&qt.isTypedArray(r))for(let a=0,l=r.length;a!==l;++a){const c=r[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=qt.arraySlice(this.times),t=qt.arraySlice(this.values),s=this.getValueSize(),r=this.getInterpolation()===Wd,i=e.length-1;let o=1;for(let a=1;a<i;++a){let l=!1;const c=e[a],u=e[a+1];if(c!==u&&(a!==1||c!==e[0]))if(r)l=!0;else{const h=a*s,d=h-s,p=h+s;for(let f=0;f!==s;++f){const m=t[h+f];if(m!==t[d+f]||m!==t[p+f]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const h=a*s,d=o*s;for(let p=0;p!==s;++p)t[d+p]=t[h+p]}++o}}if(i>0){e[o]=e[i];for(let a=i*s,l=o*s,c=0;c!==s;++c)t[l+c]=t[a+c];++o}return o!==e.length?(this.times=qt.arraySlice(e,0,o),this.values=qt.arraySlice(t,0,o*s)):(this.times=e,this.values=t),this}clone(){const e=qt.arraySlice(this.times,0),t=qt.arraySlice(this.values,0),s=this.constructor,r=new s(this.name,e,t);return r.createInterpolant=this.createInterpolant,r}}Js.prototype.TimeBufferType=Float32Array;Js.prototype.ValueBufferType=Float32Array;Js.prototype.DefaultInterpolation=Ko;class Ra extends Js{}Ra.prototype.ValueTypeName="bool";Ra.prototype.ValueBufferType=Array;Ra.prototype.DefaultInterpolation=xl;Ra.prototype.InterpolantFactoryMethodLinear=void 0;Ra.prototype.InterpolantFactoryMethodSmooth=void 0;class e5 extends Js{}e5.prototype.ValueTypeName="color";class zl extends Js{}zl.prototype.ValueTypeName="number";class oW extends Lr{constructor(e,t,s,r){super(e,t,s,r)}interpolate_(e,t,s,r){const i=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(s-t)/(r-t);let c=e*a;for(let u=c+a;c!==u;c+=4)Vn.slerpFlat(i,0,o,c-a,o,c,l);return i}}class ro extends Js{InterpolantFactoryMethodLinear(e){return new oW(this.times,this.values,this.getValueSize(),e)}}ro.prototype.ValueTypeName="quaternion";ro.prototype.DefaultInterpolation=Ko;ro.prototype.InterpolantFactoryMethodSmooth=void 0;class Ia extends Js{}Ia.prototype.ValueTypeName="string";Ia.prototype.ValueBufferType=Array;Ia.prototype.DefaultInterpolation=xl;Ia.prototype.InterpolantFactoryMethodLinear=void 0;Ia.prototype.InterpolantFactoryMethodSmooth=void 0;class Ul extends Js{}Ul.prototype.ValueTypeName="vector";class Zp{constructor(e,t=-1,s,r=Hd){this.name=e,this.tracks=s,this.duration=t,this.blendMode=r,this.uuid=Ss(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,r=1/(e.fps||1);for(let o=0,a=s.length;o!==a;++o)t.push(lW(s[o]).scale(r));const i=new this(e.name,e.duration,t,e.blendMode);return i.uuid=e.uuid,i}static toJSON(e){const t=[],s=e.tracks,r={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let i=0,o=s.length;i!==o;++i)t.push(Js.toJSON(s[i]));return r}static CreateFromMorphTargetSequence(e,t,s,r){const i=t.length,o=[];for(let a=0;a<i;a++){let l=[],c=[];l.push((a+i-1)%i,a,(a+1)%i),c.push(0,1,0);const u=qt.getKeyframeOrder(l);l=qt.sortedArray(l,1,u),c=qt.sortedArray(c,1,u),!r&&l[0]===0&&(l.push(i),c.push(c[0])),o.push(new zl(".morphTargetInfluences["+t[a].name+"]",l,c).scale(1/s))}return new this(e,-1,o)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const r=e;s=r.geometry&&r.geometry.animations||r.animations}for(let r=0;r<s.length;r++)if(s[r].name===t)return s[r];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const r={},i=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],u=c.name.match(i);if(u&&u.length>1){const h=u[1];let d=r[h];d||(r[h]=d=[]),d.push(c)}}const o=[];for(const a in r)o.push(this.CreateFromMorphTargetSequence(a,r[a],t,s));return o}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(h,d,p,f,m){if(p.length!==0){const y=[],g=[];qt.flattenJSON(p,y,g,f),y.length!==0&&m.push(new h(d,y,g))}},r=[],i=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let m=0;m<d[f].morphTargets.length;m++)p[d[f].morphTargets[m]]=-1;for(const m in p){const y=[],g=[];for(let x=0;x!==d[f].morphTargets.length;++x){const b=d[f];y.push(b.time),g.push(b.morphTarget===m?1:0)}r.push(new zl(".morphTargetInfluence["+m+"]",y,g))}l=p.length*(o||1)}else{const p=".bones["+t[h].name+"]";s(Ul,p+".position",d,"pos",r),s(ro,p+".quaternion",d,"rot",r),s(Ul,p+".scale",d,"scl",r)}}return r.length===0?null:new this(i,l,r,a)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,r=e.length;s!==r;++s){const i=this.tracks[s];t=Math.max(t,i.times[i.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function aW(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return zl;case"vector":case"vector2":case"vector3":case"vector4":return Ul;case"color":return e5;case"quaternion":return ro;case"bool":case"boolean":return Ra;case"string":return Ia}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function lW(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=aW(n.type);if(n.times===void 0){const t=[],s=[];qt.flattenJSON(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const Na={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class cW{constructor(e,t,s){const r=this;let i=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.itemStart=function(u){a++,i===!1&&r.onStart!==void 0&&r.onStart(u,o,a),i=!0},this.itemEnd=function(u){o++,r.onProgress!==void 0&&r.onProgress(u,o,a),o===a&&(i=!1,r.onLoad!==void 0&&r.onLoad())},this.itemError=function(u){r.onError!==void 0&&r.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const p=c[h],f=c[h+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const uW=new cW;class Pr{constructor(e){this.manager=e!==void 0?e:uW,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(r,i){s.load(e,r,t,i)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}const Dr={};class Jp extends Pr{constructor(e){super(e)}load(e,t,s,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=Na.get(e);if(i!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(i),this.manager.itemEnd(e)},0),i;if(Dr[e]!==void 0){Dr[e].push({onLoad:t,onProgress:s,onError:r});return}Dr[e]=[],Dr[e].push({onLoad:t,onProgress:s,onError:r});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});fetch(o).then(a=>{if(a.status===200||a.status===0){a.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received.");const l=Dr[e],c=a.body.getReader(),u=a.headers.get("Content-Length"),h=u?parseInt(u):0,d=h!==0;let p=0;return new ReadableStream({start(f){m();function m(){c.read().then(({done:y,value:g})=>{if(y)f.close();else{p+=g.byteLength;const x=new ProgressEvent("progress",{lengthComputable:d,loaded:p,total:h});for(let b=0,w=l.length;b<w;b++){const C=l[b];C.onProgress&&C.onProgress(x)}f.enqueue(g),m()}})}}})}else throw Error(`fetch for "${a.url}" responded with ${a.status}: ${a.statusText}`)}).then(a=>{const l=new Response(a);switch(this.responseType){case"arraybuffer":return l.arrayBuffer();case"blob":return l.blob();case"document":return l.text().then(c=>new DOMParser().parseFromString(c,this.mimeType));case"json":return l.json();default:return l.text()}}).then(a=>{Na.add(e,a);const l=Dr[e];delete Dr[e];for(let c=0,u=l.length;c<u;c++){const h=l[c];h.onLoad&&h.onLoad(a)}this.manager.itemEnd(e)}).catch(a=>{const l=Dr[e];delete Dr[e];for(let c=0,u=l.length;c<u;c++){const h=l[c];h.onError&&h.onError(a)}this.manager.itemError(e),this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class t5 extends Pr{constructor(e){super(e)}load(e,t,s,r){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=Na.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a=Zc("img");function l(){u(),Na.add(e,this),t&&t(this),i.manager.itemEnd(e)}function c(h){u(),r&&r(h),i.manager.itemError(e),i.manager.itemEnd(e)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.substr(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),i.manager.itemStart(e),a.src=e,a}}class hW extends Pr{constructor(e){super(e)}load(e,t,s,r){const i=new fu,o=new t5(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(u){i.images[c]=u,a++,a===6&&(i.needsUpdate=!0,t&&t(i))},void 0,r)}for(let c=0;c<e.length;++c)l(c);return i}}class Qp extends Pr{constructor(e){super(e)}load(e,t,s,r){const i=new dn,o=new t5(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){i.image=a,i.needsUpdate=!0,t!==void 0&&t(i)},s,r),i}}class Qs extends Ye{constructor(e,t=1){super();this.type="Light",this.color=new Le(e),this.intensity=t}dispose(){}copy(e){return super.copy(e),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}Qs.prototype.isLight=!0;class n5 extends Qs{constructor(e,t,s){super(e,s);this.type="HemisphereLight",this.position.copy(Ye.DefaultUp),this.updateMatrix(),this.groundColor=new Le(t)}copy(e){return Qs.prototype.copy.call(this,e),this.groundColor.copy(e.groundColor),this}}n5.prototype.isHemisphereLight=!0;const s5=new ze,r5=new L,i5=new L;class ef{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new pe(512,512),this.map=null,this.mapPass=null,this.matrix=new ze,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new gu,this._frameExtents=new pe(1,1),this._viewportCount=1,this._viewports=[new $t(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;r5.setFromMatrixPosition(e.matrixWorld),t.position.copy(r5),i5.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(i5),t.updateMatrixWorld(),s5.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(s5),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(t.projectionMatrix),s.multiply(t.matrixWorldInverse)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class o5 extends ef{constructor(){super(new Gn(50,1,.5,500));this.focus=1}updateMatrices(e){const t=this.camera,s=bl*2*e.angle*this.focus,r=this.mapSize.width/this.mapSize.height,i=e.distance||t.far;(s!==t.fov||r!==t.aspect||i!==t.far)&&(t.fov=s,t.aspect=r,t.far=i,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}o5.prototype.isSpotLightShadow=!0;class a5 extends Qs{constructor(e,t,s=0,r=Math.PI/3,i=0,o=1){super(e,t);this.type="SpotLight",this.position.copy(Ye.DefaultUp),this.updateMatrix(),this.target=new Ye,this.distance=s,this.angle=r,this.penumbra=i,this.decay=o,this.shadow=new o5}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}a5.prototype.isSpotLight=!0;const l5=new ze,Vl=new L,tf=new L;class c5 extends ef{constructor(){super(new Gn(90,1,.5,500));this._frameExtents=new pe(4,2),this._viewportCount=6,this._viewports=[new $t(2,1,1,1),new $t(0,1,1,1),new $t(3,1,1,1),new $t(1,1,1,1),new $t(3,0,1,1),new $t(1,0,1,1)],this._cubeDirections=[new L(1,0,0),new L(-1,0,0),new L(0,0,1),new L(0,0,-1),new L(0,1,0),new L(0,-1,0)],this._cubeUps=[new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,1,0),new L(0,0,1),new L(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,r=this.matrix,i=e.distance||s.far;i!==s.far&&(s.far=i,s.updateProjectionMatrix()),Vl.setFromMatrixPosition(e.matrixWorld),s.position.copy(Vl),tf.copy(s.position),tf.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(tf),s.updateMatrixWorld(),r.makeTranslation(-Vl.x,-Vl.y,-Vl.z),l5.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(l5)}}c5.prototype.isPointLightShadow=!0;class u5 extends Qs{constructor(e,t,s=0,r=1){super(e,t);this.type="PointLight",this.distance=s,this.decay=r,this.shadow=new c5}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}u5.prototype.isPointLight=!0;class h5 extends ef{constructor(){super(new Ml(-5,5,5,-5,.5,500))}}h5.prototype.isDirectionalLightShadow=!0;class nf extends Qs{constructor(e,t){super(e,t);this.type="DirectionalLight",this.position.copy(Ye.DefaultUp),this.updateMatrix(),this.target=new Ye,this.shadow=new h5}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}nf.prototype.isDirectionalLight=!0;class d5 extends Qs{constructor(e,t){super(e,t);this.type="AmbientLight"}}d5.prototype.isAmbientLight=!0;class dW extends Qs{constructor(e,t,s=10,r=10){super(e,t);this.type="RectAreaLight",this.width=s,this.height=r}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const t=super.toJSON(e);return t.object.width=this.width,t.object.height=this.height,t}}dW.prototype.isRectAreaLight=!0;class p5{constructor(){this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new L)}set(e){for(let t=0;t<9;t++)this.coefficients[t].copy(e[t]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,t){const s=e.x,r=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.282095),t.addScaledVector(o[1],.488603*r),t.addScaledVector(o[2],.488603*i),t.addScaledVector(o[3],.488603*s),t.addScaledVector(o[4],1.092548*(s*r)),t.addScaledVector(o[5],1.092548*(r*i)),t.addScaledVector(o[6],.315392*(3*i*i-1)),t.addScaledVector(o[7],1.092548*(s*i)),t.addScaledVector(o[8],.546274*(s*s-r*r)),t}getIrradianceAt(e,t){const s=e.x,r=e.y,i=e.z,o=this.coefficients;return t.copy(o[0]).multiplyScalar(.886227),t.addScaledVector(o[1],2*.511664*r),t.addScaledVector(o[2],2*.511664*i),t.addScaledVector(o[3],2*.511664*s),t.addScaledVector(o[4],2*.429043*s*r),t.addScaledVector(o[5],2*.429043*r*i),t.addScaledVector(o[6],.743125*i*i-.247708),t.addScaledVector(o[7],2*.429043*s*i),t.addScaledVector(o[8],.429043*(s*s-r*r)),t}add(e){for(let t=0;t<9;t++)this.coefficients[t].add(e.coefficients[t]);return this}addScaledSH(e,t){for(let s=0;s<9;s++)this.coefficients[s].addScaledVector(e.coefficients[s],t);return this}scale(e){for(let t=0;t<9;t++)this.coefficients[t].multiplyScalar(e);return this}lerp(e,t){for(let s=0;s<9;s++)this.coefficients[s].lerp(e.coefficients[s],t);return this}equals(e){for(let t=0;t<9;t++)if(!this.coefficients[t].equals(e.coefficients[t]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,t=0){const s=this.coefficients;for(let r=0;r<9;r++)s[r].fromArray(e,t+r*3);return this}toArray(e=[],t=0){const s=this.coefficients;for(let r=0;r<9;r++)s[r].toArray(e,t+r*3);return e}static getBasisAt(e,t){const s=e.x,r=e.y,i=e.z;t[0]=.282095,t[1]=.488603*r,t[2]=.488603*i,t[3]=.488603*s,t[4]=1.092548*s*r,t[5]=1.092548*r*i,t[6]=.315392*(3*i*i-1),t[7]=1.092548*s*i,t[8]=.546274*(s*s-r*r)}}p5.prototype.isSphericalHarmonics3=!0;class sf extends Qs{constructor(e=new p5,t=1){super(void 0,t);this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const t=super.toJSON(e);return t.object.sh=this.sh.toArray(),t}}sf.prototype.isLightProbe=!0;class fi{static decodeText(e){if(typeof TextDecoder!="undefined")return new TextDecoder().decode(e);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.substr(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class pW extends Wt{constructor(){super();this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}clone(){return new this.constructor().copy(this)}toJSON(){const e=super.toJSON(this);return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}pW.prototype.isInstancedBufferGeometry=!0;class f5 extends Pr{constructor(e){super(e);typeof createImageBitmap=="undefined"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch=="undefined"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,s,r){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,o=Na.get(e);if(o!==void 0)return i.manager.itemStart(e),setTimeout(function(){t&&t(o),i.manager.itemEnd(e)},0),o;const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader,fetch(e,a).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(i.options,{colorSpaceConversion:"none"}))}).then(function(l){Na.add(e,l),t&&t(l),i.manager.itemEnd(e)}).catch(function(l){r&&r(l),i.manager.itemError(e),i.manager.itemEnd(e)}),i.manager.itemStart(e)}}f5.prototype.isImageBitmapLoader=!0;let Fu;const fW={getContext:function(){return Fu===void 0&&(Fu=new(window.AudioContext||window.webkitAudioContext)),Fu},setContext:function(n){Fu=n}};class mW extends Pr{constructor(e){super(e)}load(e,t,s,r){const i=this,o=new Jp(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{const l=a.slice(0);fW.getContext().decodeAudioData(l,function(u){t(u)})}catch(l){r?r(l):console.error(l),i.manager.itemError(e)}},s,r)}}class gW extends sf{constructor(e,t,s=1){super(void 0,s);const r=new Le().set(e),i=new Le().set(t),o=new L(r.r,r.g,r.b),a=new L(i.r,i.g,i.b),l=Math.sqrt(Math.PI),c=l*Math.sqrt(.75);this.sh.coefficients[0].copy(o).add(a).multiplyScalar(l),this.sh.coefficients[1].copy(o).sub(a).multiplyScalar(c)}}gW.prototype.isHemisphereLightProbe=!0;class xW extends sf{constructor(e,t=1){super(void 0,t);const s=new Le().set(e);this.sh.coefficients[0].set(s.r,s.g,s.b).multiplyScalar(2*Math.sqrt(Math.PI))}}xW.prototype.isAmbientLightProbe=!0;class yW{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=m5(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=m5();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function m5(){return(typeof performance=="undefined"?Date:performance).now()}class vW extends Ye{constructor(e){super();this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class bW{constructor(e,t,s){this.binding=e,this.valueSize=s;let r,i,o;switch(t){case"quaternion":r=this._slerp,i=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":r=this._select,i=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:r=this._lerp,i=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=r,this._mixBufferRegionAdditive=i,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const s=this.buffer,r=this.valueSize,i=e*r+r;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==r;++a)s[i+a]=s[a];o=t}else{o+=t;const a=t/o;this._mixBufferRegion(s,i,0,a,r)}this.cumulativeWeight=o}accumulateAdditive(e){const t=this.buffer,s=this.valueSize,r=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,r,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,s=this.buffer,r=e*t+t,i=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,i<1){const l=t*this._origIndex;this._mixBufferRegion(s,r,l,1-i,t)}o>0&&this._mixBufferRegionAdditive(s,r,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(s[l]!==s[l+t]){a.setValue(s,r);break}}saveOriginalState(){const e=this.binding,t=this.buffer,s=this.valueSize,r=s*this._origIndex;e.getValue(t,r);for(let i=s,o=r;i!==o;++i)t[i]=t[r+i%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let s=e;s<t;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[t+s]=this.buffer[e+s]}_select(e,t,s,r,i){if(r>=.5)for(let o=0;o!==i;++o)e[t+o]=e[s+o]}_slerp(e,t,s,r){Vn.slerpFlat(e,t,e,t,e,s,r)}_slerpAdditive(e,t,s,r,i){const o=this._workIndex*i;Vn.multiplyQuaternionsFlat(e,o,e,t,e,s),Vn.slerpFlat(e,t,e,t,e,o,r)}_lerp(e,t,s,r,i){const o=1-r;for(let a=0;a!==i;++a){const l=t+a;e[l]=e[l]*o+e[s+a]*r}}_lerpAdditive(e,t,s,r,i){for(let o=0;o!==i;++o){const a=t+o;e[a]=e[a]+e[s+o]*r}}}const rf="\\[\\]\\.:\\/",wW=new RegExp("["+rf+"]","g"),of="[^"+rf+"]",_W="[^"+rf.replace("\\.","")+"]",SW=/((?:WC+[\/:])*)/.source.replace("WC",of),TW=/(WCOD+)?/.source.replace("WCOD",_W),EW=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",of),CW=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",of),MW=new RegExp("^"+SW+TW+EW+CW+"$"),AW=["material","materials","bones"];class RW{constructor(e,t,s){const r=s||Nt.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,r)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,r=this._bindings[s];r!==void 0&&r.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let r=this._targetGroup.nCachedObjects_,i=s.length;r!==i;++r)s[r].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class Nt{constructor(e,t,s){this.path=t,this.parsedPath=s||Nt.parseTrackName(t),this.node=Nt.findNode(e,this.parsedPath.nodeName)||e,this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new Nt.Composite(e,t,s):new Nt(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(wW,"")}static parseTrackName(e){const t=MW.exec(e);if(!t)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},r=s.nodeName&&s.nodeName.lastIndexOf(".");if(r!==void 0&&r!==-1){const i=s.nodeName.substring(r+1);AW.indexOf(i)!==-1&&(s.nodeName=s.nodeName.substring(0,r),s.objectName=i)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(!t||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(i){for(let o=0;o<i.length;o++){const a=i[o];if(a.name===t||a.uuid===t)return a;const l=s(a.children);if(l)return l}return null},r=s(e.children);if(r)return r}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)e[t++]=s[r]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)s[r]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)s[r]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let r=0,i=s.length;r!==i;++r)s[r]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,r=t.propertyName;let i=t.propertyIndex;if(e||(e=Nt.findNode(this.rootNode,t.nodeName)||this.rootNode,this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.");return}if(s){let c=t.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[r];if(o===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+r+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(i!==void 0){if(r==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(e.geometry.isBufferGeometry){if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[i]!==void 0&&(i=e.morphTargetDictionary[i])}else{console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.",this);return}}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=i}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=r;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Nt.Composite=RW;Nt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Nt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Nt.prototype.GetterByBindingType=[Nt.prototype._getValue_direct,Nt.prototype._getValue_array,Nt.prototype._getValue_arrayElement,Nt.prototype._getValue_toArray];Nt.prototype.SetterByBindingTypeAndVersioning=[[Nt.prototype._setValue_direct,Nt.prototype._setValue_direct_setNeedsUpdate,Nt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Nt.prototype._setValue_array,Nt.prototype._setValue_array_setNeedsUpdate,Nt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Nt.prototype._setValue_arrayElement,Nt.prototype._setValue_arrayElement_setNeedsUpdate,Nt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Nt.prototype._setValue_fromArray,Nt.prototype._setValue_fromArray_setNeedsUpdate,Nt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class IW{constructor(e,t,s=null,r=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=s,this.blendMode=r;const i=t.tracks,o=i.length,a=new Array(o),l={endingStart:Yo,endingEnd:Yo};for(let c=0;c!==o;++c){const u=i[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=dO,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,s){if(e.fadeOut(t),this.fadeIn(t),s){const r=this._clip.duration,i=e._clip.duration,o=i/r,a=r/i;e.warp(1,o,t),this.warp(a,1,t)}return this}crossFadeTo(e,t,s){return e.crossFadeFrom(this,t,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,s){const r=this._mixer,i=r.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=r._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=i,l[1]=i+s,c[0]=e/o,c[1]=t/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,s,r){if(!this.enabled){this._updateWeight(e);return}const i=this._startTime;if(i!==null){const l=(e-i)*s;if(l<0||s===0)return;this._startTime=null,t=s*l}t*=this._updateTimeScale(e);const o=this._updateTime(t),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case ux:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case Hd:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(o),c[u].accumulate(r,a)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const s=this._weightInterpolant;if(s!==null){const r=s.evaluate(e)[0];t*=r,e>s.parameterPositions[1]&&(this.stopFading(),r===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const s=this._timeScaleInterpolant;s!==null&&(t*=s.evaluate(e)[0],e>s.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t))}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,s=this.loop;let r=this.time+e,i=this._loopCount;const o=s===pO;if(e===0)return i===-1?r:o&&(i&1)==1?t-r:r;if(s===hO){i===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(r>=t)r=t;else if(r<0)r=0;else{this.time=r;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(i===-1&&(e>=0?(i=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),r>=t||r<0){const a=Math.floor(r/t);r-=t*a,i+=Math.abs(a);const l=this.repetitions-i;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,r=e>0?t:0,this.time=r,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=i,this.time=r,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=r;if(o&&(i&1)==1)return t-r}return r}_setEndings(e,t,s){const r=this._interpolantSettings;s?(r.endingStart=Zo,r.endingEnd=Zo):(e?r.endingStart=this.zeroSlopeAtStart?Zo:Yo:r.endingStart=qc,t?r.endingEnd=this.zeroSlopeAtEnd?Zo:Yo:r.endingEnd=qc)}_scheduleFading(e,t,s){const r=this._mixer,i=r.time;let o=this._weightInterpolant;o===null&&(o=r._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=i,l[0]=t,a[1]=i+e,l[1]=s,this}}class NW extends qi{constructor(e){super();this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const s=e._localRoot||this._root,r=e._clip.tracks,i=r.length,o=e._propertyBindings,a=e._interpolants,l=s.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==i;++h){const d=r[h],p=d.name;let f=u[p];if(f!==void 0)o[h]=f;else{if(f=o[h],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const m=t&&t._propertyBindings[h].binding.parsedPath;f=new bW(Nt.create(s,p,m),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),o[h]=f}a[h].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,r=e._clip.uuid,i=this._actionsByClip[r];this._bindAction(e,i&&i.knownActions[0]),this._addInactiveAction(e,r,s)}const t=e._propertyBindings;for(let s=0,r=t.length;s!==r;++s){const i=t[s];i.useCount++==0&&(this._lendBinding(i),i.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let s=0,r=t.length;s!==r;++s){const i=t[s];--i.useCount==0&&(i.restoreOriginalState(),this._takeBackBinding(i))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,s){const r=this._actions,i=this._actionsByClip;let o=i[t];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,i[t]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=r.length,r.push(e),o.actionByRoot[s]=e}_removeInactiveAction(e){const t=this._actions,s=t[t.length-1],r=e._cacheIndex;s._cacheIndex=r,t[r]=s,t.pop(),e._cacheIndex=null;const i=e._clip.uuid,o=this._actionsByClip,a=o[i],l=a.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=a.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete o[i],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let s=0,r=t.length;s!==r;++s){const i=t[s];--i.referenceCount==0&&this._removeInactiveBinding(i)}}_lendAction(e){const t=this._actions,s=e._cacheIndex,r=this._nActiveActions++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_takeBackAction(e){const t=this._actions,s=e._cacheIndex,r=--this._nActiveActions,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_addInactiveBinding(e,t,s){const r=this._bindingsByRootAndName,i=this._bindings;let o=r[t];o===void 0&&(o={},r[t]=o),o[s]=e,e._cacheIndex=i.length,i.push(e)}_removeInactiveBinding(e){const t=this._bindings,s=e.binding,r=s.rootNode.uuid,i=s.path,o=this._bindingsByRootAndName,a=o[r],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete a[i],Object.keys(a).length===0&&delete o[r]}_lendBinding(e){const t=this._bindings,s=e._cacheIndex,r=this._nActiveBindings++,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_takeBackBinding(e){const t=this._bindings,s=e._cacheIndex,r=--this._nActiveBindings,i=t[r];e._cacheIndex=r,t[r]=e,i._cacheIndex=s,t[s]=i}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let s=e[t];return s===void 0&&(s=new Qy(new Float32Array(2),new Float32Array(2),1,this._controlInterpolantsResultBuffer),s.__cacheIndex=t,e[t]=s),s}_takeBackControlInterpolant(e){const t=this._controlInterpolants,s=e.__cacheIndex,r=--this._nActiveControlInterpolants,i=t[r];e.__cacheIndex=r,t[r]=e,i.__cacheIndex=s,t[s]=i}clipAction(e,t,s){const r=t||this._root,i=r.uuid;let o=typeof e=="string"?Zp.findByName(r,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(s===void 0&&(o!==null?s=o.blendMode:s=Hd),l!==void 0){const h=l.actionByRoot[i];if(h!==void 0&&h.blendMode===s)return h;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const u=new IW(this,o,t,s);return this._bindAction(u,c),this._addInactiveAction(u,a,i),u}existingAction(e,t){const s=t||this._root,r=s.uuid,i=typeof e=="string"?Zp.findByName(s,e):e,o=i?i.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[r]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let s=t-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const t=this._actions,s=this._nActiveActions,r=this.time+=e,i=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==s;++c)t[c]._update(r,e,i,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,s=e.uuid,r=this._actionsByClip,i=r[s];if(i!==void 0){const o=i.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete r[s]}}uncacheRoot(e){const t=e.uuid,s=this._actionsByClip;for(const o in s){const a=s[o].actionByRoot,l=a[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const r=this._bindingsByRootAndName,i=r[t];if(i!==void 0)for(const o in i){const a=i[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,t){const s=this.existingAction(e,t);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}NW.prototype._controlInterpolantsResultBuffer=new Float32Array(1);class LW extends ba{constructor(e,t,s=1){super(e,t);this.meshPerAttribute=s}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const t=super.clone(e);return t.meshPerAttribute=this.meshPerAttribute,t}toJSON(e){const t=super.toJSON(e);return t.isInstancedInterleavedBuffer=!0,t.meshPerAttribute=this.meshPerAttribute,t}}LW.prototype.isInstancedInterleavedBuffer=!0;const mi=new L,Ou=new ze,af=new ze;class PW extends Au{constructor(e){const t=g5(e),s=new Wt,r=[],i=[],o=new Le(0,0,1),a=new Le(0,1,0);for(let c=0;c<t.length;c++){const u=t[c];u.parent&&u.parent.isBone&&(r.push(0,0,0),r.push(0,0,0),i.push(o.r,o.g,o.b),i.push(a.r,a.g,a.b))}s.setAttribute("position",new tn(r,3)),s.setAttribute("color",new tn(i,3));const l=new Ca({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(s,l);this.type="SkeletonHelper",this.isSkeletonHelper=!0,this.root=e,this.bones=t,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const t=this.bones,s=this.geometry,r=s.getAttribute("position");af.copy(this.root.matrixWorld).invert();for(let i=0,o=0;i<t.length;i++){const a=t[i];a.parent&&a.parent.isBone&&(Ou.multiplyMatrices(af,a.matrixWorld),mi.setFromMatrixPosition(Ou),r.setXYZ(o,mi.x,mi.y,mi.z),Ou.multiplyMatrices(af,a.parent.matrixWorld),mi.setFromMatrixPosition(Ou),r.setXYZ(o+1,mi.x,mi.y,mi.z),o+=2)}s.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}}function g5(n){const e=[];n&&n.isBone&&e.push(n);for(let t=0;t<n.children.length;t++)e.push.apply(e,g5(n.children[t]));return e}class DW extends Au{constructor(e=10,t=10,s=4473924,r=8947848){s=new Le(s),r=new Le(r);const i=t/2,o=e/t,a=e/2,l=[],c=[];for(let d=0,p=0,f=-a;d<=t;d++,f+=o){l.push(-a,0,f,a,0,f),l.push(f,0,-a,f,0,a);const m=d===i?s:r;m.toArray(c,p),p+=3,m.toArray(c,p),p+=3,m.toArray(c,p),p+=3,m.toArray(c,p),p+=3}const u=new Wt;u.setAttribute("position",new tn(l,3)),u.setAttribute("color",new tn(c,3));const h=new Ca({vertexColors:!0,toneMapped:!1});super(u,h);this.type="GridHelper"}}const kW=new Float32Array(1);new Int32Array(kW.buffer);Cs.create=function(n,e){return console.log("THREE.Curve.create() has been deprecated"),n.prototype=Object.create(Cs.prototype),n.prototype.constructor=n,n.prototype.getPoint=e,n};jp.prototype.fromPoints=function(n){return console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."),this.setFromPoints(n)};DW.prototype.setColors=function(){console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")};PW.prototype.update=function(){console.error("THREE.SkeletonHelper: update() no longer needs to be called.")};Pr.prototype.extractUrlBase=function(n){return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."),fi.extractUrlBase(n)};Pr.Handlers={add:function(){console.error("THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.")},get:function(){console.error("THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.")}};jt.prototype.center=function(n){return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."),this.getCenter(n)};jt.prototype.empty=function(){return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),this.isEmpty()};jt.prototype.isIntersectionBox=function(n){return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};jt.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};jt.prototype.size=function(n){return console.warn("THREE.Box3: .size() has been renamed to .getSize()."),this.getSize(n)};Zi.prototype.empty=function(){return console.warn("THREE.Sphere: .empty() has been renamed to .isEmpty()."),this.isEmpty()};gu.prototype.setFromMatrix=function(n){return console.warn("THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix()."),this.setFromProjectionMatrix(n)};En.prototype.flattenToArrayOffset=function(n,e){return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)};En.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};En.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")};En.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead."),n.applyMatrix3(this)};En.prototype.applyToVector3Array=function(){console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")};En.prototype.getInverse=function(n){return console.warn("THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};ze.prototype.extractPosition=function(n){return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),this.copyPosition(n)};ze.prototype.flattenToArrayOffset=function(n,e){return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."),this.toArray(n,e)};ze.prototype.getPosition=function(){return console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),new L().setFromMatrixColumn(this,3)};ze.prototype.setRotationFromQuaternion=function(n){return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),this.makeRotationFromQuaternion(n)};ze.prototype.multiplyToArray=function(){console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")};ze.prototype.multiplyVector3=function(n){return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};ze.prototype.multiplyVector4=function(n){return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};ze.prototype.multiplyVector3Array=function(){console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")};ze.prototype.rotateAxis=function(n){console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),n.transformDirection(this)};ze.prototype.crossVector=function(n){return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};ze.prototype.translate=function(){console.error("THREE.Matrix4: .translate() has been removed.")};ze.prototype.rotateX=function(){console.error("THREE.Matrix4: .rotateX() has been removed.")};ze.prototype.rotateY=function(){console.error("THREE.Matrix4: .rotateY() has been removed.")};ze.prototype.rotateZ=function(){console.error("THREE.Matrix4: .rotateZ() has been removed.")};ze.prototype.rotateByAxis=function(){console.error("THREE.Matrix4: .rotateByAxis() has been removed.")};ze.prototype.applyToBufferAttribute=function(n){return console.warn("THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead."),n.applyMatrix4(this)};ze.prototype.applyToVector3Array=function(){console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")};ze.prototype.makeFrustum=function(n,e,t,s,r,i){return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."),this.makePerspective(n,e,s,t,r,i)};ze.prototype.getInverse=function(n){return console.warn("THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead."),this.copy(n).invert()};Nr.prototype.isIntersectionLine=function(n){return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),this.intersectsLine(n)};Vn.prototype.multiplyVector3=function(n){return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),n.applyQuaternion(this)};Vn.prototype.inverse=function(){return console.warn("THREE.Quaternion: .inverse() has been renamed to invert()."),this.invert()};sa.prototype.isIntersectionBox=function(n){return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),this.intersectsBox(n)};sa.prototype.isIntersectionPlane=function(n){return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),this.intersectsPlane(n)};sa.prototype.isIntersectionSphere=function(n){return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),this.intersectsSphere(n)};on.prototype.area=function(){return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."),this.getArea()};on.prototype.barycoordFromPoint=function(n,e){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),this.getBarycoord(n,e)};on.prototype.midpoint=function(n){return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."),this.getMidpoint(n)};on.prototypenormal=function(n){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),this.getNormal(n)};on.prototype.plane=function(n){return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."),this.getPlane(n)};on.barycoordFromPoint=function(n,e,t,s,r){return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."),on.getBarycoord(n,e,t,s,r)};on.normal=function(n,e,t,s){return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."),on.getNormal(n,e,t,s)};$l.prototype.extractAllPoints=function(n){return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."),this.extractPoints(n)};$l.prototype.extrude=function(n){return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."),new Aa(this,n)};$l.prototype.makeGeometry=function(n){return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."),new Yp(this,n)};pe.prototype.fromAttribute=function(n,e,t){return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)};pe.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};pe.prototype.lengthManhattan=function(){return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};L.prototype.setEulerFromRotationMatrix=function(){console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")};L.prototype.setEulerFromQuaternion=function(){console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")};L.prototype.getPositionFromMatrix=function(n){return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),this.setFromMatrixPosition(n)};L.prototype.getScaleFromMatrix=function(n){return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),this.setFromMatrixScale(n)};L.prototype.getColumnFromMatrix=function(n,e){return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),this.setFromMatrixColumn(e,n)};L.prototype.applyProjection=function(n){return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."),this.applyMatrix4(n)};L.prototype.fromAttribute=function(n,e,t){return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)};L.prototype.distanceToManhattan=function(n){return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."),this.manhattanDistanceTo(n)};L.prototype.lengthManhattan=function(){return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};$t.prototype.fromAttribute=function(n,e,t){return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."),this.fromBufferAttribute(n,e,t)};$t.prototype.lengthManhattan=function(){return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."),this.manhattanLength()};Ye.prototype.getChildByName=function(n){return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),this.getObjectByName(n)};Ye.prototype.renderDepth=function(){console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")};Ye.prototype.translate=function(n,e){return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),this.translateOnAxis(e,n)};Ye.prototype.getWorldRotation=function(){console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")};Ye.prototype.applyMatrix=function(n){return console.warn("THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(Ye.prototype,{eulerOrder:{get:function(){return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order},set:function(n){console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),this.rotation.order=n}},useQuaternion:{get:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")},set:function(){console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")}}});fn.prototype.setDrawMode=function(){console.error("THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")};Object.defineProperties(fn.prototype,{drawMode:{get:function(){return console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode."),fO},set:function(){console.error("THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.")}}});Pp.prototype.initBones=function(){console.error("THREE.SkinnedMesh: initBones() has been removed.")};Gn.prototype.setLens=function(n,e){console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."),e!==void 0&&(this.filmGauge=e),this.setFocalLength(n)};Object.defineProperties(Qs.prototype,{onlyShadow:{set:function(){console.warn("THREE.Light: .onlyShadow has been removed.")}},shadowCameraFov:{set:function(n){console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),this.shadow.camera.fov=n}},shadowCameraLeft:{set:function(n){console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),this.shadow.camera.left=n}},shadowCameraRight:{set:function(n){console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),this.shadow.camera.right=n}},shadowCameraTop:{set:function(n){console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),this.shadow.camera.top=n}},shadowCameraBottom:{set:function(n){console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),this.shadow.camera.bottom=n}},shadowCameraNear:{set:function(n){console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),this.shadow.camera.near=n}},shadowCameraFar:{set:function(n){console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),this.shadow.camera.far=n}},shadowCameraVisible:{set:function(){console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")}},shadowBias:{set:function(n){console.warn("THREE.Light: .shadowBias is now .shadow.bias."),this.shadow.bias=n}},shadowDarkness:{set:function(){console.warn("THREE.Light: .shadowDarkness has been removed.")}},shadowMapWidth:{set:function(n){console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),this.shadow.mapSize.width=n}},shadowMapHeight:{set:function(n){console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),this.shadow.mapSize.height=n}}});Object.defineProperties(en.prototype,{length:{get:function(){return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."),this.array.length}},dynamic:{get:function(){return console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.usage===Kc},set:function(){console.warn("THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead."),this.setUsage(Kc)}}});en.prototype.setDynamic=function(n){return console.warn("THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?Kc:yl),this};en.prototype.copyIndicesArray=function(){console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")},en.prototype.setArray=function(){console.error("THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Wt.prototype.addIndex=function(n){console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),this.setIndex(n)};Wt.prototype.addAttribute=function(n,e){return console.warn("THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute()."),!(e&&e.isBufferAttribute)&&!(e&&e.isInterleavedBufferAttribute)?(console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),this.setAttribute(n,new en(arguments[1],arguments[2]))):n==="index"?(console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),this.setIndex(e),this):this.setAttribute(n,e)};Wt.prototype.addDrawCall=function(n,e,t){t!==void 0&&console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),this.addGroup(n,e)};Wt.prototype.clearDrawCalls=function(){console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),this.clearGroups()};Wt.prototype.computeOffsets=function(){console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")};Wt.prototype.removeAttribute=function(n){return console.warn("THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute()."),this.deleteAttribute(n)};Wt.prototype.applyMatrix=function(n){return console.warn("THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4()."),this.applyMatrix4(n)};Object.defineProperties(Wt.prototype,{drawcalls:{get:function(){return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),this.groups}},offsets:{get:function(){return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),this.groups}}});ba.prototype.setDynamic=function(n){return console.warn("THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead."),this.setUsage(n===!0?Kc:yl),this};ba.prototype.setArray=function(){console.error("THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers")};Aa.prototype.getArrays=function(){console.error("THREE.ExtrudeGeometry: .getArrays() has been removed.")};Aa.prototype.addShapeList=function(){console.error("THREE.ExtrudeGeometry: .addShapeList() has been removed.")};Aa.prototype.addShape=function(){console.error("THREE.ExtrudeGeometry: .addShape() has been removed.")};wu.prototype.dispose=function(){console.error("THREE.Scene: .dispose() has been removed.")};Object.defineProperties(pn.prototype,{wrapAround:{get:function(){console.warn("THREE.Material: .wrapAround has been removed.")},set:function(){console.warn("THREE.Material: .wrapAround has been removed.")}},overdraw:{get:function(){console.warn("THREE.Material: .overdraw has been removed.")},set:function(){console.warn("THREE.Material: .overdraw has been removed.")}},wrapRGB:{get:function(){return console.warn("THREE.Material: .wrapRGB has been removed."),new Le}},shading:{get:function(){console.error("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead.")},set:function(n){console.warn("THREE."+this.type+": .shading has been removed. Use the boolean .flatShading instead."),this.flatShading=n===W4}},stencilMask:{get:function(){return console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask},set:function(n){console.warn("THREE."+this.type+": .stencilMask has been removed. Use .stencilFuncMask instead."),this.stencilFuncMask=n}},vertexTangents:{get:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")},set:function(){console.warn("THREE."+this.type+": .vertexTangents has been removed.")}}});Object.defineProperties(Ji.prototype,{derivatives:{get:function(){return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives},set:function(n){console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),this.extensions.derivatives=n}}});Lt.prototype.clearTarget=function(n,e,t,s){console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."),this.setRenderTarget(n),this.clear(e,t,s)};Lt.prototype.animate=function(n){console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."),this.setAnimationLoop(n)};Lt.prototype.getCurrentRenderTarget=function(){return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."),this.getRenderTarget()};Lt.prototype.getMaxAnisotropy=function(){return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."),this.capabilities.getMaxAnisotropy()};Lt.prototype.getPrecision=function(){return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."),this.capabilities.precision};Lt.prototype.resetGLState=function(){return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."),this.state.reset()};Lt.prototype.supportsFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),this.extensions.get("OES_texture_float")};Lt.prototype.supportsHalfFloatTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),this.extensions.get("OES_texture_half_float")};Lt.prototype.supportsStandardDerivatives=function(){return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),this.extensions.get("OES_standard_derivatives")};Lt.prototype.supportsCompressedTextureS3TC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),this.extensions.get("WEBGL_compressed_texture_s3tc")};Lt.prototype.supportsCompressedTexturePVRTC=function(){return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),this.extensions.get("WEBGL_compressed_texture_pvrtc")};Lt.prototype.supportsBlendMinMax=function(){return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),this.extensions.get("EXT_blend_minmax")};Lt.prototype.supportsVertexTextures=function(){return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."),this.capabilities.vertexTextures};Lt.prototype.supportsInstancedArrays=function(){return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),this.extensions.get("ANGLE_instanced_arrays")};Lt.prototype.enableScissorTest=function(n){console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),this.setScissorTest(n)};Lt.prototype.initMaterial=function(){console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")};Lt.prototype.addPrePlugin=function(){console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")};Lt.prototype.addPostPlugin=function(){console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")};Lt.prototype.updateShadowMap=function(){console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")};Lt.prototype.setFaceCulling=function(){console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")};Lt.prototype.allocTextureUnit=function(){console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.")};Lt.prototype.setTexture=function(){console.warn("THREE.WebGLRenderer: .setTexture() has been removed.")};Lt.prototype.setTexture2D=function(){console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.")};Lt.prototype.setTextureCube=function(){console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.")};Lt.prototype.getActiveMipMapLevel=function(){return console.warn("THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel()."),this.getActiveMipmapLevel()};Object.defineProperties(Lt.prototype,{shadowMapEnabled:{get:function(){return this.shadowMap.enabled},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),this.shadowMap.enabled=n}},shadowMapType:{get:function(){return this.shadowMap.type},set:function(n){console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),this.shadowMap.type=n}},shadowMapCullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")}},context:{get:function(){return console.warn("THREE.WebGLRenderer: .context has been removed. Use .getContext() instead."),this.getContext()}},vr:{get:function(){return console.warn("THREE.WebGLRenderer: .vr has been renamed to .xr"),this.xr}},gammaInput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead."),!1},set:function(){console.warn("THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.")}},gammaOutput:{get:function(){return console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),!1},set:function(n){console.warn("THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead."),this.outputEncoding=n===!0?ti:Jn}},toneMappingWhitePoint:{get:function(){return console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed."),1},set:function(){console.warn("THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.")}}});Object.defineProperties(xy.prototype,{cullFace:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")}},renderReverseSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")}},renderSingleSided:{get:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")},set:function(){console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")}}});Object.defineProperties(Ts.prototype,{wrapS:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),this.texture.wrapS=n}},wrapT:{get:function(){return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT},set:function(n){console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),this.texture.wrapT=n}},magFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),this.texture.magFilter=n}},minFilter:{get:function(){return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter},set:function(n){console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),this.texture.minFilter=n}},anisotropy:{get:function(){return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy},set:function(n){console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),this.texture.anisotropy=n}},offset:{get:function(){return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset},set:function(n){console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),this.texture.offset=n}},repeat:{get:function(){return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat},set:function(n){console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),this.texture.repeat=n}},format:{get:function(){return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format},set:function(n){console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),this.texture.format=n}},type:{get:function(){return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type},set:function(n){console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),this.texture.type=n}},generateMipmaps:{get:function(){return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps},set:function(n){console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),this.texture.generateMipmaps=n}}});vW.prototype.load=function(n){console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");const e=this;return new mW().load(n,function(s){e.setBuffer(s)}),this};wp.prototype.updateCubeMap=function(n,e){return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."),this.update(n,e)};wp.prototype.clear=function(n,e,t,s){return console.warn("THREE.CubeCamera: .clear() is now .renderTarget.clear()."),this.renderTarget.clear(n,e,t,s)};Qo.crossOrigin=void 0;Qo.loadTexture=function(n,e,t,s){console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");const r=new Qp;r.setCrossOrigin(this.crossOrigin);const i=r.load(n,t,void 0,s);return e&&(i.mapping=e),i};Qo.loadTextureCube=function(n,e,t,s){console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");const r=new hW;r.setCrossOrigin(this.crossOrigin);const i=r.load(n,t,void 0,s);return e&&(i.mapping=e),i};Qo.loadCompressedTexture=function(){console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")};Qo.loadCompressedTextureCube=function(){console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")};typeof __THREE_DEVTOOLS__!="undefined"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Fd}}));typeof window!="undefined"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Fd);class $W extends Pr{constructor(e){super(e);this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new zW(t)}),this.register(function(t){return new XW(t)}),this.register(function(t){return new jW(t)}),this.register(function(t){return new UW(t)}),this.register(function(t){return new VW(t)}),this.register(function(t){return new GW(t)}),this.register(function(t){return new WW(t)}),this.register(function(t){return new HW(t)}),this.register(function(t){return new OW(t)}),this.register(function(t){return new qW(t)})}load(e,t,s,r){const i=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=fi.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){r?r(c):console.error(c),i.manager.itemError(e),i.manager.itemEnd(e)},l=new Jp(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{i.parse(c,o,function(u){t(u),i.manager.itemEnd(e)},a)}catch(u){a(u)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,r){let i;const o={},a={};if(typeof e=="string")i=e;else if(fi.decodeText(new Uint8Array(e,0,4))===x5){try{o[bt.KHR_BINARY_GLTF]=new KW(e)}catch(h){r&&r(h);return}i=o[bt.KHR_BINARY_GLTF].content}else i=fi.decodeText(new Uint8Array(e));const l=JSON.parse(i);if(l.asset===void 0||l.asset.version[0]<2){r&&r(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new aH(l,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const h=this.pluginCallbacks[u](c);a[h.name]=h,o[h.name]=!0}if(l.extensionsUsed)for(let u=0;u<l.extensionsUsed.length;++u){const h=l.extensionsUsed[u],d=l.extensionsRequired||[];switch(h){case bt.KHR_MATERIALS_UNLIT:o[h]=new BW;break;case bt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:o[h]=new JW;break;case bt.KHR_DRACO_MESH_COMPRESSION:o[h]=new YW(l,this.dracoLoader);break;case bt.KHR_TEXTURE_TRANSFORM:o[h]=new ZW;break;case bt.KHR_MESH_QUANTIZATION:o[h]=new QW;break;default:d.indexOf(h)>=0&&a[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}c.setExtensions(o),c.setPlugins(a),c.parse(s,r)}parseAsync(e,t){const s=this;return new Promise(function(r,i){s.parse(e,t,r,i)})}}function FW(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const bt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class OW{constructor(e){this.parser=e,this.name=bt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,r=t.length;s<r;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let r=t.cache.get(s);if(r)return r;const i=t.json,l=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let c;const u=new Le(16777215);l.color!==void 0&&u.fromArray(l.color);const h=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new nf(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new u5(u),c.distance=h;break;case"spot":c=new a5(u),c.distance=h,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),r=Promise.resolve(c),t.cache.add(s,r),r}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return s._getNodeRef(t.cache,a,l)})}}class BW{constructor(){this.name=bt.KHR_MATERIALS_UNLIT}getMaterialType(){return Ks}extendParams(e,t,s){const r=[];e.color=new Le(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const o=i.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}i.baseColorTexture!==void 0&&r.push(s.assignTexture(e,"map",i.baseColorTexture))}return Promise.all(r)}}class zW{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:so}extendMaterialParams(e,t){const s=this.parser,r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],o=r.extensions[this.name];if(o.clearcoatFactor!==void 0&&(t.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new pe(a,a)}return Promise.all(i)}}class UW{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:so}extendMaterialParams(e,t){const s=this.parser,r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new Le(0,0,0),t.sheenRoughness=0,t.sheen=1;const o=r.extensions[this.name];return o.sheenColorFactor!==void 0&&t.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",o.sheenColorTexture)),o.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(i)}}class VW{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:so}extendMaterialParams(e,t){const s=this.parser,r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],o=r.extensions[this.name];return o.transmissionFactor!==void 0&&(t.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",o.transmissionTexture)),Promise.all(i)}}class GW{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:so}extendMaterialParams(e,t){const s=this.parser,r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],o=r.extensions[this.name];t.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",o.thicknessTexture)),t.attenuationDistance=o.attenuationDistance||0;const a=o.attenuationColor||[1,1,1];return t.attenuationColor=new Le(a[0],a[1],a[2]),Promise.all(i)}}class WW{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:so}extendMaterialParams(e,t){const r=this.parser.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=r.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class HW{constructor(e){this.parser=e,this.name=bt.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:so}extendMaterialParams(e,t){const s=this.parser,r=s.json.materials[e];if(!r.extensions||!r.extensions[this.name])return Promise.resolve();const i=[],o=r.extensions[this.name];t.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return t.specularColor=new Le(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",o.specularColorTexture).then(function(l){l.encoding=ti})),Promise.all(i)}}class XW{constructor(e){this.parser=e,this.name=bt.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,r=s.textures[e];if(!r.extensions||!r.extensions[this.name])return null;const i=r.extensions[this.name],o=s.images[i.source],a=t.options.ktx2Loader;if(!a){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,o,a)}}class jW{constructor(e){this.parser=e,this.name=bt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,r=s.json,i=r.textures[e];if(!i.extensions||!i.extensions[t])return null;const o=i.extensions[t],a=r.images[o.source];let l=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,a,l);if(r.extensionsRequired&&r.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class qW{constructor(e){this.name=bt.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const r=s.extensions[this.name],i=this.parser.getDependency("buffer",r.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return Promise.all([i,o.ready]).then(function(a){const l=r.byteOffset||0,c=r.byteLength||0,u=r.count,h=r.byteStride,d=new ArrayBuffer(u*h),p=new Uint8Array(a[0],l,c);return o.decodeGltfBuffer(new Uint8Array(d),u,h,p,r.mode,r.filter),d})}else return null}}const x5="glTF",Gl=12,y5={JSON:1313821514,BIN:5130562};class KW{constructor(e){this.name=bt.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,Gl);if(this.header={magic:fi.decodeText(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==x5)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const s=this.header.length-Gl,r=new DataView(e,Gl);let i=0;for(;i<s;){const o=r.getUint32(i,!0);i+=4;const a=r.getUint32(i,!0);if(i+=4,a===y5.JSON){const l=new Uint8Array(e,Gl+i,o);this.content=fi.decodeText(l)}else if(a===y5.BIN){const l=Gl+i;this.body=e.slice(l,l+o)}i+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class YW{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=bt.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,r=this.dracoLoader,i=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const u in o){const h=cf[u]||u.toLowerCase();a[h]=o[u]}for(const u in e.attributes){const h=cf[u]||u.toLowerCase();if(o[u]!==void 0){const d=s.accessors[e.attributes[u]],p=Wl[d.componentType];c[h]=p,l[h]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(u){return new Promise(function(h){r.decodeDracoFile(u,function(d){for(const p in d.attributes){const f=d.attributes[p],m=l[p];m!==void 0&&(f.normalized=m)}h(d)},a,c)})})}}class ZW{constructor(){this.name=bt.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return t.texCoord!==void 0&&console.warn('THREE.GLTFLoader: Custom UV sets in "'+this.name+'" extension not yet supported.'),t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class lf extends no{constructor(e){super();this.isGLTFSpecularGlossinessMaterial=!0;const t=["#ifdef USE_SPECULARMAP","	uniform sampler2D specularMap;","#endif"].join(`
`),s=["#ifdef USE_GLOSSINESSMAP","	uniform sampler2D glossinessMap;","#endif"].join(`
`),r=["vec3 specularFactor = specular;","#ifdef USE_SPECULARMAP","	vec4 texelSpecular = texture2D( specularMap, vUv );","	texelSpecular = sRGBToLinear( texelSpecular );","	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture","	specularFactor *= texelSpecular.rgb;","#endif"].join(`
`),i=["float glossinessFactor = glossiness;","#ifdef USE_GLOSSINESSMAP","	vec4 texelGlossiness = texture2D( glossinessMap, vUv );","	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture","	glossinessFactor *= texelGlossiness.a;","#endif"].join(`
`),o=["PhysicalMaterial material;","material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );","vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );","float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );","material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.","material.roughness += geometryRoughness;","material.roughness = min( material.roughness, 1.0 );","material.specularColor = specularFactor;"].join(`
`),a={specular:{value:new Le().setHex(16777215)},glossiness:{value:1},specularMap:{value:null},glossinessMap:{value:null}};this._extraUniforms=a,this.onBeforeCompile=function(l){for(const c in a)l.uniforms[c]=a[c];l.fragmentShader=l.fragmentShader.replace("uniform float roughness;","uniform vec3 specular;").replace("uniform float metalness;","uniform float glossiness;").replace("#include <roughnessmap_pars_fragment>",t).replace("#include <metalnessmap_pars_fragment>",s).replace("#include <roughnessmap_fragment>",r).replace("#include <metalnessmap_fragment>",i).replace("#include <lights_physical_fragment>",o)},Object.defineProperties(this,{specular:{get:function(){return a.specular.value},set:function(l){a.specular.value=l}},specularMap:{get:function(){return a.specularMap.value},set:function(l){a.specularMap.value=l,l?this.defines.USE_SPECULARMAP="":delete this.defines.USE_SPECULARMAP}},glossiness:{get:function(){return a.glossiness.value},set:function(l){a.glossiness.value=l}},glossinessMap:{get:function(){return a.glossinessMap.value},set:function(l){a.glossinessMap.value=l,l?(this.defines.USE_GLOSSINESSMAP="",this.defines.USE_UV=""):(delete this.defines.USE_GLOSSINESSMAP,delete this.defines.USE_UV)}}}),delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this.setValues(e)}copy(e){return super.copy(e),this.specularMap=e.specularMap,this.specular.copy(e.specular),this.glossinessMap=e.glossinessMap,this.glossiness=e.glossiness,delete this.metalness,delete this.roughness,delete this.metalnessMap,delete this.roughnessMap,this}}class JW{constructor(){this.name=bt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,this.specularGlossinessParams=["color","map","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","displacementMap","displacementScale","displacementBias","specularMap","specular","glossinessMap","glossiness","alphaMap","envMap","envMapIntensity","refractionRatio"]}getMaterialType(){return lf}extendParams(e,t,s){const r=t.extensions[this.name];e.color=new Le(1,1,1),e.opacity=1;const i=[];if(Array.isArray(r.diffuseFactor)){const o=r.diffuseFactor;e.color.fromArray(o),e.opacity=o[3]}if(r.diffuseTexture!==void 0&&i.push(s.assignTexture(e,"map",r.diffuseTexture)),e.emissive=new Le(0,0,0),e.glossiness=r.glossinessFactor!==void 0?r.glossinessFactor:1,e.specular=new Le(1,1,1),Array.isArray(r.specularFactor)&&e.specular.fromArray(r.specularFactor),r.specularGlossinessTexture!==void 0){const o=r.specularGlossinessTexture;i.push(s.assignTexture(e,"glossinessMap",o)),i.push(s.assignTexture(e,"specularMap",o))}return Promise.all(i)}createMaterial(e){const t=new lf(e);return t.fog=!0,t.color=e.color,t.map=e.map===void 0?null:e.map,t.lightMap=null,t.lightMapIntensity=1,t.aoMap=e.aoMap===void 0?null:e.aoMap,t.aoMapIntensity=1,t.emissive=e.emissive,t.emissiveIntensity=1,t.emissiveMap=e.emissiveMap===void 0?null:e.emissiveMap,t.bumpMap=e.bumpMap===void 0?null:e.bumpMap,t.bumpScale=1,t.normalMap=e.normalMap===void 0?null:e.normalMap,t.normalMapType=ji,e.normalScale&&(t.normalScale=e.normalScale),t.displacementMap=null,t.displacementScale=1,t.displacementBias=0,t.specularMap=e.specularMap===void 0?null:e.specularMap,t.specular=e.specular,t.glossinessMap=e.glossinessMap===void 0?null:e.glossinessMap,t.glossiness=e.glossiness,t.alphaMap=null,t.envMap=e.envMap===void 0?null:e.envMap,t.envMapIntensity=1,t.refractionRatio=.98,t}}class QW{constructor(){this.name=bt.KHR_MESH_QUANTIZATION}}class io extends Lr{constructor(e,t,s,r){super(e,t,s,r)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,r=this.valueSize,i=e*r*3+r;for(let o=0;o!==r;o++)t[o]=s[i+o];return t}}io.prototype.beforeStart_=io.prototype.copySampleValue_;io.prototype.afterEnd_=io.prototype.copySampleValue_;io.prototype.interpolate_=function(n,e,t,s){const r=this.resultBuffer,i=this.sampleValues,o=this.valueSize,a=o*2,l=o*3,c=s-e,u=(t-e)/c,h=u*u,d=h*u,p=n*l,f=p-l,m=-2*d+3*h,y=d-h,g=1-m,x=y-h+u;for(let b=0;b!==o;b++){const w=i[f+b+o],C=i[f+b+a]*c,M=i[p+b+o],E=i[p+b]*c;r[b]=g*w+x*C+m*M+y*E}return r};const eH=new Vn;class tH extends io{interpolate_(e,t,s,r){const i=super.interpolate_(e,t,s,r);return eH.fromArray(i).normalize().toArray(i),i}}const kr={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Wl={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},v5={9728:hn,9729:Zn,9984:Vd,9985:Q4,9986:Gd,9987:Ho},b5={33071:Yn,33648:Xc,10497:Wo},w5={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},cf={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv2",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},gi={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},nH={CUBICSPLINE:void 0,LINEAR:Ko,STEP:xl},uf={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function sH(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new no({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Vo})),n.DefaultMaterial}function Hl(n,e,t){for(const s in t.extensions)n[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function oo(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function rH(n,e,t){let s=!1,r=!1;for(let a=0,l=e.length;a<l;a++){const c=e[a];if(c.POSITION!==void 0&&(s=!0),c.NORMAL!==void 0&&(r=!0),s&&r)break}if(!s&&!r)return Promise.resolve(n);const i=[],o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];if(s){const u=c.POSITION!==void 0?t.getDependency("accessor",c.POSITION):n.attributes.position;i.push(u)}if(r){const u=c.NORMAL!==void 0?t.getDependency("accessor",c.NORMAL):n.attributes.normal;o.push(u)}}return Promise.all([Promise.all(i),Promise.all(o)]).then(function(a){const l=a[0],c=a[1];return s&&(n.morphAttributes.position=l),r&&(n.morphAttributes.normal=c),n.morphTargetsRelative=!0,n})}function iH(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let s=0,r=t.length;s<r;s++)n.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function oH(n){const e=n.extensions&&n.extensions[bt.KHR_DRACO_MESH_COMPRESSION];let t;return e?t="draco:"+e.bufferView+":"+e.indices+":"+_5(e.attributes):t=n.indices+":"+_5(n.attributes)+":"+n.mode,t}function _5(n){let e="";const t=Object.keys(n).sort();for(let s=0,r=t.length;s<r;s++)e+=t[s]+":"+n[t[s]]+";";return e}function hf(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}class aH{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new FW,this.associations=new Map,this.primitiveCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.textureCache={},this.nodeNamesUsed={},typeof createImageBitmap!="undefined"&&/Firefox/.test(navigator.userAgent)===!1?this.textureLoader=new f5(this.options.manager):this.textureLoader=new Qp(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Jp(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,r=this.json,i=this.extensions;this.cache.removeAll(),this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(o){const a={scene:o[0][r.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:r.asset,parser:s,userData:{}};Hl(i,a,r),oo(a,r),Promise.all(s._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let r=0,i=t.length;r<i;r++){const o=t[r].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let r=0,i=e.length;r<i;r++){const o=e[r];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(s[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const r=s.clone(),i=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,u]of o.children.entries())i(u,a.children[c])};return i(s,r),r.name+="_instance_"+e.uses[t]++,r}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const r=e(t[s]);if(r)return r}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let r=0;r<t.length;r++){const i=e(t[r]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let r=this.cache.get(s);if(!r){switch(e){case"scene":r=this.loadScene(t);break;case"node":r=this.loadNode(t);break;case"mesh":r=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":r=this.loadAccessor(t);break;case"bufferView":r=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":r=this.loadBuffer(t);break;case"material":r=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":r=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":r=this.loadSkin(t);break;case"animation":r=this.loadAnimation(t);break;case"camera":r=this.loadCamera(t);break;default:throw new Error("Unknown type: "+e)}this.cache.add(s,r)}return r}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,r=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(r.map(function(i,o){return s.getDependency(e,o)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[bt.KHR_BINARY_GLTF].body);const r=this.options;return new Promise(function(i,o){s.load(fi.resolveURL(t.uri,r.path),i,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const r=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+r)})}loadAccessor(e){const t=this,s=this.json,r=this.json.accessors[e];if(r.bufferView===void 0&&r.sparse===void 0)return Promise.resolve(null);const i=[];return r.bufferView!==void 0?i.push(this.getDependency("bufferView",r.bufferView)):i.push(null),r.sparse!==void 0&&(i.push(this.getDependency("bufferView",r.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",r.sparse.values.bufferView))),Promise.all(i).then(function(o){const a=o[0],l=w5[r.type],c=Wl[r.componentType],u=c.BYTES_PER_ELEMENT,h=u*l,d=r.byteOffset||0,p=r.bufferView!==void 0?s.bufferViews[r.bufferView].byteStride:void 0,f=r.normalized===!0;let m,y;if(p&&p!==h){const g=Math.floor(d/p),x="InterleavedBuffer:"+r.bufferView+":"+r.componentType+":"+g+":"+r.count;let b=t.cache.get(x);b||(m=new c(a,g*p,r.count*p/u),b=new ba(m,p/u),t.cache.add(x,b)),y=new wa(b,l,d%p/u,f)}else a===null?m=new c(r.count*l):m=new c(a,d,r.count*l),y=new en(m,l,f);if(r.sparse!==void 0){const g=w5.SCALAR,x=Wl[r.sparse.indices.componentType],b=r.sparse.indices.byteOffset||0,w=r.sparse.values.byteOffset||0,C=new x(o[1],b,r.sparse.count*g),M=new c(o[2],w,r.sparse.count*l);a!==null&&(y=new en(y.array.slice(),y.itemSize,y.normalized));for(let E=0,A=C.length;E<A;E++){const $=C[E];if(y.setX($,M[E*l]),l>=2&&y.setY($,M[E*l+1]),l>=3&&y.setZ($,M[E*l+2]),l>=4&&y.setW($,M[E*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return y})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e],i=t.images[r.source];let o=this.textureLoader;if(i.uri){const a=s.manager.getHandler(i.uri);a!==null&&(o=a)}return this.loadTextureImage(e,i,o)}loadTextureImage(e,t,s){const r=this,i=this.json,o=this.options,a=i.textures[e],l=(t.uri||t.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const c=self.URL||self.webkitURL;let u=t.uri||"",h=!1;if(t.bufferView!==void 0)u=r.getDependency("bufferView",t.bufferView).then(function(p){h=!0;const f=new Blob([p],{type:t.mimeType});return u=c.createObjectURL(f),u});else if(t.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const d=Promise.resolve(u).then(function(p){return new Promise(function(f,m){let y=f;s.isImageBitmapLoader===!0&&(y=function(g){const x=new dn(g);x.needsUpdate=!0,f(x)}),s.load(fi.resolveURL(p,o.path),y,void 0,m)})}).then(function(p){h===!0&&c.revokeObjectURL(u),p.flipY=!1,a.name&&(p.name=a.name);const m=(i.samplers||{})[a.sampler]||{};return p.magFilter=v5[m.magFilter]||Zn,p.minFilter=v5[m.minFilter]||Ho,p.wrapS=b5[m.wrapS]||Wo,p.wrapT=b5[m.wrapT]||Wo,r.associations.set(p,{textures:e}),p}).catch(function(){return console.error("THREE.GLTFLoader: Couldn't load texture",u),null});return this.textureCache[l]=d,d}assignTexture(e,t,s){const r=this;return this.getDependency("texture",s.index).then(function(i){if(s.texCoord!==void 0&&s.texCoord!=0&&!(t==="aoMap"&&s.texCoord==1)&&console.warn("THREE.GLTFLoader: Custom UV set "+s.texCoord+" for texture "+t+" not yet supported."),r.extensions[bt.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[bt.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const a=r.associations.get(i);i=r.extensions[bt.KHR_TEXTURE_TRANSFORM].extendTexture(i,o),r.associations.set(i,a)}}return e[t]=i,i})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const r=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,o=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new Op,pn.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,l.sizeAttenuation=!1,this.cache.add(a,l)),s=l}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let l=this.cache.get(a);l||(l=new Ca,pn.prototype.copy.call(l,s),l.color.copy(s.color),this.cache.add(a,l)),s=l}if(r||i||o){let a="ClonedMaterial:"+s.uuid+":";s.isGLTFSpecularGlossinessMaterial&&(a+="specular-glossiness:"),r&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=s.clone(),i&&(l.vertexColors=!0),o&&(l.flatShading=!0),r&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(s))),s=l}s.aoMap&&t.attributes.uv2===void 0&&t.attributes.uv!==void 0&&t.setAttribute("uv2",t.attributes.uv),e.material=s}getMaterialType(){return no}loadMaterial(e){const t=this,s=this.json,r=this.extensions,i=s.materials[e];let o;const a={},l=i.extensions||{},c=[];if(l[bt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]){const h=r[bt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];o=h.getMaterialType(),c.push(h.extendParams(a,i,t))}else if(l[bt.KHR_MATERIALS_UNLIT]){const h=r[bt.KHR_MATERIALS_UNLIT];o=h.getMaterialType(),c.push(h.extendParams(a,i,t))}else{const h=i.pbrMetallicRoughness||{};if(a.color=new Le(1,1,1),a.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;a.color.fromArray(d),a.opacity=d[3]}h.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",h.baseColorTexture)),a.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,a.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",h.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",h.metallicRoughnessTexture))),o=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}i.doubleSided===!0&&(a.side=Wi);const u=i.alphaMode||uf.OPAQUE;if(u===uf.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.format=ei,a.transparent=!1,u===uf.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&o!==Ks&&(c.push(t.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new pe(1,1),i.normalTexture.scale!==void 0)){const h=i.normalTexture.scale;a.normalScale.set(h,h)}return i.occlusionTexture!==void 0&&o!==Ks&&(c.push(t.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&o!==Ks&&(a.emissive=new Le().fromArray(i.emissiveFactor)),i.emissiveTexture!==void 0&&o!==Ks&&c.push(t.assignTexture(a,"emissiveMap",i.emissiveTexture)),Promise.all(c).then(function(){let h;return o===lf?h=r[bt.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(a):h=new o(a),i.name&&(h.name=i.name),h.map&&(h.map.encoding=ti),h.emissiveMap&&(h.emissiveMap.encoding=ti),oo(h,i),t.associations.set(h,{materials:e}),i.extensions&&Hl(r,h,i),h})}createUniqueName(e){const t=Nt.sanitizeNodeName(e||"");let s=t;for(let r=1;this.nodeNamesUsed[s];++r)s=t+"_"+r;return this.nodeNamesUsed[s]=!0,s}loadGeometries(e){const t=this,s=this.extensions,r=this.primitiveCache;function i(a){return s[bt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(l){return T5(l,a,t)})}const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],u=oH(c),h=r[u];if(h)o.push(h.promise);else{let d;c.extensions&&c.extensions[bt.KHR_DRACO_MESH_COMPRESSION]?d=i(c):d=T5(new Wt,c,t),r[u]={primitive:c,promise:d},o.push(d)}}return Promise.all(o)}loadMesh(e){const t=this,s=this.json,r=this.extensions,i=s.meshes[e],o=i.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const u=o[l].material===void 0?sH(this.cache):this.getDependency("material",o[l].material);a.push(u)}return a.push(t.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),u=l[l.length-1],h=[];for(let p=0,f=u.length;p<f;p++){const m=u[p],y=o[p];let g;const x=c[p];if(y.mode===kr.TRIANGLES||y.mode===kr.TRIANGLE_STRIP||y.mode===kr.TRIANGLE_FAN||y.mode===void 0)g=i.isSkinnedMesh===!0?new Pp(m,x):new fn(m,x),g.isSkinnedMesh===!0&&!g.geometry.attributes.skinWeight.normalized&&g.normalizeSkinWeights(),y.mode===kr.TRIANGLE_STRIP?g.geometry=E5(g.geometry,mO):y.mode===kr.TRIANGLE_FAN&&(g.geometry=E5(g.geometry,hx));else if(y.mode===kr.LINES)g=new Au(m,x);else if(y.mode===kr.LINE_STRIP)g=new Mu(m,x);else if(y.mode===kr.LINE_LOOP)g=new $y(m,x);else if(y.mode===kr.POINTS)g=new Oy(m,x);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(g.geometry.morphAttributes).length>0&&iH(g,i),g.name=t.createUniqueName(i.name||"mesh_"+e),oo(g,i),y.extensions&&Hl(r,g,y),t.assignFinalMaterial(g),h.push(g)}for(let p=0,f=h.length;p<f;p++)t.associations.set(h[p],{meshes:e,primitives:p});if(h.length===1)return h[0];const d=new hi;t.associations.set(d,{meshes:e});for(let p=0,f=h.length;p<f;p++)d.add(h[p]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],r=s[s.type];if(!r){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Gn(PO.radToDeg(r.yfov),r.aspectRatio||1,r.znear||1,r.zfar||2e6):s.type==="orthographic"&&(t=new Ml(-r.xmag,r.xmag,r.ymag,-r.ymag,r.znear,r.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),oo(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s={joints:t.joints};return t.inverseBindMatrices===void 0?Promise.resolve(s):this.getDependency("accessor",t.inverseBindMatrices).then(function(r){return s.inverseBindMatrices=r,s})}loadAnimation(e){const s=this.json.animations[e],r=[],i=[],o=[],a=[],l=[];for(let c=0,u=s.channels.length;c<u;c++){const h=s.channels[c],d=s.samplers[h.sampler],p=h.target,f=p.node!==void 0?p.node:p.id,m=s.parameters!==void 0?s.parameters[d.input]:d.input,y=s.parameters!==void 0?s.parameters[d.output]:d.output;r.push(this.getDependency("node",f)),i.push(this.getDependency("accessor",m)),o.push(this.getDependency("accessor",y)),a.push(d),l.push(p)}return Promise.all([Promise.all(r),Promise.all(i),Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const u=c[0],h=c[1],d=c[2],p=c[3],f=c[4],m=[];for(let g=0,x=u.length;g<x;g++){const b=u[g],w=h[g],C=d[g],M=p[g],E=f[g];if(b===void 0)continue;b.updateMatrix(),b.matrixAutoUpdate=!0;let A;switch(gi[E.path]){case gi.weights:A=zl;break;case gi.rotation:A=ro;break;case gi.position:case gi.scale:default:A=Ul;break}const $=b.name?b.name:b.uuid,B=M.interpolation!==void 0?nH[M.interpolation]:Ko,R=[];gi[E.path]===gi.weights?b.traverse(function(F){F.morphTargetInfluences&&R.push(F.name?F.name:F.uuid)}):R.push($);let K=C.array;if(C.normalized){const F=hf(K.constructor),z=new Float32Array(K.length);for(let V=0,H=K.length;V<H;V++)z[V]=K[V]*F;K=z}for(let F=0,z=R.length;F<z;F++){const V=new A(R[F]+"."+gi[E.path],w.array,K,B);M.interpolation==="CUBICSPLINE"&&(V.createInterpolant=function(j){const ae=this instanceof ro?tH:io;return new ae(this.times,this.values,this.getValueSize()/3,j)},V.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),m.push(V)}}const y=s.name?s.name:"animation_"+e;return new Zp(y,void 0,m)})}createNodeMesh(e){const t=this.json,s=this,r=t.nodes[e];return r.mesh===void 0?null:s.getDependency("mesh",r.mesh).then(function(i){const o=s._getNodeRef(s.meshCache,r.mesh,i);return r.weights!==void 0&&o.traverse(function(a){if(!!a.isMesh)for(let l=0,c=r.weights.length;l<c;l++)a.morphTargetInfluences[l]=r.weights[l]}),o})}loadNode(e){const t=this.json,s=this.extensions,r=this,i=t.nodes[e],o=i.name?r.createUniqueName(i.name):"";return function(){const a=[],l=r._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),i.camera!==void 0&&a.push(r.getDependency("camera",i.camera).then(function(c){return r._getNodeRef(r.cameraCache,i.camera,c)})),r._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),Promise.all(a)}().then(function(a){let l;if(i.isBone===!0?l=new Dp:a.length>1?l=new hi:a.length===1?l=a[0]:l=new Ye,l!==a[0])for(let c=0,u=a.length;c<u;c++)l.add(a[c]);if(i.name&&(l.userData.name=i.name,l.name=o),oo(l,i),i.extensions&&Hl(s,l,i),i.matrix!==void 0){const c=new ze;c.fromArray(i.matrix),l.applyMatrix4(c)}else i.translation!==void 0&&l.position.fromArray(i.translation),i.rotation!==void 0&&l.quaternion.fromArray(i.rotation),i.scale!==void 0&&l.scale.fromArray(i.scale);return r.associations.has(l)||r.associations.set(l,{}),r.associations.get(l).nodes=e,l})}loadScene(e){const t=this.json,s=this.extensions,r=this.json.scenes[e],i=this,o=new hi;r.name&&(o.name=i.createUniqueName(r.name)),oo(o,r),r.extensions&&Hl(s,o,r);const a=r.nodes||[],l=[];for(let c=0,u=a.length;c<u;c++)l.push(S5(a[c],o,t,i));return Promise.all(l).then(function(){const c=u=>{const h=new Map;for(const[d,p]of i.associations)(d instanceof pn||d instanceof dn)&&h.set(d,p);return u.traverse(d=>{const p=i.associations.get(d);p!=null&&h.set(d,p)}),h};return i.associations=c(o),o})}}function S5(n,e,t,s){const r=t.nodes[n];return s.getDependency("node",n).then(function(i){if(r.skin===void 0)return i;let o;return s.getDependency("skin",r.skin).then(function(a){o=a;const l=[];for(let c=0,u=o.joints.length;c<u;c++)l.push(s.getDependency("node",o.joints[c]));return Promise.all(l)}).then(function(a){return i.traverse(function(l){if(!l.isMesh)return;const c=[],u=[];for(let h=0,d=a.length;h<d;h++){const p=a[h];if(p){c.push(p);const f=new ze;o.inverseBindMatrices!==void 0&&f.fromArray(o.inverseBindMatrices.array,h*16),u.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',o.joints[h])}l.bind(new kp(c,u),l.matrixWorld)}),i})}).then(function(i){e.add(i);const o=[];if(r.children){const a=r.children;for(let l=0,c=a.length;l<c;l++){const u=a[l];o.push(S5(u,i,t,s))}}return Promise.all(o)})}function lH(n,e,t){const s=e.attributes,r=new jt;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],l=a.min,c=a.max;if(l!==void 0&&c!==void 0){if(r.set(new L(l[0],l[1],l[2]),new L(c[0],c[1],c[2])),a.normalized){const u=hf(Wl[a.componentType]);r.min.multiplyScalar(u),r.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const a=new L,l=new L;for(let c=0,u=i.length;c<u;c++){const h=i[c];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const m=hf(Wl[d.componentType]);l.multiplyScalar(m)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}r.expandByVector(a)}n.boundingBox=r;const o=new Zi;r.getCenter(o.center),o.radius=r.min.distanceTo(r.max)/2,n.boundingSphere=o}function T5(n,e,t){const s=e.attributes,r=[];function i(o,a){return t.getDependency("accessor",o).then(function(l){n.setAttribute(a,l)})}for(const o in s){const a=cf[o]||o.toLowerCase();a in n.attributes||r.push(i(s[o],a))}if(e.indices!==void 0&&!n.index){const o=t.getDependency("accessor",e.indices).then(function(a){n.setIndex(a)});r.push(o)}return oo(n,e),lH(n,e,t),Promise.all(r).then(function(){return e.targets!==void 0?rH(n,e.targets,t):n})}function E5(n,e){let t=n.getIndex();if(t===null){const o=[],a=n.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);n.setIndex(o),t=n.getIndex()}else return console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const s=t.count-2,r=[];if(e===hx)for(let o=1;o<=s;o++)r.push(t.getX(0)),r.push(t.getX(o)),r.push(t.getX(o+1));else for(let o=0;o<s;o++)o%2==0?(r.push(t.getX(o)),r.push(t.getX(o+1)),r.push(t.getX(o+2))):(r.push(t.getX(o+2)),r.push(t.getX(o+1)),r.push(t.getX(o)));r.length/3!==s&&console.error("THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=n.clone();return i.setIndex(r),i}const cH=[.499976992607117,.34746599197387695,.500025987625122,.45251297950744596,.499974012374878,.397628009319305,.482113003730774,.528020977973938,.500150978565216,.47284400463104204,.499909996986389,.5017470121383669,.499523013830185,.59893798828125,.289712011814117,.6192359924316411,.499954998493195,.687601983547211,.499987006187439,.730081021785736,.500023007392883,.892949998378754,.500023007392883,.33376598358154297,.5000159740448,.320775985717773,.500023007392883,.30765199661254905,.499976992607117,.30472201108932495,.499976992607117,.29406601190567005,.499976992607117,.280614972114563,.499976992607117,.262980997562408,.499967992305756,.21862900257110596,.499816000461578,.43701899051666304,.473773002624512,.42609000205993697,.104906998574734,.745859026908875,.365929991006851,.590424001216888,.338757991790771,.58697497844696,.311120003461838,.590539991855621,.274657994508743,.6108689904212949,.393361985683441,.596293985843658,.345234006643295,.655988991260529,.370094001293182,.6539239883422849,.319321990013123,.652734994888306,.297903001308441,.646408975124359,.24779200553894,.589190006256104,.396889001131058,.15724498033523604,.280097991228104,.6244000196456909,.106310002505779,.6000440120697019,.2099249958992,.6086469888687129,.355807989835739,.46559399366378795,.471751004457474,.34959602355957,.474155008792877,.319808006286621,.439785003662109,.342770993709564,.414617002010345,.33345901966095004,.450374007225037,.319139003753662,.428770989179611,.31730902194976796,.374971002340317,.272194981575012,.486716985702515,.452371001243591,.485300987958908,.47260499000549305,.257764995098114,.685509979724884,.401223003864288,.544827997684479,.429818987846375,.451385021209717,.421351999044418,.466259002685547,.276895999908447,.467943012714386,.483370006084442,.500413000583649,.33721199631691,.7171170115470891,.296391993761063,.706757009029388,.169294998049736,.806186020374298,.447580009698868,.697390019893646,.392390012741089,.646112024784088,.354490011930466,.30321598052978505,.067304998636246,.269894957542419,.442739009857178,.427173972129822,.457098007202148,.415207982063293,.381974011659622,.305289030075073,.392388999462128,.305796980857849,.277076005935669,.728067994117737,.422551989555359,.436766982078552,.385919004678726,.718635976314545,.383103013038635,.744159996509552,.331431001424789,.880285978317261,.229923993349075,.767997026443481,.364500999450684,.810886025428772,.229622006416321,.700459003448486,.173287004232407,.721252024173737,.472878992557526,.33380198478698697,.446828007698059,.331472992897034,.422762006521225,.32611000537872303,.445307999849319,.41993403434753396,.388103008270264,.306038975715637,.403039008378983,.293460011482239,.403629004955292,.306046962738037,.460041999816895,.44286096096038796,.431158006191254,.307633996009827,.452181994915009,.307633996009827,.475387006998062,.307633996009827,.465828001499176,.22080999612808205,.472328990697861,.263774037361145,.473087012767792,.282142996788025,.473122000694275,.295374035835266,.473033010959625,.30472201108932495,.427942007780075,.30472201108932495,.426479011774063,.29646003246307395,.423162013292313,.28815400600433305,.4183090031147,.27993702888488803,.390094995498657,.360427021980286,.013953999616206,.439965963363647,.499913990497589,.41985297203064,.413199990987778,.30460000038146995,.409626007080078,.29817700386047397,.468080013990402,.398465037345886,.422728985548019,.414014995098114,.463079988956451,.406216025352478,.37211999297142,.52658599615097,.334562003612518,.5039269924163821,.411671012639999,.45303499698638905,.242175996303558,.85232400894165,.290776997804642,.798554003238678,.327338010072708,.7434729933738711,.399509996175766,.251078963279724,.441727995872498,.738323986530304,.429764986038208,.8121659755706789,.412198007106781,.891098976135254,.288955003023148,.601047992706299,.218936994671822,.564589023590088,.41278201341629,.601029992103577,.257135003805161,.644559979438782,.427684992551804,.562039017677307,.448339998722076,.46306395530700695,.178560003638268,.54244601726532,.247308000922203,.542806029319763,.286267012357712,.532325029373169,.332827985286713,.5392879843711851,.368755996227264,.552793025970459,.398963987827301,.567345023155212,.476410001516342,.594193994998932,.189241006970406,.47607600688934304,.228962004184723,.651049017906189,.490725994110107,.43759900331497203,.404670000076294,.514867007732391,.019469000399113,.598435997962952,.426243007183075,.5795689821243291,.396993011236191,.451202988624573,.266469985246658,.6230229735374451,.439121007919312,.48104202747345004,.032313998788595,.355643033981323,.419054001569748,.612845003604889,.462783008813858,.49425303936004605,.238978996872902,.22025501728057895,.198220998048782,.16806197166442904,.107550002634525,.459244966506958,.183610007166862,.259742975234985,.134409993886948,.6663169860839839,.385764002799988,.11684602499008201,.490967005491257,.42062199115753196,.382384985685349,.491427004337311,.174399003386497,.602329015731812,.318785011768341,.60376501083374,.343364000320435,.599403023719788,.396100014448166,.28978300094604503,.187885001301765,.41146200895309404,.430987000465393,.05593502521514904,.318993002176285,.101714968681335,.266247987747192,.130298972129822,.500023007392883,.809423983097076,.499976992607117,.045547008514403964,.366169989109039,.601177990436554,.393207013607025,.6044629812240601,.410373002290726,.608919978141785,.194993004202843,.657898008823395,.388664990663528,.6377159953117371,.365961998701096,.644029021263123,.343364000320435,.6446430087089541,.318785011768341,.64165997505188,.301414996385574,.636843979358673,.058132998645306,.680923998355865,.301414996385574,.612550973892212,.499987989664078,.38156598806381203,.415838003158569,.375804007053375,.445681989192963,.43392300605773904,.465844005346298,.379359006881714,.49992299079895,.648476004600525,.288718998432159,.180054008960724,.335278987884521,.14718002080917403,.440512001514435,.09758102893829301,.128294005990028,.20805901288986195,.408771991729736,.6261060237884519,.455606997013092,.548198997974396,.499877005815506,.09100997447967496,.375436991453171,.07580798864364602,.11421000212431,.38497799634933505,.448662012815475,.30472201108932495,.4480200111866,.295367956161499,.447111994028091,.28419196605682395,.444831997156143,.269205987453461,.430011987686157,.23319101333618197,.406787008047104,.31432700157165505,.400738000869751,.318930983543396,.392399996519089,.32229697704315197,.367855995893478,.33608102798461903,.247923001646996,.39866697788238503,.452769994735718,.579150021076202,.43639200925827,.640112996101379,.416164010763168,.631286025047302,.413385987281799,.307633996009827,.228018000721931,.316428005695343,.468268007040024,.6473289728164671,.411361992359161,.195672988891602,.499989002943039,.530174970626831,.479153990745544,.557345986366272,.499974012374878,.5603629946708679,.432112008333206,.506411015987396,.499886006116867,.13308298587799094,.49991300702095,.17827099561691295,.456548988819122,.18079900741577104,.344549000263214,.254561007022858,.37890899181366,.425989985466003,.374292999505997,.219815015792847,.319687992334366,.42926204204559304,.357154995203018,.395730018615723,.295284003019333,.37841904163360596,.447750002145767,.137522995471954,.410986006259918,.491276979446411,.31395098567009,.22469198703765902,.354128003120422,.187447011470795,.324548006057739,.296007037162781,.189096003770828,.35370004177093495,.279776990413666,.28534197807312,.1338230073452,.317299008369446,.336768001317978,.35526698827743497,.429883986711502,.533478021621704,.455527991056442,.451377034187317,.437114000320435,.441103994846344,.467287987470627,.47007501125335704,.414712011814117,.6647800207138059,.37704598903656,.677222013473511,.344107985496521,.679849028587341,.312875986099243,.67766797542572,.283526003360748,.6668099761009221,.241245999932289,.617214024066925,.102986000478268,.531237006187439,.267612010240555,.575439989566803,.297879010438919,.5668240189552309,.333433985710144,.5661219954490659,.366427004337311,.573884010314941,.396012008190155,.583303987979889,.420121014118195,.58977198600769,.007561000064015,.519222974777222,.432949006557465,.43048202991485596,.458638995885849,.520910978317261,.473466008901596,.45425599813461304,.476087987422943,.43616998195648204,.468472003936768,.444943010807037,.433990985155106,.417638003826141,.483518004417419,.43701601028442405,.482482999563217,.42215096950530995,.42645001411438,.6102010011672969,.438998997211456,.60350501537323,.450067013502121,.599565982818604,.289712011814117,.631747007369995,.276670008897781,.636627018451691,.517862021923065,.528051972389221,.710287988185883,.6192359924316411,.526226997375488,.42609000205993697,.895093023777008,.745859026908875,.634069979190826,.590424001216888,.661242008209229,.58697497844696,.688880026340485,.590539991855621,.725341975688934,.6108689904212949,.606630027294159,.5962949991226201,.654766023159027,.655988991260529,.629905998706818,.6539239883422849,.680678009986877,.652734994888306,.702096998691559,.646408975124359,.75221198797226,.589195013046265,.602918028831482,.15713703632354703,.719901978969574,.6244000196456909,.893692970275879,.600040018558502,.790081977844238,.608645975589752,.643998026847839,.465512037277222,.528249025344849,.34959602355957,.525849997997284,.31980895996093806,.560214996337891,.342770993709564,.585384011268616,.33345901966095004,.549625992774963,.319139003753662,.57122802734375,.317308008670807,.624852001667023,.27190101146698,.513050019741058,.45271801948547397,.51509702205658,.472748041152954,.742246985435486,.685492992401123,.598631024360657,.545020997524261,.570338010787964,.451424956321716,.578631997108459,.46637701988220204,.723087012767792,.467945992946625,.516445994377136,.500361025333405,.662801027297974,.717082023620605,.70362401008606,.706728994846344,.830704987049103,.806186020374298,.552385985851288,.697431981563568,.607609987258911,.646112024784088,.645429015159607,.30329298973083496,.932694971561432,.269894957542419,.557260990142822,.427173972129822,.542901992797852,.415207982063293,.6180260181427,.305289030075073,.607590973377228,.305796980857849,.722943007946014,.7280369997024541,.577413976192474,.43683302402496305,.614082992076874,.7186130285263059,.616907000541687,.744113981723785,.668509006500244,.880086004734039,.770092010498047,.767979025840759,.635536015033722,.8107510209083559,.77039098739624,.7004439830780029,.826722025871277,.7212449908256531,.527121007442474,.33380198478698697,.553171992301941,.331472992897034,.577238023281097,.32611000537872303,.554691970348358,.41993403434753396,.611896991729736,.306038975715637,.59696102142334,.293460011482239,.596370995044708,.306046962738037,.539958000183105,.44286096096038796,.568841993808746,.307633996009827,.547818005084991,.307633996009827,.52461302280426,.307633996009827,.534089982509613,.22085899114608798,.527670979499817,.263774037361145,.526912987232208,.282142996788025,.526877999305725,.295374035835266,.526966989040375,.30472201108932495,.572058022022247,.30472201108932495,.573521018028259,.29646003246307395,.57683801651001,.28815400600433305,.581691026687622,.27993702888488803,.609944999217987,.36009001731872603,.986046016216278,.439965963363647,.5867999792099,.30460000038146995,.590372025966644,.29817700386047397,.531915009021759,.398463010787964,.577268004417419,.414065003395081,.536915004253387,.406213998794556,.627542972564697,.526647984981537,.665585994720459,.5040490031242371,.588353991508484,.45313799381256104,.757824003696442,.85232400894165,.709249973297119,.798492014408112,.672684013843536,.743418991565704,.600408971309662,.25099503993988004,.55826598405838,.738327980041504,.570303976535797,.812129020690918,.588165998458862,.890955984592438,.711045026779175,.601047992706299,.781069993972778,.564594984054565,.587247014045715,.601068019866943,.742869973182678,.644554018974304,.572156012058258,.562348008155823,.55186802148819,.46342998743057295,.821442008018494,.542443990707397,.752701997756958,.542818009853363,.71375697851181,.532373011112213,.66711300611496,.539327025413513,.631101012229919,.552846014499664,.6008620262146,.567526996135712,.523481011390686,.5943729877471919,.810747981071472,.476073980331421,.771045982837677,.6510409712791441,.509127020835876,.43728196620941195,.595292985439301,.514976024627686,.980530977249146,.598435997962952,.573499977588654,.579999983310699,.602994978427887,.45131200551986705,.733529984951019,.6230229735374451,.560611009597778,.48098301887512196,.967685997486115,.355643033981323,.580985009670258,.612839996814728,.537728011608124,.494614958763123,.760966002941132,.22024703025817904,.801778972148895,.16806197166442904,.892440974712372,.45923900604248,.816350996494293,.259739995002747,.865594983100891,.666312992572784,.614073991775513,.11675399541854903,.508952975273132,.42056202888488803,.617941975593567,.49168395996093806,.825608015060425,.602325022220612,.681214988231659,.60376501083374,.656635999679565,.599403023719788,.603900015354156,.28978300094604503,.81208598613739,.41146099567413297,.56801301240921,.05543500185012795,.681007981300354,.101714968681335,.733752012252808,.130298972129822,.633830010890961,.601177990436554,.606792986392975,.6044629812240601,.589659988880157,.6089379787445071,.805015981197357,.657891988754272,.611334979534149,.6377159953117371,.634037971496582,.644029021263123,.656635999679565,.6446430087089541,.681214988231659,.64165997505188,.698584973812103,.636843979358673,.941866993904114,.680923998355865,.698584973812103,.612550973892212,.584177017211914,.375892996788025,.554318010807037,.43392300605773904,.534153997898102,.37935996055603005,.711217999458313,.18002498149871804,.664629995822906,.14712899923324596,.559099972248077,.09736800193786599,.871706008911133,.20805901288986195,.591234028339386,.6261060237884519,.544341027736664,.548416018486023,.624562978744507,.07580798864364602,.88577002286911,.384971022605896,.551338016986847,.30472201108932495,.551980018615723,.295367956161499,.552887976169586,.28419196605682395,.555167973041534,.269205987453461,.569944024085999,.23296499252319303,.593203008174896,.31432402133941695,.599261999130249,.318930983543396,.607599973678589,.32229697704315197,.631937980651855,.33649998903274503,.752032995223999,.398684978485107,.547226011753082,.579604983329773,.563543975353241,.640172004699707,.583841025829315,.631286025047302,.586614012718201,.307633996009827,.771915018558502,.31642198562622104,.531597018241882,.647517025470734,.588370978832245,.19555902481079102,.52079701423645,.5574349761009221,.567984998226166,.5065209865570071,.543282985687256,.18074500560760498,.655317008495331,.25448501110076904,.621008992195129,.42598199844360396,.625559985637665,.21968799829483,.680198013782501,.42928099632263195,.64276397228241,.39566200971603405,.704662978649139,.378470003604889,.552012026309967,.13740801811218295,.589071989059448,.491362988948822,.685944974422455,.224642992019653,.645735025405884,.18735998868942305,.675342977046967,.29602199792861905,.810858011245728,.35369503498077404,.72012197971344,.28533303737640403,.866151988506317,.31729501485824596,.663187026977539,.35540300607681297,.570082008838654,.533674001693726,.544561982154846,.451624035835266,.562758982181549,.441215038299561,.531987011432648,.469859957695007,.585271000862122,.664822995662689,.622952997684479,.67722100019455,.655896008014679,.679836988449097,.687132000923157,.677654027938843,.716481983661652,.666799008846283,.758756995201111,.617213010787964,.897013008594513,.531230986118317,.732392013072968,.575452983379364,.70211398601532,.566837012767792,.66652500629425,.566133975982666,.633504986763,.5739120244979861,.603875994682312,.583413004875183,.579657971858978,.590054988861084,.992439985275269,.519222974777222,.567192018032074,.43058001995086703,.54136598110199,.521100997924805,.526564002037048,.453881978988647,.523913025856018,.43616998195648204,.531529009342194,.444943010807037,.566035985946655,.41767096519470204,.51631098985672,.43694603443145796,.5174720287323,.42212295532226596,.573594987392426,.610193014144897,.560697972774506,.604668021202087,.549755990505219,.6002489924430849,.710287988185883,.631747007369995,.723330020904541,.636627018451691],uH=[323.11651611328125,323.94647216796875,-17.568782806396484,321.64990234375,267.7066650390625,-31.925785064697266,321.6676330566406,285.19525146484375,-17.194509506225586,306.4206848144531,216.11929321289062,-23.553361892700195,321.1368103027344,251.257568359375,-33.84282302856445,320.308837890625,230.17721557617188,-31.289081573486328,318.3310546875,181.22036743164062,-14.797897338867188,210.6700897216797,183.96359252929688,8.644062042236328,317.1302490234375,148.72677612304688,-10.399860382080078,316.5323791503906,128.6800079345703,-11.26718521118164,314.0401611328125,52.11235046386719,-3.3319506645202637,323.38702392578125,332.09625244140625,-16.704530715942383,323.5595397949219,338.2655944824219,-14.759981155395508,323.5887756347656,340.659423828125,-12.136107444763184,323.96087646484375,342.1773681640625,-11.875374794006348,324.2167663574219,348.4466857910156,-12.978582382202148,324.48931884765625,356.75933837890625,-14.554830551147461,324.84228515625,366.36590576171875,-14.144981384277344,325.2572937011719,384.9513854980469,-8.975934028625488,321.7921142578125,276.28167724609375,-28.98696517944336,306.4281921386719,275.7503662109375,-20.878870010375977,159.87014770507812,131.3053741455078,37.14374923706055,254.20277404785156,194.42990112304688,2.7031404972076416,239.59185791015625,196.41848754882812,2.972090482711792,225.3127899169922,196.68807983398438,4.522538185119629,205.5539093017578,190.17918395996094,9.360472679138184,266.25823974609375,190.09291076660156,3.3210108280181885,232.54664611816406,161.1142578125,.4966323971748352,248.14019775390625,161.02940368652344,.7534967660903931,218.1525421142578,163.57833862304688,2.2705366611480713,208.49998474121094,168.55471801757812,4.669690132141113,194.8409423828125,200.6750030517578,12.155685424804688,267.7841796875,414.53961181640625,-1.8064359426498413,205.23828125,181.122802734375,10.508393287658691,154.94073486328125,197.5607452392578,38.3432731628418,178.42001342773438,191.921142578125,18.159528732299805,244.1207733154297,258.5937194824219,-3.900184154510498,303.1524658203125,321.52093505859375,-16.866844177246094,306.58087158203125,338.35498046875,-13.89834213256836,283.00830078125,327.0491027832031,-13.434535026550293,270.6599426269531,334.0726623535156,-9.07385540008545,291.79815673828125,339.4311828613281,-11.61515998840332,280.6661376953125,341.4773864746094,-7.595709800720215,253.0904083251953,359.0290832519531,-.5970669388771057,308.47296142578125,267.54986572265625,-31.436981201171875,305.8460998535156,251.86883544921875,-33.17796325683594,185.6485137939453,153.70790100097656,6.360101699829102,273.1829833984375,218.42984008789062,-4.297842025756836,270.1053466796875,264.7032470703125,-16.802474975585938,268.9358215332031,256.55902099609375,-14.856505393981934,201.0337677001953,258.9792785644531,3.5506505966186523,305.99237060546875,232.39395141601562,-29.471277236938477,219.88006591796875,137.08212280273438,-3.7479465007781982,199.33328247070312,142.66859436035156,.7038824558258057,171.93594360351562,102.62930297851562,25.879261016845703,285.7288818359375,146.78271484375,-8.614612579345703,262.0455322265625,164.37820434570312,2.617023468017578,240.76773071289062,344.6684875488281,1.1622507572174072,172.84420776367188,344.5473937988281,52.14391326904297,281.74786376953125,273.1513977050781,-14.525100708007812,295.11383056640625,278.23193359375,-15.336343765258789,257.3583984375,344.6321105957031,.5829941630363464,264.4135437011719,343.39166259765625,-1.017601490020752,191.10064697265625,132.69065856933594,3.8590035438537598,269.67431640625,271.9882507324219,-13.59800910949707,248.12142944335938,137.29592895507812,-6.9757537841796875,244.83111572265625,124.17098999023438,-8.012014389038086,228.30499267578125,62.86616516113281,3.8345837593078613,181.92501831054688,116.54222106933594,13.413105964660645,238.1670684814453,91.65449523925781,-2.371932029724121,177.29916381835938,147.32359313964844,11.65469741821289,168.9032745361328,139.77952575683594,23.712440490722656,304.657470703125,331.4319152832031,-16.049942016601562,287.97210693359375,334.75262451171875,-12.795928955078125,275.8045959472656,338.0773620605469,-8.809469223022461,285.7834777832031,276.115234375,-13.412927627563477,261.038330078125,344.1378173828125,-.24986127018928528,268.093505859375,345.9375,-4.172092914581299,266.13116455078125,342.62908935546875,-1.2260991334915161,290.6131896972656,267.3948974609375,-22.783634185791016,283.6044006347656,340.5296936035156,-6.641707897186279,295.03564453125,340.2284851074219,-9.275909423828125,308.5382080078125,340.4044189453125,-11.458096504211426,304.6598815917969,384.4068908691406,-8.751299858093262,305.5709228515625,365.5459289550781,-13.695691108703613,306.277099609375,355.4984130859375,-14.016304016113281,307.0936279296875,347.2339782714844,-12.360522270202637,308.20281982421875,342.0711975097656,-11.197815895080566,282.26275634765625,342.27349853515625,-6.5559587478637695,280.1040344238281,344.2525634765625,-7.676806926727295,276.89044189453125,348.6038513183594,-8.685104370117188,273.98187255859375,354.4639892578125,-7.716130256652832,256.96429443359375,315.8611145019531,-7.173637390136719,156.67434692382812,268.1974182128906,61.823402404785156,321.67657470703125,279.9446105957031,-21.204376220703125,274.7763671875,342.8690490722656,-3.4922499656677246,271.748291015625,343.65057373046875,-4.173834800720215,300.82440185546875,285.601806640625,-15.708353042602539,275.4014892578125,281.88909912109375,-9.427604675292969,298.0133056640625,282.04547119140625,-15.658348083496094,257.8790588378906,228.18124389648438,-2.3751800060272217,234.48097229003906,239.43783569335938,-.8608551621437073,266.601318359375,263.881103515625,-11.564746856689453,193.27264404296875,79.32144165039062,13.976980209350586,203.66551208496094,99.89955139160156,4.993534564971924,214.192626953125,124.35659790039062,-2.3503618240356445,266.8046569824219,368.8791198730469,-3.8713901042938232,280.217041015625,126.4576416015625,-10.782143592834473,274.21429443359375,89.12802124023438,-6.5469970703125,267.3445739746094,54.692535400390625,-2.064028263092041,212.81898498535156,194.91871643066406,6.971029758453369,180.09385681152344,212.29409790039062,15.353899002075195,273.771484375,185.7499237060547,4.228655815124512,192.789306640625,172.89857482910156,9.732086181640625,283.6727600097656,207.76104736328125,-6.431457042694092,280.1270751953125,258.4156799316406,-22.589630126953125,165.6214141845703,224.11279296875,21.64031410217285,190.24551391601562,221.98941040039062,9.924493789672852,209.01893615722656,226.47073364257812,4.510352611541748,236.8439178466797,222.82125854492188,1.8049453496932983,257.20220947265625,215.456787109375,.6790369749069214,272.492431640625,207.42327880859375,-.8617515563964844,303.6573181152344,185.8953857421875,-12.504512786865234,168.3778076171875,256.185791015625,19.68412971496582,181.09927368164062,171.31813049316406,12.517826080322266,313.75042724609375,275.7742919921875,-28.656028747558594,274.2816162109375,233.32928466796875,-6.912413597106934,152.38613891601562,198.63865661621094,58.12936782836914,283.8626403808594,198.5483856201172,-1.6045750379562378,265.49407958984375,265.3607177734375,-5.484303951263428,200.5620574951172,182.45314025878906,11.547853469848633,278.98931884765625,248.54299926757812,-20.185150146484375,162.0050048828125,305.53851318359375,58.60392379760742,272.994140625,180.28761291503906,5.834909915924072,292.3125915527344,238.79739379882812,-25.972232818603516,202.45433044433594,379.2152099609375,20.797351837158203,204.62899780273438,398.7668762207031,30.881372451782227,156.33914184570312,262.9945373535156,40.65882110595703,184.59329223632812,358.08984375,28.37997055053711,161.83724975585938,166.27520751953125,32.74825668334961,264.6654357910156,433.0896301269531,1.4305986166000366,315.250244140625,279.32794189453125,-20.81725311279297,261.2689208984375,245.606689453125,-4.830883979797363,166.9665069580078,195.82589721679688,24.034517288208008,225.92388916015625,187.05523681640625,5.200074195861816,238.94944763183594,187.44232177734375,3.7697904109954834,264.1736145019531,349.2875061035156,-3.1675024032592773,171.58206176757812,287.9273376464844,21.306987762451172,293.95599365234375,457.10064697265625,2.6667895317077637,246.57467651367188,434.9912109375,14.810300827026367,226.7908172607422,419.973388671875,21.8872013092041,315.3326416015625,88.80404663085938,-7.664234161376953,327.2855224609375,459.603759765625,1.0371936559677124,251.32020568847656,185.9434814453125,3.591391086578369,262.6206359863281,183.20826721191406,4.425485134124756,269.65252685546875,181.5925750732422,5.718056678771973,171.45248413085938,168.89012145996094,18.5508975982666,260.152099609375,172.79396057128906,3.693479537963867,247.5819549560547,170.77157592773438,2.508162260055542,235.03382873535156,170.6088409423828,2.6751668453216553,222.2652587890625,173.05519104003906,4.039044380187988,213.94973754882812,176.4881591796875,5.945765972137451,153.9766845703125,161.3706817626953,49.039398193359375,216.9583282470703,185.66758728027344,7.032083511352539,322.1541442871094,297.5083312988281,-16.00879669189453,269.7311706542969,305.6127624511719,-10.331046104431152,281.48126220703125,270.48370361328125,-16.717947006225586,300.04461669921875,299.4017333984375,-15.656883239746094,317.66339111328125,164.8524627685547,-10.237009048461914,222.44737243652344,400.28460693359375,14.630343437194824,242.59323120117188,416.992431640625,8.299786567687988,292.862060546875,443.7979736328125,-4.521420001983643,187.72213745117188,375.5125427246094,41.960391998291016,268.95684814453125,176.8852081298828,4.970767021179199,294.11273193359375,210.64590454101562,-14.587058067321777,327.2318115234375,446.44342041015625,-5.906525611877441,268.2618408203125,448.0268859863281,7.456300258636475,161.5745849609375,297.48333740234375,39.41569519042969,294.0351257324219,341.7873840332031,-9.140814781188965,291.95458984375,345.6842956542969,-10.367130279541016,289.845947265625,352.1710205078125,-11.577893257141113,288.1461486816406,361.09893798828125,-11.053465843200684,283.66680908203125,377.870361328125,-7.087894439697266,270.8735046386719,342.74639892578125,-4.103464603424072,266.14617919921875,341.66937255859375,-4.162796974182129,261.54791259765625,339.3941345214844,-4.1746826171875,246.18902587890625,329.3245849609375,-2.961322546005249,190.56277465820312,294.2333984375,9.390547752380371,293.86993408203125,195.8378448486328,-9.012523651123047,285.0931091308594,169.88436889648438,1.7015331983566284,275.52679443359375,172.66934204101562,3.9000771045684814,274.2338562011719,340.83880615234375,-3.529534101486206,189.50616455078125,333.734619140625,17.67523956298828,298.2148742675781,168.2777862548828,-6.0877814292907715,275.1707458496094,395.8807373046875,-4.150460243225098,319.609375,213.20645141601562,-25.531686782836914,304.7801818847656,201.61163330078125,-18.585384368896484,318.9832458496094,197.57528686523438,-19.884870529174805,283.4682312011719,235.45059204101562,-14.688872337341309,326.6484069824219,427.47015380859375,-9.102132797241211,325.87774658203125,404.880126953125,-8.94002914428711,299.8717041015625,403.94073486328125,-7.80373477935791,238.68128967285156,367.0010986328125,2.7526659965515137,253.98707580566406,278.80322265625,-4.358704566955566,255.34938049316406,383.8130798339844,-.5109075903892517,221.5740203857422,278.1018981933594,-1.8077586889266968,241.415771484375,295.5854797363281,-3.5574092864990234,209.53550720214844,304.8381042480469,2.743500232696533,294.94976806640625,425.327880859375,-7.4867353439331055,274.0611572265625,244.91165161132812,-10.546663284301758,226.30633544921875,380.7353515625,8.176047325134277,246.79827880859375,398.94097900390625,3.8866376876831055,225.9365234375,347.2131042480469,3.8363399505615234,175.85333251953125,315.1534729003906,23.08595848083496,207.78817749023438,350.5667724609375,9.71776008605957,169.63876342773438,329.195556640625,36.44424057006836,230.44189453125,317.53167724609375,-.9267317652702332,284.35980224609375,221.7354736328125,-10.449814796447754,285.5650634765625,264.9780578613281,-23.92240333557129,274.9562683105469,269.5750732421875,-17.530813217163086,292.2945861816406,254.3388671875,-28.237804412841797,273.01220703125,158.96517944335938,-.09002730250358582,248.7141571044922,152.65328979492188,-1.389674425125122,227.8582763671875,151.95883178710938,-1.2474606037139893,210.54685974121094,154.68576049804688,1.0268592834472656,198.41705322265625,161.3450469970703,4.723947048187256,191.10504150390625,186.9726104736328,13.84589958190918,153.60556030273438,229.93136596679688,39.786155700683594,202.93617248535156,206.47616577148438,9.13370418548584,218.19210815429688,209.81057739257812,5.49985933303833,237.618408203125,208.71490478515625,3.108225107192993,256.08367919921875,204.24436950683594,2.2745330333709717,270.3304138183594,198.43910217285156,2.0658209323883057,280.03753662109375,192.8920440673828,1.8290718793869019,154.55300903320312,233.4366455078125,61.95684814453125,275.45025634765625,273.9498596191406,-14.600406646728516,294.47747802734375,224.07571411132812,-19.41942596435547,297.1092529296875,265.4220275878906,-28.585128784179688,305.83050537109375,273.2985534667969,-26.266172409057617,297.0882568359375,268.02960205078125,-25.710546493530273,280.0792236328125,278.9830322265625,-12.655070304870605,308.76202392578125,274.71514892578125,-27.840410232543945,310.0816345214844,278.26849365234375,-20.86105728149414,278.5430603027344,181.00303649902344,4.947571754455566,287.54656982421875,184.307861328125,1.260591745376587,292.3014831542969,186.36598205566406,-3.143568992614746,209.09744262695312,179.09437561035156,7.914038181304932,201.1513214111328,174.12767028808594,8.084104537963867,332.9224853515625,215.6724853515625,-23.370018005371094,424.55767822265625,180.68113708496094,9.830978393554688,336.6293640136719,275.2829284667969,-20.78504180908203,469.8965148925781,125.57901000976562,38.99407958984375,382.28717041015625,192.43331909179688,3.4612600803375244,396.9390869140625,193.86790466308594,3.8914084434509277,411.00787353515625,193.62002563476562,5.549503803253174,429.71795654296875,186.66195678710938,10.617892265319824,370.05230712890625,188.40982055664062,3.9252419471740723,401.5653991699219,158.86630249023438,1.4472987651824951,386.22540283203125,159.340087890625,1.508786678314209,415.85626220703125,160.82952880859375,3.381333351135254,425.4224853515625,165.43167114257812,5.918134689331055,440.8648986816406,196.23458862304688,13.489381790161133,383.5614013671875,412.1856689453125,-1.2763981819152832,429.66766357421875,177.68446350097656,11.750621795654297,478.7536926269531,191.44679260253906,40.292274475097656,456.2593688964844,187.05970764160156,19.656951904296875,396.70855712890625,255.54208374023438,-3.1392972469329834,342.8689270019531,320.60870361328125,-16.659250259399414,340.4381408691406,337.6176452636719,-13.7393217086792,363.13134765625,325.23089599609375,-12.994629859924316,375.7514953613281,331.7568359375,-8.478598594665527,355.1566162109375,338.01800537109375,-11.234922409057617,366.4199523925781,339.488037109375,-7.100727081298828,394.68389892578125,356.0306396484375,.13269051909446716,334.7259216308594,267.0843811035156,-31.326902389526367,336.2799377441406,251.33706665039062,-33.022640228271484,446.9028625488281,149.9997100830078,7.749013900756836,365.2566833496094,216.65200805664062,-3.8045411109924316,371.8299865722656,262.5707702636719,-16.28518295288086,372.3122253417969,254.44293212890625,-14.348434448242188,439.06005859375,254.14584350585938,4.803002834320068,334.6656799316406,231.83706665039062,-29.320056915283203,412.4833679199219,134.77537536621094,-2.8003480434417725,432.9185485839844,139.5846405029297,1.896531343460083,456.6582336425781,97.67573547363281,27.524517059326172,348.30828857421875,146.11997985839844,-8.290468215942383,372.6208801269531,162.8184356689453,3.228713274002075,406.0555419921875,341.1844787597656,2.0252270698547363,469.9366149902344,338.3891296386719,53.86491394042969,360.842041015625,271.5228271484375,-14.121028900146484,347.8482360839844,277.2429504394531,-15.139877319335938,389.7527770996094,341.73504638671875,1.3748646974563599,382.7810974121094,340.7091064453125,-.3233203589916229,440.296630859375,129.44049072265625,5.1410088539123535,372.5621643066406,269.7780456542969,-13.115525245666504,384.7712707519531,135.73818969726562,-6.309181213378906,387.2312316894531,122.5787353515625,-7.326788425445557,399.4652099609375,60.144744873046875,4.721075057983398,448.0954895019531,112.34931945800781,14.905879974365234,391.7792663574219,89.46018981933594,-1.5736668109893799,454.69744873046875,143.20791625976562,13.139555931091309,462.18414306640625,134.90118408203125,25.395933151245117,342.05596923828125,330.6085510253906,-15.849852561950684,358.6634216308594,333.08514404296875,-12.385476112365723,371.0511474609375,335.9906005859375,-8.29167366027832,356.9338073730469,274.68096923828125,-13.09109878540039,386.1968078613281,341.385986328125,.4633089601993561,379.505615234375,343.56292724609375,-3.58079195022583,380.99072265625,339.9813537597656,-.56928950548172,351.92706298828125,266.1675109863281,-22.411170959472656,363.1768798828125,338.68280029296875,-6.149283409118652,351.8752136230469,338.9214782714844,-8.935256958007812,338.43121337890625,339.7230224609375,-11.266111373901367,345.47833251953125,383.5452880859375,-8.54257869720459,343.7301940917969,364.6892395019531,-13.523378372192383,342.5115051269531,354.8351135253906,-13.84434986114502,341.0390930175781,346.5924072265625,-12.141350746154785,339.55938720703125,341.4112854003906,-11.004034996032715,365.00738525390625,340.4651794433594,-6.095052242279053,367.36639404296875,342.3319396972656,-7.191629409790039,370.9842224121094,346.59893798828125,-8.184698104858398,374.2361755371094,352.38916015625,-7.224337100982666,388.0760803222656,312.992431640625,-6.49540376663208,480.3379821777344,261.6239013671875,63.763389587402344,372.50164794921875,340.673095703125,-2.910421848297119,375.647216796875,341.3985290527344,-3.5980868339538574,342.5552673339844,284.8035583496094,-15.550444602966309,367.3857421875,280.0863342285156,-9.014886856079102,345.03631591796875,281.2030029296875,-15.500083923339844,381.04669189453125,225.75692749023438,-1.7069110870361328,404.9681091308594,236.08831787109375,-.008579621091485023,374.9254150390625,261.70758056640625,-11.010907173156738,434.6033935546875,75.28443145751953,15.280303001403809,425.8450927734375,96.6444091796875,6.181840419769287,417.2605285644531,121.89888000488281,-1.3361674547195435,381.77252197265625,366.4750061035156,-3.2928552627563477,352.6125793457031,125.71281433105469,-10.41528606414795,356.1432189941406,87.92901611328125,-6.096003532409668,360.54925537109375,53.24565887451172,-1.6013318300247192,423.0085144042969,191.4607391357422,8.192007064819336,455.9168701171875,207.06011962890625,16.840869903564453,362.320556640625,184.3780059814453,4.786047458648682,441.0181579589844,169.07571411132812,11.076071739196777,354.32940673828125,206.4979248046875,-6.017457962036133,361.7270812988281,256.7944030761719,-22.147241592407227,470.78857421875,218.2230224609375,23.366037368774414,446.9043884277344,217.05377197265625,11.335209846496582,428.977783203125,222.14804077148438,5.704945087432861,401.39324951171875,219.66403198242188,2.709503650665283,380.70123291015625,213.15652465820312,1.3608025312423706,365.122802734375,205.7574920654297,-.3050336539745331,333.2375793457031,185.38961791992188,-12.339582443237305,470.42559814453125,250.09902954101562,21.368783950805664,452.41015625,166.84707641601562,14.01742935180664,329.67291259765625,275.4928894042969,-28.54446029663086,365.2168884277344,231.57791137695312,-6.41494607925415,480.26104736328125,192.2894287109375,60.1459846496582,353.3818359375,197.30165100097656,-1.2043124437332153,375.92144775390625,263.09228515625,-4.952785968780518,434.0610656738281,178.89532470703125,12.865796089172363,362.0376892089844,246.83267211914062,-19.729684829711914,477.7235412597656,299.0860290527344,60.44133758544922,362.7712707519531,178.93336486816406,6.433119297027588,348.4642639160156,237.6964111328125,-25.6434268951416,444.9437255859375,374.3408203125,22.08431625366211,443.3897399902344,393.920654296875,32.19438171386719,481.78631591796875,256.505615234375,42.56291961669922,460.74566650390625,352.44598388671875,29.870811462402344,470.4197998046875,160.69410705566406,34.579654693603516,387.6665344238281,430.642333984375,2.0062272548675537,328.07861328125,279.17724609375,-20.75840950012207,378.8198547363281,243.26248168945312,-4.24747371673584,467.50250244140625,190.25503540039062,25.744525909423828,409.82464599609375,184.141357421875,6.231921195983887,397.0033264160156,185.0110321044922,4.7111334800720215,383.4640197753906,346.753662109375,-2.522388458251953,469.2848205566406,281.7126159667969,22.92217445373535,360.1937255859375,455.74932861328125,2.9791202545166016,405.12158203125,431.91900634765625,15.62734603881836,423.4313049316406,416.1868591308594,22.959041595458984,384.67138671875,183.9629364013672,4.3632402420043945,373.213623046875,181.48912048339844,5.123116970062256,366.1402893066406,180.15541076660156,6.310164928436279,461.6444091796875,163.96163940429688,20.155040740966797,374.98333740234375,171.23558044433594,4.387862682342529,387.49774169921875,168.8740692138672,3.304352283477783,399.94378662109375,168.39108276367188,3.634413242340088,412.6290588378906,170.36415100097656,5.1217498779296875,420.96893310546875,173.51547241210938,7.114045143127441,476.9218444824219,155.16864013671875,50.95864486694336,418.4987487792969,182.4808807373047,8.162747383117676,374.7021179199219,303.31707763671875,-9.819207191467285,360.9924621582031,268.89068603515625,-16.321969985961914,344.3481140136719,298.4349365234375,-15.438346862792969,426.8325500488281,396.30877685546875,15.641507148742676,408.3316955566406,413.7490539550781,9.129907608032227,360.76519775390625,442.39337158203125,-4.226146221160889,457.8586120605469,370.0028991699219,43.47062301635742,366.5082092285156,175.42959594726562,5.558383464813232,344.51177978515625,209.68707275390625,-14.27273941040039,384.7861022949219,445.6679382324219,8.124580383300781,478.9347229003906,290.98956298828125,41.21711349487305,353.3740539550781,340.5323486328125,-8.78250789642334,355.8246154785156,344.3572082519531,-9.997100830078125,358.39141845703125,350.72332763671875,-11.240950584411621,360.680419921875,359.6910400390625,-10.636283874511719,365.86053466796875,376.1639099121094,-6.660977363586426,376.22296142578125,340.27056884765625,-3.5048739910125732,380.8910217285156,339.0758972167969,-3.475714921951294,385.29180908203125,336.63427734375,-3.401749610900879,399.6767883300781,325.93450927734375,-2.128159523010254,451.57861328125,288.81036376953125,10.718208312988281,343.4667053222656,194.96011352539062,-8.735547065734863,350.09100341796875,169.0031280517578,2.0712971687316895,359.6502990722656,171.5241241455078,4.450891017913818,372.62359619140625,338.539794921875,-2.956547975540161,454.8492431640625,328.1819152832031,19.078685760498047,337.1347351074219,167.7401123046875,-5.871736526489258,375.0529479980469,393.76483154296875,-3.6778383255004883,333.4227294921875,201.0952911376953,-18.425695419311523,356.4927062988281,234.01895141601562,-14.301460266113281,351.2936706542969,402.79620361328125,-7.5585551261901855,409.10919189453125,363.5516357421875,3.57236647605896,388.25555419921875,276.1095275878906,-3.709625244140625,393.75286865234375,380.920166015625,.1369001269340515,420.40191650390625,273.9984436035156,-.8729774355888367,401.9803161621094,292.1586608886719,-2.742661714553833,433.86163330078125,300.2438659667969,3.79644513130188,357.5480041503906,424.0931091308594,-7.21943998336792,366.2776184082031,243.02346801757812,-10.05320930480957,422.03759765625,376.86553955078125,9.139190673828125,403.22271728515625,395.7782897949219,4.615209102630615,420.5649108886719,343.19183349609375,4.793065071105957,466.7944641113281,309.1900329589844,24.664592742919922,438.3085021972656,345.8584899902344,10.867822647094727,473.22900390625,323.0245361328125,38.14845275878906,414.3385925292969,313.6124267578125,.012857065536081791,354.69293212890625,220.4129638671875,-10.033292770385742,356.8241271972656,263.5083312988281,-23.556297302246094,367.4049072265625,267.6433410644531,-17.09963607788086,349.74609375,253.279541015625,-27.92021942138672,361.42388916015625,157.93853759765625,.41821685433387756,385.1235046386719,150.96600341796875,-.6607803106307983,405.5707702636719,149.6215057373047,-.3118784427642822,422.8327941894531,151.75064086914062,2.1794090270996094,434.8728332519531,158.0150146484375,5.985780239105225,443.5646667480469,182.8747100830078,15.249552726745605,482.15576171875,223.59829711914062,41.767704010009766,433.39141845703125,202.36753845214844,10.402255058288574,418.7890625,206.17379760742188,6.606390953063965,399.58636474609375,205.84176635742188,4.021158218383789,381.0849609375,202.08261108398438,3.0047805309295654,366.6188659667969,196.7928924560547,2.618781566619873,356.5893859863281,191.5957794189453,2.271151542663574,480.2386474609375,226.94879150390625,63.96815872192383,367.0486755371094,272.0451965332031,-14.173871994018555,345.1959228515625,223.20333862304688,-19.10439682006836,345.7338562011719,264.4343566894531,-28.369665145874023,337.3208312988281,272.7472839355469,-26.105701446533203,345.6841125488281,267.1420593261719,-25.44144630432129,362.701171875,277.2493591308594,-12.29609489440918,334.5038757324219,274.249267578125,-27.719623565673828,333.1357727050781,277.93988037109375,-20.768848419189453,357.30718994140625,179.84762573242188,5.402637004852295,348.57269287109375,183.3765869140625,1.6270942687988281,344.1528015136719,185.49330139160156,-2.848400592803955,425.8621520996094,175.94349670410156,9.125075340270996,432.9592590332031,170.6381378173828,9.381414413452148];/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xl=[127,34,139,11,0,37,232,231,120,72,37,39,128,121,47,232,121,128,104,69,67,175,171,148,157,154,155,118,50,101,73,39,40,9,151,108,48,115,131,194,204,211,74,40,185,80,42,183,40,92,186,230,229,118,202,212,214,83,18,17,76,61,146,160,29,30,56,157,173,106,204,194,135,214,192,203,165,98,21,71,68,51,45,4,144,24,23,77,146,91,205,50,187,201,200,18,91,106,182,90,91,181,85,84,17,206,203,36,148,171,140,92,40,39,193,189,244,159,158,28,247,246,161,236,3,196,54,68,104,193,168,8,117,228,31,189,193,55,98,97,99,126,47,100,166,79,218,155,154,26,209,49,131,135,136,150,47,126,217,223,52,53,45,51,134,211,170,140,67,69,108,43,106,91,230,119,120,226,130,247,63,53,52,238,20,242,46,70,156,78,62,96,46,53,63,143,34,227,173,155,133,123,117,111,44,125,19,236,134,51,216,206,205,154,153,22,39,37,167,200,201,208,36,142,100,57,212,202,20,60,99,28,158,157,35,226,113,160,159,27,204,202,210,113,225,46,43,202,204,62,76,77,137,123,116,41,38,72,203,129,142,64,98,240,49,102,64,41,73,74,212,216,207,42,74,184,169,170,211,170,149,176,105,66,69,122,6,168,123,147,187,96,77,90,65,55,107,89,90,180,101,100,120,63,105,104,93,137,227,15,86,85,129,102,49,14,87,86,55,8,9,100,47,121,145,23,22,88,89,179,6,122,196,88,95,96,138,172,136,215,58,172,115,48,219,42,80,81,195,3,51,43,146,61,171,175,199,81,82,38,53,46,225,144,163,110,246,33,7,52,65,66,229,228,117,34,127,234,107,108,69,109,108,151,48,64,235,62,78,191,129,209,126,111,35,143,163,161,246,117,123,50,222,65,52,19,125,141,221,55,65,3,195,197,25,7,33,220,237,44,70,71,139,122,193,245,247,130,33,71,21,162,153,158,159,170,169,150,188,174,196,216,186,92,144,160,161,2,97,167,141,125,241,164,167,37,72,38,12,145,159,160,38,82,13,63,68,71,226,35,111,158,153,154,101,50,205,206,92,165,209,198,217,165,167,97,220,115,218,133,112,243,239,238,241,214,135,169,190,173,133,171,208,32,125,44,237,86,87,178,85,86,179,84,85,180,83,84,181,201,83,182,137,93,132,76,62,183,61,76,184,57,61,185,212,57,186,214,207,187,34,143,156,79,239,237,123,137,177,44,1,4,201,194,32,64,102,129,213,215,138,59,166,219,242,99,97,2,94,141,75,59,235,24,110,228,25,130,226,23,24,229,22,23,230,26,22,231,112,26,232,189,190,243,221,56,190,28,56,221,27,28,222,29,27,223,30,29,224,247,30,225,238,79,20,166,59,75,60,75,240,147,177,215,20,79,166,187,147,213,112,233,244,233,128,245,128,114,188,114,217,174,131,115,220,217,198,236,198,131,134,177,132,58,143,35,124,110,163,7,228,110,25,356,389,368,11,302,267,452,350,349,302,303,269,357,343,277,452,453,357,333,332,297,175,152,377,384,398,382,347,348,330,303,304,270,9,336,337,278,279,360,418,262,431,304,408,409,310,415,407,270,409,410,450,348,347,422,430,434,313,314,17,306,307,375,387,388,260,286,414,398,335,406,418,364,367,416,423,358,327,251,284,298,281,5,4,373,374,253,307,320,321,425,427,411,421,313,18,321,405,406,320,404,405,315,16,17,426,425,266,377,400,369,322,391,269,417,465,464,386,257,258,466,260,388,456,399,419,284,332,333,417,285,8,346,340,261,413,441,285,327,460,328,355,371,329,392,439,438,382,341,256,429,420,360,364,394,379,277,343,437,443,444,283,275,440,363,431,262,369,297,338,337,273,375,321,450,451,349,446,342,467,293,334,282,458,461,462,276,353,383,308,324,325,276,300,293,372,345,447,382,398,362,352,345,340,274,1,19,456,248,281,436,427,425,381,256,252,269,391,393,200,199,428,266,330,329,287,273,422,250,462,328,258,286,384,265,353,342,387,259,257,424,431,430,342,353,276,273,335,424,292,325,307,366,447,345,271,303,302,423,266,371,294,455,460,279,278,294,271,272,304,432,434,427,272,407,408,394,430,431,395,369,400,334,333,299,351,417,168,352,280,411,325,319,320,295,296,336,319,403,404,330,348,349,293,298,333,323,454,447,15,16,315,358,429,279,14,15,316,285,336,9,329,349,350,374,380,252,318,402,403,6,197,419,318,319,325,367,364,365,435,367,397,344,438,439,272,271,311,195,5,281,273,287,291,396,428,199,311,271,268,283,444,445,373,254,339,263,466,249,282,334,296,449,347,346,264,447,454,336,296,299,338,10,151,278,439,455,292,407,415,358,371,355,340,345,372,390,249,466,346,347,280,442,443,282,19,94,370,441,442,295,248,419,197,263,255,359,440,275,274,300,383,368,351,412,465,263,467,466,301,368,389,380,374,386,395,378,379,412,351,419,436,426,322,373,390,388,2,164,393,370,462,461,164,0,267,302,11,12,374,373,387,268,12,13,293,300,301,446,261,340,385,384,381,330,266,425,426,423,391,429,355,437,391,327,326,440,457,438,341,382,362,459,457,461,434,430,394,414,463,362,396,369,262,354,461,457,316,403,402,315,404,403,314,405,404,313,406,405,421,418,406,366,401,361,306,408,407,291,409,408,287,410,409,432,436,410,434,416,411,264,368,383,309,438,457,352,376,401,274,275,4,421,428,262,294,327,358,433,416,367,289,455,439,462,370,326,2,326,370,305,460,455,254,449,448,255,261,446,253,450,449,252,451,450,256,452,451,341,453,452,413,464,463,441,413,414,258,442,441,257,443,442,259,444,443,260,445,444,467,342,445,459,458,250,289,392,290,290,328,460,376,433,435,250,290,392,411,416,433,341,463,464,453,464,465,357,465,412,343,412,399,360,363,440,437,399,456,420,456,363,401,435,288,372,383,353,339,255,249,448,261,255,133,243,190,133,155,112,33,246,247,33,130,25,398,384,286,362,398,414,362,463,341,263,359,467,263,249,255,466,467,260,75,60,166,238,239,79,162,127,139,72,11,37,121,232,120,73,72,39,114,128,47,233,232,128,103,104,67,152,175,148,173,157,155,119,118,101,74,73,40,107,9,108,49,48,131,32,194,211,184,74,185,191,80,183,185,40,186,119,230,118,210,202,214,84,83,17,77,76,146,161,160,30,190,56,173,182,106,194,138,135,192,129,203,98,54,21,68,5,51,4,145,144,23,90,77,91,207,205,187,83,201,18,181,91,182,180,90,181,16,85,17,205,206,36,176,148,140,165,92,39,245,193,244,27,159,28,30,247,161,174,236,196,103,54,104,55,193,8,111,117,31,221,189,55,240,98,99,142,126,100,219,166,218,112,155,26,198,209,131,169,135,150,114,47,217,224,223,53,220,45,134,32,211,140,109,67,108,146,43,91,231,230,120,113,226,247,105,63,52,241,238,242,124,46,156,95,78,96,70,46,63,116,143,227,116,123,111,1,44,19,3,236,51,207,216,205,26,154,22,165,39,167,199,200,208,101,36,100,43,57,202,242,20,99,56,28,157,124,35,113,29,160,27,211,204,210,124,113,46,106,43,204,96,62,77,227,137,116,73,41,72,36,203,142,235,64,240,48,49,64,42,41,74,214,212,207,183,42,184,210,169,211,140,170,176,104,105,69,193,122,168,50,123,187,89,96,90,66,65,107,179,89,180,119,101,120,68,63,104,234,93,227,16,15,85,209,129,49,15,14,86,107,55,9,120,100,121,153,145,22,178,88,179,197,6,196,89,88,96,135,138,136,138,215,172,218,115,219,41,42,81,5,195,51,57,43,61,208,171,199,41,81,38,224,53,225,24,144,110,105,52,66,118,229,117,227,34,234,66,107,69,10,109,151,219,48,235,183,62,191,142,129,126,116,111,143,7,163,246,118,117,50,223,222,52,94,19,141,222,221,65,196,3,197,45,220,44,156,70,139,188,122,245,139,71,162,145,153,159,149,170,150,122,188,196,206,216,92,163,144,161,164,2,167,242,141,241,0,164,37,11,72,12,144,145,160,12,38,13,70,63,71,31,226,111,157,158,154,36,101,205,203,206,165,126,209,217,98,165,97,237,220,218,237,239,241,210,214,169,140,171,32,241,125,237,179,86,178,180,85,179,181,84,180,182,83,181,194,201,182,177,137,132,184,76,183,185,61,184,186,57,185,216,212,186,192,214,187,139,34,156,218,79,237,147,123,177,45,44,4,208,201,32,98,64,129,192,213,138,235,59,219,141,242,97,97,2,141,240,75,235,229,24,228,31,25,226,230,23,229,231,22,230,232,26,231,233,112,232,244,189,243,189,221,190,222,28,221,223,27,222,224,29,223,225,30,224,113,247,225,99,60,240,213,147,215,60,20,166,192,187,213,243,112,244,244,233,245,245,128,188,188,114,174,134,131,220,174,217,236,236,198,134,215,177,58,156,143,124,25,110,7,31,228,25,264,356,368,0,11,267,451,452,349,267,302,269,350,357,277,350,452,357,299,333,297,396,175,377,381,384,382,280,347,330,269,303,270,151,9,337,344,278,360,424,418,431,270,304,409,272,310,407,322,270,410,449,450,347,432,422,434,18,313,17,291,306,375,259,387,260,424,335,418,434,364,416,391,423,327,301,251,298,275,281,4,254,373,253,375,307,321,280,425,411,200,421,18,335,321,406,321,320,405,314,315,17,423,426,266,396,377,369,270,322,269,413,417,464,385,386,258,248,456,419,298,284,333,168,417,8,448,346,261,417,413,285,326,327,328,277,355,329,309,392,438,381,382,256,279,429,360,365,364,379,355,277,437,282,443,283,281,275,363,395,431,369,299,297,337,335,273,321,348,450,349,359,446,467,283,293,282,250,458,462,300,276,383,292,308,325,283,276,293,264,372,447,346,352,340,354,274,19,363,456,281,426,436,425,380,381,252,267,269,393,421,200,428,371,266,329,432,287,422,290,250,328,385,258,384,446,265,342,386,387,257,422,424,430,445,342,276,422,273,424,306,292,307,352,366,345,268,271,302,358,423,371,327,294,460,331,279,294,303,271,304,436,432,427,304,272,408,395,394,431,378,395,400,296,334,299,6,351,168,376,352,411,307,325,320,285,295,336,320,319,404,329,330,349,334,293,333,366,323,447,316,15,315,331,358,279,317,14,316,8,285,9,277,329,350,253,374,252,319,318,403,351,6,419,324,318,325,397,367,365,288,435,397,278,344,439,310,272,311,248,195,281,375,273,291,175,396,199,312,311,268,276,283,445,390,373,339,295,282,296,448,449,346,356,264,454,337,336,299,337,338,151,294,278,455,308,292,415,429,358,355,265,340,372,388,390,466,352,346,280,295,442,282,354,19,370,285,441,295,195,248,197,457,440,274,301,300,368,417,351,465,251,301,389,385,380,386,394,395,379,399,412,419,410,436,322,387,373,388,326,2,393,354,370,461,393,164,267,268,302,12,386,374,387,312,268,13,298,293,301,265,446,340,380,385,381,280,330,425,322,426,391,420,429,437,393,391,326,344,440,438,458,459,461,364,434,394,428,396,262,274,354,457,317,316,402,316,315,403,315,314,404,314,313,405,313,421,406,323,366,361,292,306,407,306,291,408,291,287,409,287,432,410,427,434,411,372,264,383,459,309,457,366,352,401,1,274,4,418,421,262,331,294,358,435,433,367,392,289,439,328,462,326,94,2,370,289,305,455,339,254,448,359,255,446,254,253,449,253,252,450,252,256,451,256,341,452,414,413,463,286,441,414,286,258,441,258,257,442,257,259,443,259,260,444,260,467,445,309,459,250,305,289,290,305,290,460,401,376,435,309,250,392,376,411,433,453,341,464,357,453,465,343,357,412,437,343,399,344,360,440,420,437,456,360,420,363,361,401,288,265,372,353,390,339,249,339,448,255],La=(n,e,t)=>Math.max(Math.min(n,t),e),$r=(n,e,t)=>(La(n,e,t)-e)/(t-e);class xe{constructor(e,t,s){var r,i,o,a,l,c;if(Array.isArray(e)){this.x=(r=e[0])!==null&&r!==void 0?r:0,this.y=(i=e[1])!==null&&i!==void 0?i:0,this.z=(o=e[2])!==null&&o!==void 0?o:0;return}if(!!e&&typeof e=="object"){this.x=(a=e.x)!==null&&a!==void 0?a:0,this.y=(l=e.y)!==null&&l!==void 0?l:0,this.z=(c=e.z)!==null&&c!==void 0?c:0;return}this.x=e!=null?e:0,this.y=t!=null?t:0,this.z=s!=null?s:0}negative(){return new xe(-this.x,-this.y,-this.z)}add(e){return e instanceof xe?new xe(this.x+e.x,this.y+e.y,this.z+e.z):new xe(this.x+e,this.y+e,this.z+e)}subtract(e){return e instanceof xe?new xe(this.x-e.x,this.y-e.y,this.z-e.z):new xe(this.x-e,this.y-e,this.z-e)}multiply(e){return e instanceof xe?new xe(this.x*e.x,this.y*e.y,this.z*e.z):new xe(this.x*e,this.y*e,this.z*e)}divide(e){return e instanceof xe?new xe(this.x/e.x,this.y/e.y,this.z/e.z):new xe(this.x/e,this.y/e,this.z/e)}equals(e){return this.x==e.x&&this.y==e.y&&this.z==e.z}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}cross(e){return new xe(this.y*e.z-this.z*e.y,this.z*e.x-this.x*e.z,this.x*e.y-this.y*e.x)}length(){return Math.sqrt(this.dot(this))}distance(e,t=3){return Math.sqrt(t===2?Math.pow(this.x-e.x,2)+Math.pow(this.y-e.y,2):Math.pow(this.x-e.x,2)+Math.pow(this.y-e.y,2)+Math.pow(this.z-e.z,2))}lerp(e,t){return e.subtract(this).multiply(t).add(this)}unit(){return this.divide(this.length())}min(){return Math.min(Math.min(this.x,this.y),this.z)}max(){return Math.max(Math.max(this.x,this.y),this.z)}toAngles(){return{theta:Math.atan2(this.z,this.x),phi:Math.asin(this.y/this.length())}}angleTo(e){return Math.acos(this.dot(e)/(this.length()*e.length()))}toArray(e){return[this.x,this.y,this.z].slice(0,e||3)}clone(){return new xe(this.x,this.y,this.z)}init(e,t,s){return this.x=e,this.y=t,this.z=s,this}static negative(e,t=new xe){return t.x=-e.x,t.y=-e.y,t.z=-e.z,t}static add(e,t,s=new xe){return t instanceof xe?(s.x=e.x+t.x,s.y=e.y+t.y,s.z=e.z+t.z):(s.x=e.x+t,s.y=e.y+t,s.z=e.z+t),s}static subtract(e,t,s=new xe){return t instanceof xe?(s.x=e.x-t.x,s.y=e.y-t.y,s.z=e.z-t.z):(s.x=e.x-t,s.y=e.y-t,s.z=e.z-t),s}static multiply(e,t,s=new xe){return t instanceof xe?(s.x=e.x*t.x,s.y=e.y*t.y,s.z=e.z*t.z):(s.x=e.x*t,s.y=e.y*t,s.z=e.z*t),s}static divide(e,t,s=new xe){return t instanceof xe?(s.x=e.x/t.x,s.y=e.y/t.y,s.z=e.z/t.z):(s.x=e.x/t,s.y=e.y/t,s.z=e.z/t),s}static cross(e,t,s=new xe){return s.x=e.y*t.z-e.z*t.y,s.y=e.z*t.x-e.x*t.z,s.z=e.x*t.y-e.y*t.x,s}static unit(e,t){let s=e.length();return t.x=e.x/s,t.y=e.y/s,t.z=e.z/s,t}static fromAngles(e,t){return new xe(Math.cos(e)*Math.cos(t),Math.sin(t),Math.sin(e)*Math.cos(t))}static randomDirection(){return xe.fromAngles(Math.random()*Math.PI*2,Math.asin(Math.random()*2-1))}static min(e,t){return new xe(Math.min(e.x,t.x),Math.min(e.y,t.y),Math.min(e.z,t.z))}static max(e,t){return new xe(Math.max(e.x,t.x),Math.max(e.y,t.y),Math.max(e.z,t.z))}static lerp(e,t,s){return t instanceof xe?t.subtract(e).multiply(s).add(e):(t-e)*s+e}static fromArray(e){return Array.isArray(e)?new xe(e[0],e[1],e[2]):new xe(e.x,e.y,e.z)}static angleBetween(e,t){return e.angleTo(t)}static angleBetweenVertices(e,t,s){e.subtract(t),s.subtract(t)}static distance(e,t,s){return Math.sqrt(s===2?Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2):Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2)+Math.pow(e.z-t.z,2))}static toDegrees(e){return e*(180/Math.PI)}static normalizeAngle(e){let t=Math.PI*2,s=e%t;return s=s>Math.PI?s-t:s<-Math.PI?t+s:s,s/Math.PI}static normalizeRadians(e){return e>=Math.PI/2&&(e-=2*Math.PI),e<=-Math.PI/2&&(e+=2*Math.PI,e=Math.PI-e),e/Math.PI}static find2DAngle(e,t,s,r){var i=r-t,o=s-e,a=Math.atan2(i,o);return a}static findRotation(e,t,s=!0){return s?new xe(xe.normalizeRadians(xe.find2DAngle(e.z,e.x,t.z,t.x)),xe.normalizeRadians(xe.find2DAngle(e.z,e.y,t.z,t.y)),xe.normalizeRadians(xe.find2DAngle(e.x,e.y,t.x,t.y))):new xe(xe.find2DAngle(e.z,e.x,t.z,t.x),xe.find2DAngle(e.z,e.y,t.z,t.y),xe.find2DAngle(e.x,e.y,t.x,t.y))}static rollPitchYaw(e,t,s){if(!s)return new xe(xe.normalizeAngle(xe.find2DAngle(e.z,e.y,t.z,t.y)),xe.normalizeAngle(xe.find2DAngle(e.z,e.x,t.z,t.x)),xe.normalizeAngle(xe.find2DAngle(e.x,e.y,t.x,t.y)));let r=t.subtract(e),i=s.subtract(e),a=r.cross(i).unit(),l=r.unit(),c=a.cross(l),u=Math.asin(a.x)||0,h=Math.atan2(-a.y,a.z)||0,d=Math.atan2(-c.x,l.x)||0;return new xe(xe.normalizeAngle(h),xe.normalizeAngle(u),xe.normalizeAngle(d))}static angleBetween3DCoords(e,t,s){e instanceof xe||(e=new xe(e),t=new xe(t),s=new xe(s));const r=e.subtract(t),i=s.subtract(t),o=r.unit(),a=i.unit(),l=o.dot(a),c=Math.acos(l);return xe.normalizeRadians(c)}}const hH=n=>{let e=new xe(n[21]),t=new xe(n[251]),s=new xe(n[397]),r=new xe(n[172]),i=s.lerp(r,.5);return{vector:[e,t,i],points:[e,t,s,r]}},dH=n=>{const e=hH(n).vector;let t=xe.rollPitchYaw(e[0],e[1],e[2]),s=e[0].lerp(e[1],.5),r=e[0].distance(e[1]),i=s.distance(e[2]);return t.x*=-1,t.z*=-1,{y:t.y*Math.PI,x:t.x*Math.PI,z:t.z*Math.PI,width:r,height:i,position:s.lerp(e[2],.5),normalized:{y:t.y,x:t.x,z:t.z},degrees:{y:t.y*180,x:t.x*180,z:t.z*180}}},jl={eye:{left:[130,133,160,159,158,144,145,153],right:[263,362,387,386,385,373,374,380]},brow:{left:[35,244,63,105,66,229,230,231],right:[265,464,293,334,296,449,450,451]},pupil:{left:[468,469,470,471,472],right:[473,474,475,476,477]}},C5=(n,e="left",{high:t=.85,low:s=.55}={})=>{let r=jl.eye[e],i=M5(n[r[0]],n[r[1]],n[r[2]],n[r[3]],n[r[4]],n[r[5]],n[r[6]],n[r[7]]),a=La(i/.285,0,2);return{norm:$r(a,s,t),raw:a}},M5=(n,e,t,s,r,i,o,a)=>{n=new xe(n),e=new xe(e),t=new xe(t),s=new xe(s),r=new xe(r),i=new xe(i),o=new xe(o),a=new xe(a);const l=n.distance(e,2),c=t.distance(i,2),u=s.distance(o,2),h=r.distance(a,2);return(c+u+h)/3/l},A5=(n,e="left")=>{const t=new xe(n[jl.eye[e][0]]),s=new xe(n[jl.eye[e][1]]),r=t.distance(s,2),i=t.lerp(s,.5),o=new xe(n[jl.pupil[e][0]]),a=i.x-o.x,l=i.y-r*.075-o.y;let c=a/(r/2),u=l/(r/4);return c*=4,u*=4,{x:c,y:u}},R5=(n,e,{enableWink:t=!0,maxRot:s=.5}={})=>{n.r=La(n.r,0,1),n.l=La(n.l,0,1);const r=Math.abs(n.l-n.r),i=t?.8:1.2,o=n.l<.3&&n.r<.3,a=n.l>.6&&n.r>.6;return e>s?{l:n.r,r:n.r}:e<-s?{l:n.l,r:n.l}:{l:r>=i&&!o&&!a?n.l:n.r>n.l?xe.lerp(n.r,n.l,.95):xe.lerp(n.r,n.l,.05),r:r>=i&&!o&&!a?n.r:n.r>n.l?xe.lerp(n.r,n.l,.95):xe.lerp(n.r,n.l,.05)}},pH=(n,{high:e=.85,low:t=.55}={})=>{if(n.length!==478)return{l:1,r:1};const s=C5(n,"left",{high:e,low:t}),r=C5(n,"right",{high:e,low:t});return{l:s.norm||0,r:r.norm||0}},fH=n=>{if(n.length!==478)return{x:0,y:0};{const e=A5(n,"left"),t=A5(n,"right");return{x:(e.x+t.x)*.5||0,y:(e.y+t.y)*.5||0}}},I5=(n,e="left")=>{let t=jl.brow[e],s=M5(n[t[0]],n[t[1]],n[t[2]],n[t[3]],n[t[4]],n[t[5]],n[t[6]],n[t[7]]),r=1.15,i=.125,o=.07,a=s/r-1;return(La(a,o,i)-o)/(i-o)},mH=n=>{if(n.length!==478)return 0;{const e=I5(n,"left"),t=I5(n,"right");return(e+t)/2||0}},gH=n=>{const e=new xe(n[133]),t=new xe(n[362]),s=new xe(n[130]),r=new xe(n[263]),i=e.distance(t),o=s.distance(r),a=new xe(n[13]),l=new xe(n[14]),c=new xe(n[61]),u=new xe(n[291]),h=a.distance(l),d=c.distance(u);let p=h/i,f=d/o;p=$r(p,.15,.7),f=$r(f,.45,.9),f=(f-.3)*2;const m=f,y=$r(h/i,.17,.5);let g=La($r(m,0,1)*2*$r(y,.2,.7),0,1),x=y*.4+y*(1-g)*.6,b=y*$r(1-g,0,.3)*.1,w=$r(b,.2,1)*(1-g)*.3,C=(1-g)*$r(y,.3,1)*.4;return{x:f||0,y:p||0,shape:{A:x||0,E:w||0,I:g||0,O:C||0,U:b||0}}};class N5{constructor(){}static solve(e,{runtime:t="tfjs",video:s=null,imageSize:r=null,smoothBlink:i=!1,blinkSettings:o=[]}={}){if(!e){console.error("Need Face Landmarks");return}if(s){const d=typeof s=="string"?document.querySelector(s):s;r={width:d.videoWidth,height:d.videoHeight}}t==="mediapipe"&&r&&e.forEach(d=>{d.x*=r.width,d.y*=r.height,d.z*=r.width});let a=dH(e),l=gH(e);o=o.length>0?o:t==="tfjs"?[.55,.85]:[.35,.5];let c=pH(e,{high:o[1],low:o[0]});i&&(c=R5(c,a.y));let u=fH(e),h=mH(e);return{head:a,eye:c,brow:h,pupil:u,mouth:l}}}N5.stabilizeBlink=R5;function kn(n,e=0,t=1){const s=new L(...n[e]),r=new L(...n[t]);return s.distanceTo(r)}function $n(n,e=0,t=1,s=2){const r=new L(...n[e]),i=new L(...n[t]),o=new L(...n[s]),a=new ze,l=i.clone().sub(o).normalize(),c=i.clone().add(o).multiplyScalar(.5).sub(r).multiplyScalar(-1).normalize(),u=new L().crossVectors(l,c).normalize();return a.makeBasis(l,c,u),a.invert()}function xH(n){return n.map(e=>({x:e[0],y:e[1],z:e[2]}))}function yH(n,e){return N5.solve(xH(n.scaledMesh),{runtime:"tfjs",video:e,imageSize:{height:480,width:640},smoothBlink:!1,blinkSettings:[.25,.75]})}function vH(n,e,t=.8){const s=n.scaledMesh.map((a,l)=>{const c=e.scaledMesh[l];return o(c,a)}),r=n.annotations,i=e.annotations;Object.keys(r).forEach(a=>{r[a]=r[a].map((l,c)=>{const u=i[a][c];return o(u,l)})});function o(a,l){const c=new L(...a),u=new L(...l),{x:h,y:d,z:p}=c.lerp(u,t);return[h,d,p]}return Sf(Vu({},n),{scaledMesh:s})}function as(n){const e={},t=s=>{if(s.type==="Mesh"&&s.morphTargetInfluences){const r=s;Object.keys(r.morphTargetDictionary).forEach(i=>{e[i]=o=>{r.morphTargetInfluences[r.morphTargetDictionary[i]]=o}})}s.children.forEach(t)};return t(n),e}function Bu(n,e){return Math.sqrt(Math.pow(n[0]-e[0],2)+Math.pow(n[1]-e[1],2))}function L5(n,e,t){const s=new Path2D;s.moveTo(e[0][0],e[0][1]);for(let r=1;r<e.length;r++){const i=e[r];s.lineTo(i[0],i[1])}t&&s.closePath(),n.stroke(s)}function bH(n,e,t,s){const r=468,i=5;n.clearRect(0,0,1e3,1e3),e.forEach(o=>{const a=o.scaledMesh;if(s){n.strokeStyle="#FF2C35",n.lineWidth=1;const l=o.boundingBox;L5(n,[[l.topLeft[0],l.topLeft[1]],[l.bottomRight[0],l.topLeft[1]],[l.bottomRight[0],l.bottomRight[1]],[l.topLeft[0],l.bottomRight[1]]],!0)}if(t){n.strokeStyle="#32EEDB",n.lineWidth=.5;for(let l=0;l<Xl.length/3;l++){const c=[Xl[l*3],Xl[l*3+1],Xl[l*3+2]].map(u=>a[u]);L5(n,c,!0)}}else{n.fillStyle="#32EEDB";for(let l=0;l<r;l++){const c=a[l][0],u=a[l][1];n.beginPath(),n.arc(c,u,1,0,2*Math.PI),n.fill()}}if(a.length>r){n.strokeStyle="#FF2C35",n.lineWidth=1;const l=a[r],c=Bu(a[r+4],a[r+2]),u=Bu(a[r+3],a[r+1]);if(n.beginPath(),n.ellipse(l[0],l[1],u/2,c/2,0,0,2*Math.PI),n.stroke(),a.length>r+i){const h=a[r+i],d=Bu(a[r+i+2],a[r+i+4]),p=Bu(a[r+i+3],a[r+i+1]);n.beginPath(),n.ellipse(h[0],h[1],p/2,d/2,0,0,2*Math.PI),n.stroke()}}})}function wH(n,e){const t=n.load(e);t.encoding=ti,t.anisotropy=16;const s=.5;return new Ks({map:t,transparent:!0,color:new Le(16777215),reflectivity:s})}function _H(n,e){let t=window.innerWidth-170,s=window.innerHeight;const r=e.videoWidth,i=e.videoHeight,o=new wu,a=new wu,l=new yW,c=new zy(e),u=new fn(new ma(r,i),new Ks({map:c}));u.position.set(0,0,-1e3);const h=u.clone(),d=new Ml(t/-2,t/2,s/2,s/-2,.1,2e3);d.position.set(0,0,1e3),d.lookAt(o.position);const p=new Lt({canvas:n,alpha:!0,antialias:!0});p.setPixelRatio(window.devicePixelRatio),p.setSize(t,s);const f=new n5(16777215,16777215,.3);o.add(f);const m=new d5(16777215,.7);o.add(m);const y=new nf(16777215,.7);y.position.set(.5,0,.866),o.add(y);const g=new Wt;g.setIndex(Xl),g.setAttribute("position",new tn(uH,3)),g.setAttribute("uv",new tn(cH.map((R,K)=>K%2?R:1-R),2)),g.computeVertexNormals();const x=new Qp,b=new $W;let w=null,C=null;function M(R){const F=P5(R.scaledMesh,r,i).reduce((z,V)=>z.concat(V),[]);g.setAttribute("position",new tn(F,3)),g.attributes.position.needsUpdate=!0}let E=null;function A(R,K){var F;if((K==null?void 0:K.background)?(o.add(u),a.add(h)):(o.remove(u),a.remove(h)),R){const z=R.annotations;Object.keys(z).forEach(H=>{z[H]=P5(z[H],r,i)});const V=yH(R,e);E&&(R=vH(R,E)),(w==null?void 0:w.type)==="model"&&((F=w.loader)==null||F.track(C,R,l,V)),(w==null?void 0:w.type)==="texture"&&M(R),p.render(o,d),E=R}else p.render(a,d),E=null}function $(){t=window.innerWidth-170,s=window.innerHeight;const R=t/s,K=r/i,F=R>K?t/r:s/i;o.scale.set(-F,F,1),a.scale.set(-F,F,1),d.top=s/2,d.bottom=s/-2,d.left=t/-2,d.right=t/2,d.updateProjectionMatrix(),p.setSize(t,s)}function B(R){if(C&&o.remove(C),w=R,R.type==="model")C=R.loader.build(b);else if(R.type==="texture"){const K=R.texture?R.texture(x):wH(x,R.path);C=new fn(g,K)}o.add(C),window.model=C}return[A,$,B]}function P5(n,e,t){return n.map(s=>[s[0]-e/2,t/2-s[1],-s[2]])}function SH(n){const e=new Ye;e.position.set(0,0,0),n.load("/ARFaceEffects/models/stereo-glasses.glb",r=>{r.scene.scale.set(1.1,1.1,-1.1),r.scene.position.set(0,0,0),e.add(r.scene)});const t=new fn(new ma(.5,.25,32),new no({color:16762920,transparent:!0,opacity:.5,roughness:.25}));t.position.copy(new L(-.3,-.01,0)),e.add(t);const s=new fn(new ma(.5,.25,32),new no({color:11358463,transparent:!0,opacity:.5,roughness:.25}));return s.position.copy(new L(.3,-.01,0)),e.add(s),e}function TH(n,e){const s=e.annotations.midwayBetweenEyes[0],r=kn(e.scaledMesh,234,454),i=$n(e.scaledMesh,10,50,280);n.position.set(...s),n.scale.setScalar(r),n.rotation.setFromRotationMatrix(i),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05)}const EH={build:SH,track:TH};function CH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/zelda_-_breath_of_the_wild/scene.gltf",t=>{t.scene.scale.setScalar(6),t.scene.position.set(-30,-920,-100),e.add(t.scene)}),e}function MH(n,e){const s=e.annotations.midwayBetweenEyes[0],r=kn(e.scaledMesh,234,454),i=$n(e.scaledMesh,10,50,280);n.position.set(...s),n.scale.setScalar(r/100),n.rotation.setFromRotationMatrix(i),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05)}const AH={build:CH,track:MH};function RH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/genshin_impact_barbara/scene.gltf",t=>{t.scene.scale.setScalar(60),t.scene.position.set(0,-1050,-100),t.scene.rotation.y=Math.PI,e.add(t.scene)}),e}function IH(n,e){const s=e.annotations.midwayBetweenEyes[0],r=kn(e.scaledMesh,234,454),i=$n(e.scaledMesh,10,50,280);n.position.set(...s),n.scale.setScalar(r/100),n.rotation.setFromRotationMatrix(i),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05)}const NH={build:RH,track:IH};let xi;function LH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/bingdundun/bingdundun.glb",t=>{console.log(t),t.scene.scale.setScalar(300),t.scene.position.set(0,-150,-50),e.add(t.scene),window.gltf=t,xi=as(t.scene)}),e}function PH(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/100),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),xi&&(xi.leftEye&&xi.leftEye(1-s.eye.r),xi.rightEye&&xi.rightEye(1-s.eye.l),xi.mouth&&xi.mouth(s.mouth.shape.A))}const DH={build:LH,track:PH};let er;function kH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/panda.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y-1,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),er=as(t.scene)}),e}function $H(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),er&&(er.leftEye&&er.leftEye(1-s.eye.r),er.rightEye&&er.rightEye(1-s.eye.l),er.mouth&&er.mouth(s.mouth.shape.A),er.tongue&&er.tongue(s.mouth.shape.A))}const FH={build:kH,track:$H};let tr;function OH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/rabit.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y+13,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),tr=as(t.scene)}),e}function BH(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),tr&&(tr.leftEye&&tr.leftEye(1-s.eye.r),tr.rightEye&&tr.rightEye(1-s.eye.l),tr.mouth&&tr.mouth(s.mouth.shape.A),tr.tongue&&tr.tongue(s.mouth.shape.A))}const zH={build:OH,track:BH};let nr;function UH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/deer.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y+6,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),nr=as(t.scene)}),e}function VH(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),nr&&(nr.leftEye&&nr.leftEye(1-s.eye.r),nr.rightEye&&nr.rightEye(1-s.eye.l),nr.mouth&&nr.mouth(s.mouth.shape.A),nr.tongue&&nr.tongue(s.mouth.shape.A))}const GH={build:UH,track:VH};let sr;function WH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/giraffe.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y+5,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),sr=as(t.scene)}),e}function HH(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),sr&&(sr.leftEye&&sr.leftEye(1-s.eye.r),sr.rightEye&&sr.rightEye(1-s.eye.l),sr.mouth&&sr.mouth(s.mouth.shape.A),sr.tongue&&sr.tongue(s.mouth.shape.A))}const XH={build:WH,track:HH};let rr;function jH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/tiger.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y-2,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),rr=as(t.scene)}),e}function qH(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),rr&&(rr.leftEye&&rr.leftEye(1-s.eye.r),rr.rightEye&&rr.rightEye(1-s.eye.l),rr.mouth&&rr.mouth(s.mouth.shape.A),rr.tongue&&rr.tongue(s.mouth.shape.A))}const KH={build:jH,track:qH};let ir;function YH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/monkey.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y+2,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),ir=as(t.scene)}),e}function ZH(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),ir&&(ir.leftEye&&ir.leftEye(1-s.eye.r),ir.rightEye&&ir.rightEye(1-s.eye.l),ir.mouth&&ir.mouth(s.mouth.shape.A),ir.tongue&&ir.tongue(s.mouth.shape.A))}const JH={build:YH,track:ZH};let or;function QH(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/lion.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),or=as(t.scene)}),e}function eX(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/22),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),or&&(or.leftEye&&or.leftEye(1-s.eye.r),or.rightEye&&or.rightEye(1-s.eye.l),or.mouth&&or.mouth(s.mouth.shape.A),or.tongue&&or.tongue(s.mouth.shape.A))}const tX={build:QH,track:eX};let ar;function nX(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/elephant.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y-5,s.position.z+=s.position.z-i.z-10,window.gltf=t,e.add(s),ar=as(t.scene)}),e}function sX(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),ar&&(ar.leftEye&&ar.leftEye(1-s.eye.r),ar.rightEye&&ar.rightEye(1-s.eye.l),ar.mouth&&ar.mouth(s.mouth.shape.A),ar.tongue&&ar.tongue(s.mouth.shape.A))}const rX={build:nX,track:sX};let lr;function iX(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/cow.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),lr=as(t.scene)}),e}function oX(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/22),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),lr&&(lr.leftEye&&lr.leftEye(1-s.eye.r),lr.rightEye&&lr.rightEye(1-s.eye.l),lr.mouth&&lr.mouth(s.mouth.shape.A),lr.tongue&&lr.tongue(s.mouth.shape.A))}const aX={build:iX,track:oX};let cr;function lX(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/bear.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y+1,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),cr=as(t.scene)}),e}function cX(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/18),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),cr&&(cr.leftEye&&cr.leftEye(1-s.eye.r),cr.rightEye&&cr.rightEye(1-s.eye.l),cr.mouth&&cr.mouth(s.mouth.shape.A),cr.tongue&&cr.tongue(s.mouth.shape.A))}const uX={build:lX,track:cX};let ur;function hX(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/pig.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),ur=as(t.scene)}),e}function dX(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),ur&&(ur.leftEye&&ur.leftEye(1-s.eye.r),ur.rightEye&&ur.rightEye(1-s.eye.l),ur.mouth&&ur.mouth(s.mouth.shape.A),ur.tongue&&ur.tongue(s.mouth.shape.A))}const pX={build:hX,track:dX};let hr;function fX(n){const e=new Ye;return e.position.set(0,0,0),n.load("/ARFaceEffects/models/animal_head/dog.glb",t=>{console.log(t);const s=t.scene,r=new jt().setFromObject(s);r.getSize(new L).length();const i=r.getCenter(new L);s.position.x+=s.position.x-i.x,s.position.y+=s.position.y-i.y-2,s.position.z+=s.position.z-i.z-15,window.gltf=t,e.add(s),hr=as(t.scene)}),e}function mX(n,e,t,s){const i=e.annotations.midwayBetweenEyes[0],o=kn(e.scaledMesh,234,454),a=$n(e.scaledMesh,10,50,280);n.position.set(...i),n.scale.setScalar(o/20),n.scale.x*=-1,n.rotation.setFromRotationMatrix(a),n.rotation.y=-n.rotation.y,n.rotateZ(Math.PI),n.rotateX(-Math.PI*.05),hr&&(hr.leftEye&&hr.leftEye(1-s.eye.r),hr.rightEye&&hr.rightEye(1-s.eye.l),hr.mouth&&hr.mouth(s.mouth.shape.A),hr.tongue&&hr.tongue(s.mouth.shape.A))}const gX={build:fX,track:mX};const xX=Tf({props:{autoSelectFirst:Boolean},setup(n,{emit:e}){const t="/ARFaceEffects/",s=[{name:"lion",thumb:t+"models/animal_head/lion.png",type:"model",loader:tX},{name:"panda",thumb:t+"models/animal_head/panda.png",type:"model",loader:FH},{name:"rabit",thumb:t+"models/animal_head/rabit.png",type:"model",loader:zH},{name:"deer",thumb:t+"models/animal_head/deer.png",type:"model",loader:GH},{name:"giraffe",thumb:t+"models/animal_head/giraffe.png",type:"model",loader:XH},{name:"tiger",thumb:t+"models/animal_head/tiger.png",type:"model",loader:KH},{name:"monkey",thumb:t+"models/animal_head/monkey.png",type:"model",loader:JH},{name:"elephant",thumb:t+"models/animal_head/elephant.png",type:"model",loader:rX},{name:"cow",thumb:t+"models/animal_head/cow.png",type:"model",loader:aX},{name:"bear",thumb:t+"models/animal_head/bear.png",type:"model",loader:uX},{name:"pig",thumb:t+"models/animal_head/pig.png",type:"model",loader:pX},{name:"dog",thumb:t+"models/animal_head/dog.png",type:"model",loader:gX},{name:"facepaint",thumb:t+"textures/facepaint.png",type:"texture",path:t+"textures/facepaint.png"},{name:"cheek",thumb:t+"textures/cheek.png",thumbBg:"white",type:"texture",path:t+"textures/cheek.png"},{name:"makeup",thumb:t+"textures/makeup.png",thumbBg:"white",type:"texture",path:t+"textures/makeup.png"},{name:"glasses",thumb:"",type:"model",loader:EH},{name:"zelda",thumb:"",type:"model",loader:AH},{name:"barbara",thumb:"",type:"model",loader:NH},{name:"bingdundun",thumb:"",type:"model",loader:DH}],r=Zl(),i=o=>{r.value=o,e("change",o)};return n.autoSelectFirst&&i(s[0]),{data:s,current:r,onClick:i}}}),yX={class:"gallery"},vX=["onClick"],bX={key:1,class:"name"};function wX(n,e,t,s,r,i){return co(),uo("div",yX,[(co(!0),uo(Ef,null,e9(n.data,o=>(co(),uo("div",{key:o.name,class:Cf(["item",{active:n.current&&n.current.name===o.name}]),onClick:a=>n.onClick(o)},[o.thumb?(co(),uo("div",{key:0,class:"thumb",style:t9({backgroundImage:`url(${o.thumb})`,backgroundColor:o.thumbBg})},null,4)):(co(),uo("div",bX,Mf(o.name),1))],10,vX))),128))])}var _X=Af(xX,[["render",wX],["__scopeId","data-v-29d881bc"]]);const df="/ARFaceEffects/",SX=Tf({components:{Gallery:_X},setup(){const n=Zl(!1),e=Zl("gray");let t=null;const s=Zl(i=>{t=i});async function r(){const i=document.getElementById("canvas"),o=document.getElementById("video"),a=document.getElementById("coords"),l=a.getContext("2d");await fv("webgl"),await G$(o);const c=await FT(nl.mediapipeFacemesh,{shouldLoadIrisModel:!0,maxFaces:1,modelUrl:df+"tfjs/facemesh/model.json",detectorModelUrl:df+"tfjs/blazeface/model.json",irisModelUrl:df+"tfjs/iris/model.json"}),[u,h,d]=_H(i,o);a.width=o.videoWidth,a.height=o.videoHeight,s.value=d,t&&(d(t),t=null);async function p(f){const m=await f.estimateFaces({input:o,predictIrises:!0});n.value=m.length>0,m.length>0,u(m[0],{background:e.value==="camera"}),bH(l,m,!0,!1),requestAnimationFrame(()=>{p(f)})}h(),p(c),window.onresize=h}return n9(r),s9(()=>{window.onresize=null}),{faceOn:n,background:e,onSelectModel:s}}}),ql=n=>(c9("data-v-d2510c42"),n=n(),u9(),n),TX={class:"info"},EX=l9("background "),CX=ql(()=>Vs("option",null,"camera",-1)),MX=ql(()=>Vs("option",null,"white",-1)),AX=ql(()=>Vs("option",null,"gray",-1)),RX=[CX,MX,AX],IX=ql(()=>Vs("video",{id:"video",width:"1",height:"1"},null,-1)),NX=ql(()=>Vs("canvas",{id:"coords"},null,-1));function LX(n,e,t,s,r,i){const o=r9("gallery");return co(),uo(Ef,null,[Vs("div",TX,[Vs("div",null,[EX,i9(Vs("select",{"onUpdate:modelValue":e[0]||(e[0]=a=>n.background=a)},RX,512),[[o9,n.background]])]),Vs("div",null,"face "+Mf(n.faceOn?"on":"detecting..."),1)]),Vs("canvas",{id:"canvas",class:Cf("bg-"+n.background)},null,2),IX,NX,a9(o,{autoSelectFirst:!0,onChange:n.onSelectModel},null,8,["onChange"])],64)}var KX=Af(SX,[["render",LX],["__scopeId","data-v-d2510c42"]]);export{KX as default};
